<link rel="import" href="/resources/polymer/polymer/polymer.html">

<link rel="import" href="/app/tg-app-config.html">
<link rel="import" href="/app/tg-reflector.html">
<link rel="import" href="/resources/serialisation/tg-serialiser.html">
<link rel="import" href="/resources/reflection/tg-polymer-utils.html">
<link rel="import" href="/resources/reflection/tg-date-utils.html">
<link rel="import" href="/resources/components/tg-tooltip-behavior.html">
<link rel="import" href="/resources/components/tg-drag-from-behavior.html">
<link rel="import" href="/resources/actions/tg-ui-action.html">
<link rel="import" href="/resources/layout/tg-flex-layout.html">
<link rel="import" href="/resources/egi/tg-secondary-action-button.html">
<link rel="import" href="/resources/actions/tg-shortcut-processing-behavior.html">
<link rel="import" href="/resources/images/tg-icons.html">

<link rel="import" href="/resources/polymer/iron-flex-layout/iron-flex-layout.html">
<link rel="import" href="/resources/polymer/iron-a11y-keys-behavior/iron-a11y-keys-behavior.html">
<link rel="import" href="/resources/polymer/iron-resizable-behavior/iron-resizable-behavior.html">
<link rel="import" href="/resources/polymer/iron-icon/iron-icon.html">
<link rel="import" href="/resources/polymer/iron-icons/iron-icons.html">
<link rel="import" href="/resources/polymer/iron-collapse/iron-collapse.html">

<link rel="import" href="/resources/polymer/paper-checkbox/paper-checkbox.html">
<link rel="import" href="/resources/polymer/paper-icon-button/paper-icon-button.html">
<link rel="import" href="/resources/polymer/paper-material/paper-material.html">
<link rel="import" href="/resources/polymer/neon-animation/neon-animations.html">
<link rel="import" href="/resources/polymer/paper-button/paper-button.html">
<link rel="import" href="/resources/polymer/paper-progress/paper-progress.html">
<link rel="import" href="/resources/polymer/paper-styles/color.html">

<dom-module id="tg-entity-grid-inspector">
    <style>
        :host {
            @apply(--layout-vertical);

        }
        /*miscellanea styles*/
        .lock-layer {
            opacity: 0.5;
            display: none;
            background-color: white;
        }
        .lock-layer[lock] {
            display: initial;
        }
        .no-flexible {
            flex-grow: 0;
            flex-shrink: 0;
        }
        .absolute,
        .absolutelyWhite {
            position: absolute;
        }
        .absolutelyWhite {
            background-color: white;
            pointer-events: auto;
        }
        .truncate {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .noselect {
            -webkit-touch-callout: none;
            /* iOS Safari */
            -webkit-user-select: none;
            /* Safari */
            -khtml-user-select: none;
            /* Konqueror HTML */
            -moz-user-select: none;
            /* Firefox */
            -ms-user-select: none;
            /* Internet Explorer/Edge */
            user-select: none;
            /* Non-prefixed version, currently
                                  supported by Chrome and Opera */
        }
        .resizing-box {
            position: absolute;
            top: 0;
            bottom: 0;
            right: 0;
            width: 10px;
        }
        .table-cell:hover > .resizing-box,
        .resizing-box:hover,
        .resizing-action {
            cursor: col-resize;
            border-right: 4px solid var(--paper-light-blue-100);
        }
        paper-material {
            border-radius: 2px;
        }
        paper-material[fit-to-height] {
            flex-grow: 1;
        }
        #scrollContainer {
            overflow: auto;
        }
        #lockContainer {
            pointer-events: none;
        }
        paper-progress {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            width: auto;
        }
        paper-progress.uploading {
            --paper-progress-active-color: var(--paper-light-green-500);
        }
        paper-progress.processing {
            --paper-progress-active-color: var(--paper-orange-500);
        }
        /*Table related styles*/
        .data-table {
            background-color: white;
            border-radius: 2px;
            position: relative;
        }
        .table-header-row {
            font-size: 0.9rem;
            font-weight: 400;
            color: #757575;
            height: 3rem;
            -webkit-font-smoothing: antialiased;
            text-rendering: optimizeLegibility;
            min-width: fit-content;
            flex-grow: 0;
            flex-shrink: 0;
        }
        .table-data-row {
            font-size: 1rem;
            font-weight: 400;
            color: #212121;
            height: 1.5rem;
            border-top: 1px solid #e3e3e3;
            -webkit-font-smoothing: antialiased;
            text-rendering: optimizeLegibility;
            min-width: fit-content;
            flex-grow: 0;
            flex-shrink: 0;
        }
        .table-data-row:last-of-type,
        .table-footer-row:last-of-type,
        #bottomShadow {
            margin-bottom: 15px;
        }
        .table-data-row[selected] {
            background-color: #F5F5F5;
        }
        .table-data-row[over] {
            background-color: #EEEEEE;
        }
        .table-footer-row {
            font-size: 0.9rem;
            color: #757575;
            height: 1.5rem;
            border-top: 1px solid #e3e3e3;
            -webkit-font-smoothing: antialiased;
            text-rendering: optimizeLegibility;
            min-width: fit-content;
            background-color: white;
            flex-grow: 0;
            flex-shrink: 0;
        }
        .table-cell,
        .table-data-cell {
            padding: 0 0.6rem;
        }
        .table-data-cell[with-action] {
            cursor: pointer;
        }
        .grid-toolbar {
            height: auto;
            position: relative;
            overflow: hidden;
            flex-grow: 0;
            flex-shrink: 0;
        }
        .grid-toolbar-content::content > * {
            margin-top: 8px;
        }
        paper-checkbox::shadow #checkboxLabel {
            display: none;
        }
        paper-checkbox.blue {
            --paper-checkbox-checked-color: var(--paper-light-blue-700);
            --paper-checkbox-checked-ink-color: var(--paper-light-blue-700);
        }
        paper-checkbox.header {
            --paper-checkbox-unchecked-color: var(--paper-grey-600);
            --paper-checkbox-unchecked-ink-color: var(--paper-grey-600);
        }
        paper-checkbox.body {
            --paper-checkbox-unchecked-color: var(--paper-grey-900);
            --paper-checkbox-unchecked-ink-color: var(--paper-grey-900);
        }
        .table-icon {
            --iron-icon-width: 1.3rem;
            --iron-icon-height: 1.3rem;
        }
        .drag-anchor {
            --iron-icon-width: 1.5rem;
            --iron-icon-height: 1.5rem;
        }
        .drag-anchor[selected]:hover {
            cursor: move;
            /* fallback if grab cursor is unsupported */
            cursor: grab;
            cursor: -moz-grab;
            cursor: -webkit-grab;
        }
        .drag-anchor[selected]:active {
            cursor: grabbing;
            cursor: -moz-grabbing;
            cursor: -webkit-grabbing;
        }
        .dummy-drag-box {
            width: 1.5rem;
            height: 1.5rem;
        }
        /* Action cell related styles*/
        .action-cell {
            width: 20px;
            padding: 0 0.3rem;
        }
        .action {
            --tg-ui-action-icon-button-height: 1.6rem;
            --tg-ui-action-icon-button-width: 1.6rem;
            --tg-ui-action-icon-button-padding: 2px;
            --tg-secondary-action-icon-button-height: 1.6rem;
            --tg-secondary-action-icon-button-width: 1.6rem;
            --tg-secondary-action-icon-button-padding: 2px;
            --tg-ui-action-spinner-width: 1.5rem;
            --tg-ui-action-spinner-height: 1.5rem;
            --tg-ui-action-spinner-min-width: 1rem;
            --tg-ui-action-spinner-min-height: 1rem;
            --tg-ui-action-spinner-max-width: 1.5rem;
            --tg-ui-action-spinner-max-height: 1.5rem;
            --tg-ui-action-spinner-padding: 0px;
            --tg-ui-action-spinner-margin-left: 0;
            --tg-secondary-action-spinner-width: 1.5rem;
            --tg-secondary-action-spinner-height: 1.5rem;
            --tg-secondary-action-spinner-min-width: 1rem;
            --tg-secondary-action-spinner-min-height: 1rem;
            --tg-secondary-action-spinner-max-width: 1.5rem;
            --tg-secondary-action-spinner-max-height: 1.5rem;
            --tg-secondary-action-spinner-padding: 0px;
            --tg-secondary-action-spinner-margin-left: 0;
        }
    </style>
    <template>
        <content id="column_selector" select="tg-property-column" hidden></content>
        <content id="primary_action_selector" select=".primary-action" hidden></content>
        <content id="secondary_action_selector" select=".secondary-action" hidden></content>
        <content id="insertion_point_action_selector" select=".insertion-point-action" hidden></content>
        <tg-app-config id="appConfig"></tg-app-config>
        <tg-reflector id="reflector"></tg-reflector>
        <tg-serialiser id="serialiser"></tg-serialiser>

        <paper-material elevation="1" style="margin: 10px 10px;" fit-to-height$="[[fitToHeight]]" class="layout vertical">
            <div id="elementToFocus" class="layout vertical flex data-table" tabindex="0">
                <!--Table toolbar-->
                <div class="grid-toolbar layout horizontal wrap" hidden$="[[!toolbarVisible]]">
                    <paper-progress id="progressBar" hidden$="[[!_showProgress]]"></paper-progress>
                    <div class="grid-toolbar-content layout horizontal center">
                        <content id="top_action_selctor" select=".entity-specific-action"></content>
                    </div>
                    <div class="grid-toolbar-content layout horizontal center" style="margin-left:auto">
                        <content select=".standart-action"></content>
                    </div>
                </div>
                <div id="baseContainer" class="relative layout horizontal flex" on-wheel="_handleWheel" on-focusin="_baseContainerFocusIn" on-focusout="_baseContainerFocusOut">
                    <div id="scrollContainer" on-scroll="_handleScrollEvent" class="layout vertical flex">
                        <!-- Table header -->
                        <div class="layout horizontal table-header-row">
                            <div class="dummy-drag-box" hidden$="[[!canDragFrom]]"></div>
                            <div class="table-cell layout horizontal center no-flexible" style$="[[_calcSelectCheckBoxStyle(canDragFrom)]]" hidden$="[[!checkboxVisible]]" tooltip-text$="[[_selectAllTooltip(selectedAll)]]">
                                <paper-checkbox class="all-checkbox blue header" hidden$="[[_isCheckboxesOrHeaderFixed(checkboxesFixed, checkboxesWithPrimaryActionsFixed, headerFixed, numOfFixedCols)]]" checked="[[selectedAll]]" on-change="_allSelectionChanged"></paper-checkbox>
                            </div>
                            <template is="dom-if" if="[[primaryAction]]">
                                <div class="action-cell layout horizontal center no-flexible">
                                    <!--Primary action stub header goes here-->
                                </div>
                            </template>
                            <template is="dom-repeat" items="[[columns]]">
                                <div class="table-cell layout horizontal center-center relative" style$="[[_calcColumnHeaderStyle(item, item.width, item.growFactor, index, numOfFixedCols)]]" on-mouseenter="_showResizingCue" on-mouseup="_showResizingCue" on-mouseleave="_hideResizingCue" tooltip-text$="[[item.columnDesc]]">
                                    <div class="truncate" hidden$="[[_isHeaderColumnHidden(headerFixed, index, numOfFixedCols)]]" style="width:100%">[[item.columnTitle]]</div>
                                    <div class="resizing-box" on-down="_makeEgiUnselectable" on-up="_makeEgiSelectable" on-track="_changeColumnSize"></div>
                                </div>
                            </template>
                            <template is="dom-if" if="[[_isSecondaryActionsPresent(secondaryActions)]]">
                                <div class="action-cell layout horizontal center no-flexible">
                                    <!--Secondary actions header goes here-->
                                </div>
                            </template>
                        </div>
                        <!-- Table body -->
                        <template is="dom-repeat" items="[[egiModel]]" as="egiEntity" index-as="entityIndex" on-dom-change="_scrollContainerEntitiesStamped">
                            <div class="layout horizontal table-data-row" selected$="[[egiEntity.selected]]" over$="[[egiEntity.over]]" on-mouseenter="_mouseRowEnter" on-mouseleave="_mouseRowLeave">
                                <iron-icon draggable="true" class="drag-anchor" selected$="[[egiEntity.selected]]" hidden$="[[!canDragFrom]]" style="[[_calcDragAnchorStyle(canDragFrom, dragAnchorFixed, checkboxesFixed, checkboxesWithPrimaryActionsFixed, numOfFixedCols, egiEntity.selected)]]" icon="tg-icons:dragVertical"></iron-icon>
                                <div class="table-cell layout horizontal center no-flexible" style$="[[_calcSelectCheckBoxStyle(canDragFrom)]]" hidden$="[[!checkboxVisible]]" tooltip-text$="[[_selectTooltip(egiEntity.selected)]]">
                                    <paper-checkbox class="blue body" hidden$="[[_isCheckboxesFixed(checkboxesFixed, checkboxesWithPrimaryActionsFixed, numOfFixedCols)]]" checked="[[egiEntity.selected]]" on-change="_selectionChanged" on-mousedown="_checkSelectionState" on-keydown="_checkSelectionState"></paper-checkbox>
                                </div>
                                <template is="dom-if" if="[[primaryAction]]">
                                    <div class="action-cell layout horizontal center no-flexible">
                                        <template is="dom-if" if="[[!_isPrimaryActionsFixed(checkboxesWithPrimaryActionsFixed, numOfFixedCols)]]">
                                            <tg-ui-action class="action" show-dialog="[[primaryAction.showDialog]]" current-entity="[[egiEntity.entity]]" short-desc="[[primaryAction.shortDesc]]" long-desc="[[primaryAction.longDesc]]" icon="[[primaryAction.icon]]" component-uri="[[primaryAction.componentUri]]" element-name="[[primaryAction.elementName]]" action-kind="[[primaryAction.actionKind]]" number-of-action="[[primaryAction.numberOfAction]]" attrs="[[primaryAction.attrs]]" create-context-holder="[[primaryAction.createContextHolder]]" require-selection-criteria="[[primaryAction.requireSelectionCriteria]]" require-selected-entities="[[primaryAction.requireSelectedEntities]]" require-master-entity="[[primaryAction.requireMasterEntity]]" pre-action="[[primaryAction.preAction]]" post-action-success="[[primaryAction.postActionSuccess]]" post-action-error="[[primaryAction.postActionError]]" should-refresh-parent-centre-after-save="[[primaryAction.shouldRefreshParentCentreAfterSave]]" ui-role="[[primaryAction.uiRole]]" icon-style="[[primaryAction.iconStyle]]"></tg-ui-action>
                                        </template>
                                    </div>
                                </template>
                                <template is="dom-repeat" items="[[columns]]" as="column">
                                    <div class="table-data-cell relative layout horizontal center" style$="[[_calcColumnStyle(column, column.width, column.growFactor, index, numOfFixedCols)]]" on-tap="_tapAction" tooltip-text$="[[_getTooltip(egiEntity.entity, column, column.customAction)]]" with-action$="[[hasAction(egiEntity.entity, column)]]">
                                        <template is="dom-if" if="[[!_isColumnFixed(index, numOfFixedCols)]]">
                                            <div class="fit" style$="[[_calcBackgroundRenderingHintsStyle(egiEntity.renderingHints.*, entityIndex, column.property)]]"></div>
                                            <iron-icon class="table-icon" hidden$="[[!_isBooleanProp(egiEntity.entity, column)]]" style$="[[_calcValueRenderingHintsStyle(egiEntity.renderingHints.*, entityIndex, column.property, 'true')]]" icon="[[_getBooleanIcon(egiEntity.entity, column.property)]]"></iron-icon>
                                            <a class="truncate" hidden$="[[!_isHyperlinkProp(egiEntity.entity, column)]]" href$="[[_getBindedValue(egiEntity.entity.*, column.property, column.type)]]" style$="[[_calcValueRenderingHintsStyle(egiEntity.renderingHints.*, entityIndex, column.property, 'false')]]">[[_getBindedValue(egiEntity.entity.*, column.property, column.type)]]</a>
                                            <div class="truncate relative" hidden$="[[!_isNotBooleanOrHyperlinkProp(egiEntity.entity, column)]]" style$="[[_calcValueRenderingHintsStyle(egiEntity.renderingHints.*, entityIndex, column.property, 'false')]]">[[_getBindedValue(egiEntity.entity.*, column.property, column.type)]]</div>
                                        </template>
                                    </div>
                                </template>
                                <template is="dom-if" if="[[_isSecondaryActionsPresent(secondaryActions)]]">
                                    <div class="action-cell layout horizontal center no-flexible">
                                        <template is="dom-if" if="[[!_isSecondaryActionsFixed(secondaryActionsFixed)]]">
                                            <template is="dom-if" if="[[_isOnlyOneSecondaryActions(secondaryActions)]]">
                                                <tg-ui-action class="action" show-dialog="[[secondaryActions.0.showDialog]]" current-entity="[[egiEntity.entity]]" short-desc="[[secondaryActions.0.shortDesc]]" long-desc="[[secondaryActions.0.longDesc]]" icon="[[secondaryActions.0.icon]]" component-uri="[[secondaryActions.0.componentUri]]" element-name="[[secondaryActions.0.elementName]]" action-kind="[[secondaryActions.0.actionKind]]" number-of-action="[[secondaryActions.0.numberOfAction]]" attrs="[[secondaryActions.0.attrs]]" create-context-holder="[[secondaryActions.0.createContextHolder]]" require-selection-criteria="[[secondaryActions.0.requireSelectionCriteria]]" require-selected-entities="[[secondaryActions.0.requireSelectedEntities]]" require-master-entity="[[secondaryActions.0.requireMasterEntity]]" pre-action="[[secondaryActions.0.preAction]]" post-action-success="[[secondaryActions.0.postActionSuccess]]" post-action-error="[[secondaryActions.0.postActionError]]" should-refresh-parent-centre-after-save="[[secondaryActions.0.shouldRefreshParentCentreAfterSave]]" ui-role="[[secondaryActions.0.uiRole]]" icon-style="[[secondaryActions.0.iconStyle]]"></tg-ui-action>
                                            </template>
                                            <template is="dom-if" if="[[!_isOnlyOneSecondaryActions(secondaryActions)]]">
                                                <tg-secondary-action-button class="action" current-entity="[[egiEntity.entity]]" actions="[[secondaryActions]]"></tg-secondary-action-button>
                                            </template>
                                        </template>
                                    </div>
                                </template>
                            </div>
                        </template>
                        <!-- Table footer -->
                        <!--div class="flex"></div-->
                        <template is="dom-if" if="[[totals]]">
                            <template is="dom-repeat" items="[[_totalsRows]]" as="summaryRow" index-as="summaryIndex">
                                <div class="layout horizontal table-footer-row" style$="[[_calcFooterRowStyle(summaryFixed, summaryIndex, fitToHeight)]]">
                                    <div class="dummy-drag-box" hidden$="[[!canDragFrom]]"></div>
                                    <div class="table-cell layout horizontal center no-flexible" style$="[[_calcSelectCheckBoxStyle(canDragFrom)]]" hidden$="[[!checkboxVisible]]">
                                        <!-- checkbox stub for table footer -->
                                    </div>
                                    <template is="dom-if" if="[[primaryAction]]">
                                        <div class="action-cell layout horizontal center no-flexible">
                                            <!--Primary action footer goes here-->
                                        </div>
                                    </template>
                                    <template is="dom-repeat" items="[[columns]]" as="column" index-as="columnIndex">
                                        <template is="dom-if" if="[[_summaryExists(column, summaryIndex, columnIndex)]]" restamp>
                                            <div class="table-cell layout horizontal center" style$="[[_calcSummaryColumnStyle(column, column.width, column.growFactor, columnIndex, numOfFixedCols)]]" tooltip-text$="[[_getTotalTooltip(columnIndex, summaryIndex)]]">
                                                <template is="dom-if" if="[[!_isColumnFixed(columnIndex, numOfFixedCols)]]">
                                                    <iron-icon class="table-icon" hidden$="[[!_isSummaryBooleanProp(totals, columnIndex, summaryIndex, columns)]]" icon="[[_getSummaryBooleanIcon(totals, columnIndex, summaryIndex, column)]]"></iron-icon>
                                                    <a class="truncate" hidden$="[[!_isSummaryHyperlinkProp(totals, columnIndex, summaryIndex, column)]]" href$="[[_getSummaryValue(totals, columnIndex, summaryIndex, column)]]">[[_getSummaryValue(totals, columnIndex, summaryIndex, column)]]</a>
                                                    <div class="truncate relative" hidden$="[[!_isSummaryNotBooleanOrHyperlinkProp(totals, columnIndex, summaryIndex, column)]]" style="width:100%">[[_getSummaryValue(totals, columnIndex, summaryIndex, column)]]</div>
                                                </template>
                                            </div>
                                        </template>
                                        <template is="dom-if" if="[[!_summaryExists(column, summaryIndex, columnIndex)]]" restamp>
                                            <div class="table-cell" style$="[[_calcEmptyTotalStyle(column, column.width, column.growFactor, columnIndex, numOfFixedCols)]]">
                                            </div>
                                        </template>
                                    </template>
                                    <template is="dom-if" if="[[_isSecondaryActionsPresent(secondaryActions)]]">
                                        <div class="action-cell layout horizontal center no-flexible">
                                            <!--Secondary actions header goes here-->
                                        </div>
                                    </template>
                                </div>
                            </template>
                        </template>
                    </div>
                    <!-- Fixed container -->
                    <div id="lockContainer" class="absolute fit" style="overflow:hidden" on-focusin="_lockContainerFocusIn" on-focusout="_lockContainerFocusOut">
                        <template is="dom-if" on-dom-change="_leftLockPanelRendered" if="[[_isLeftLockPanelVisble(canDragFrom, dragAnchorFixed, checkboxVisible, checkboxesFixed, primaryAction, checkboxesWithPrimaryActionsFixed, numOfFixedCols)]]">
                            <div id="leftLockPanel" class="absolutelyWhite layout vertical" style$="[[_calculateLeftLockPanelStyle(_showLeftShadow, _scrollTop, headerFixed)]]">
                                <!--header-->
                                <div class="layout horizontal table-header-row" hidden$="[[_isHeaderFixed(headerFixed)]]">
                                    <div class="dummy-drag-box" hidden$="[[!canDragFrom]]"></div>
                                    <div class="table-cell layout horizontal center no-flexible" style$="[[_calcSelectCheckBoxStyle(canDragFrom)]]" hidden$="[[!_isCheckboxesVisibleAndFixed(checkboxVisible, checkboxesFixed, checkboxesWithPrimaryActionsFixed, numOfFixedCols)]]" tooltip-text$="[[_selectAllTooltip(selectedAll)]]">
                                        <paper-checkbox class="blue header" checked="[[selectedAll]]" on-change="_allSelectionChanged"></paper-checkbox>
                                    </div>
                                    <template is="dom-if" if="[[_isPrimaryActionVisibleAndFixed(primaryAction, checkboxesWithPrimaryActionsFixed, numOfFixedCols)]]">
                                        <div class="action-cell layout horizontal center no-flexible">
                                            <!--Primary action stub header goes here-->
                                        </div>
                                    </template>
                                    <template is="dom-repeat" items="[[columns]]">
                                        <div class="table-cell layout horizontal center-center relative" hidden$="[[!_isColumnFixed(index, numOfFixedCols)]]" style$="[[_calcColumnHeaderStyle(item, item.width, item.growFactor, index, numOfFixedCols)]]" on-mouseenter="_showResizingCue" on-mouseup="_showResizingCue" on-mouseleave="_hideResizingCue" tooltip-text$="[[item.columnDesc]]">
                                            <div class="truncate" style="width:100%">[[item.columnTitle]]</div>
                                            <div class="resizing-box" on-down="_makeEgiUnselectable" on-up="_makeEgiSelectable" on-track="_changeColumnSize"></div>
                                        </div>
                                    </template>
                                </div>
                                <!--body-->
                                <template is="dom-repeat" items="[[egiModel]]" as="egiEntity" index-as="entityIndex">
                                    <div class="layout horizontal table-data-row" selected$="[[egiEntity.selected]]" over$="[[egiEntity.over]]" on-mouseenter="_mouseRowEnter" on-mouseleave="_mouseRowLeave">
                                        <iron-icon draggable="true" class="drag-anchor" selected$="[[egiEntity.selected]]" hidden$="[[!canDragFrom]]" style="[[_calcFixedDragAnchorStyle(canDragFrom, egiEntity.selected)]]" icon="tg-icons:dragVertical"></iron-icon>
                                        <div class="table-cell layout horizontal center no-flexible" style$="[[_calcSelectCheckBoxStyle(canDragFrom)]]" hidden$="[[!_isCheckboxesVisibleAndFixed(checkboxVisible, checkboxesFixed, checkboxesWithPrimaryActionsFixed, numOfFixedCols)]]" tooltip-text$="[[_selectTooltip(egiEntity.selected)]]">
                                            <paper-checkbox class="blue body" checked="[[egiEntity.selected]]" on-change="_selectionChanged" on-mousedown="_checkSelectionState" on-keydown="_checkSelectionState"></paper-checkbox>
                                        </div>
                                        <template is="dom-if" if="[[_isPrimaryActionVisibleAndFixed(primaryAction, checkboxesWithPrimaryActionsFixed, numOfFixedCols)]]">
                                            <div class="action-cell layout horizontal center no-flexible">
                                                <tg-ui-action class="action" show-dialog="[[primaryAction.showDialog]]" current-entity="[[egiEntity.entity]]" short-desc="[[primaryAction.shortDesc]]" long-desc="[[primaryAction.longDesc]]" icon="[[primaryAction.icon]]" component-uri="[[primaryAction.componentUri]]" element-name="[[primaryAction.elementName]]" action-kind="[[primaryAction.actionKind]]" number-of-action="[[primaryAction.numberOfAction]]" attrs="[[primaryAction.attrs]]" create-context-holder="[[primaryAction.createContextHolder]]" require-selection-criteria="[[primaryAction.requireSelectionCriteria]]" require-selected-entities="[[primaryAction.requireSelectedEntities]]" require-master-entity="[[primaryAction.requireMasterEntity]]" pre-action="[[primaryAction.preAction]]" post-action-success="[[primaryAction.postActionSuccess]]" post-action-error="[[primaryAction.postActionError]]" should-refresh-parent-centre-after-save="[[primaryAction.shouldRefreshParentCentreAfterSave]]" ui-role="[[primaryAction.uiRole]]" icon-style="[[primaryAction.iconStyle]]"></tg-ui-action>
                                            </div>
                                        </template>
                                        <template is="dom-repeat" items="[[columns]]" as="column">
                                            <div class="table-data-cell relative layout horizontal center" hidden$="[[!_isColumnFixed(index, numOfFixedCols)]]" style$="[[_calcColumnStyle(column, column.width, column.growFactor, index, numOfFixedCols)]]" on-tap="_tapAction" tooltip-text$="[[_getTooltip(egiEntity.entity, column, column.customAction)]]" with-action$="[[hasAction(egiEntity.entity, column)]]">
                                                <div class="fit" style$="[[_calcBackgroundRenderingHintsStyle(egiEntity.renderingHints.*, entityIndex, column.property)]]"></div>
                                                <iron-icon class="table-icon" hidden$="[[!_isBooleanProp(egiEntity.entity, column)]]" style$="[[_calcValueRenderingHintsStyle(egiEntity.renderingHints.*, entityIndex, column.property, 'true')]]" icon="[[_getBooleanIcon(egiEntity.entity, column.property)]]"></iron-icon>
                                                <a class="truncate" hidden$="[[!_isHyperlinkProp(egiEntity.entity, column)]]" href$="[[_getBindedValue(egiEntity.entity.*, column.property, column.type)]]" style$="[[_calcValueRenderingHintsStyle(egiEntity.renderingHints.*, entityIndex, column.property, 'false')]]">[[_getBindedValue(egiEntity.entity.*, column.property, column.type)]]</a>
                                                <div class="truncate relative" hidden$="[[!_isNotBooleanOrHyperlinkProp(egiEntity.entity, column)]]" style$="[[_calcValueRenderingHintsStyle(egiEntity.renderingHints.*, entityIndex, column.property, 'false')]]">[[_getBindedValue(egiEntity.entity.*, column.property, column.type)]]</div>
                                            </div>
                                        </template>
                                    </div>
                                </template>
                                <!--footer-->
                                <template is="dom-if" if="[[_isSummaryNotFixedAndPresent(totals, summaryFixed)]]">
                                    <template is="dom-repeat" items="[[_totalsRows]]" as="summaryRow" index-as="summaryIndex">
                                        <div class="layout horizontal table-footer-row" style$="[[_calcFixedFooterRowStyle(summaryIndex, fitToHeight)]]">
                                            <div class="dummy-drag-box" hidden$="[[!canDragFrom]]"></div>
                                            <div class="table-cell no-flexible" style$="[[_calcSelectCheckBoxStyle(canDragFrom)]]" hidden$="[[!_isCheckboxesVisibleAndFixed(checkboxVisible, checkboxesFixed, checkboxesWithPrimaryActionsFixed, numOfFixedCols)]]">
                                                <!-- checkbox stub for table footer -->
                                            </div>
                                            <template is="dom-if" if="[[_isPrimaryActionVisibleAndFixed(primaryAction, checkboxesWithPrimaryActionsFixed, numOfFixedCols)]]">
                                                <div class="action-cell no-flexible">
                                                    <!--Primary action footer goes here-->
                                                </div>
                                            </template>
                                            <template is="dom-repeat" items="[[columns]]" as="column" index-as="columnIndex">
                                                <template is="dom-if" if="[[_isColumnFixed(columnIndex, numOfFixedCols)]]">
                                                    <template is="dom-if" if="[[_summaryExists(column, summaryIndex, columnIndex)]]" restamp>
                                                        <div class="table-cell layout horizontal center" style$="[[_calcSummaryColumnStyle(column, column.width, column.growFactor, columnIndex, numOfFixedCols)]]" tooltip-text$="[[_getTotalTooltip(columnIndex, summaryIndex)]]">
                                                            <iron-icon class="table-icon" hidden$="[[!_isSummaryBooleanProp(totals, columnIndex, summaryIndex, column)]]" icon="[[_getSummaryBooleanIcon(totals, columnIndex, summaryIndex, column)]]"></iron-icon>
                                                            <a class="truncate" hidden$="[[!_isSummaryHyperlinkProp(totals, columnIndex, summaryIndex, column)]]" href$="[[_getSummaryValue(totals, columnIndex, summaryIndex, column)]]">[[_getSummaryValue(totals, columnIndex, summaryIndex, column)]]</a>
                                                            <div class="truncate relative" hidden$="[[!_isSummaryNotBooleanOrHyperlinkProp(totals, columnIndex, summaryIndex, column)]]" style="width:100%">[[_getSummaryValue(totals, columnIndex, summaryIndex, column)]]</div>
                                                        </div>
                                                    </template>
                                                    <template is="dom-if" if="[[!_summaryExists(column, summaryIndex, columnIndex)]]" restamp>
                                                        <div class="table-cell" style$="[[_calcEmptyTotalStyle(column, column.width, column.growFactor, columnIndex, numOfFixedCols)]]"></div>
                                                    </template>
                                                </template>
                                            </template>
                                        </div>
                                    </template>
                                </template>
                            </div>
                        </template>
                        <template is="dom-if" if="[[_isLeftLockPanelVisble(canDragFrom, dragAnchorFixed, checkboxVisible, checkboxesFixed, primaryAction, checkboxesWithPrimaryActionsFixed, numOfFixedCols)]]">
                            <div id="leftShadow" class="absolute" style$="[[_calcLeftShadowStyle(canDragFrom, dragAnchorFixed, checkboxVisible, checkboxesFixed, primaryAction, checkboxesWithPrimaryActionsFixed, numOfFixedCols, _showLeftShadow, _fixedColumnWidth, _scrollableColumnWidth)]]"></div>
                        </template>
                        <template is="dom-if" on-dom-change="_rightLockPanelRendered" if="[[_isSecondaryActionsPresentAndFixed(secondaryActions, secondaryActionsFixed)]]">
                            <div id="rightLockPanel" class="absolutelyWhite layout vertical" style$="[[_calculateRightLockPanelStyle(_showRightShadow, _scrollTop, headerFixed, columns)]]">
                                <!--header-->
                                <div class="layout horizontal table-header-row" hidden$="[[_isHeaderFixed(headerFixed)]]">
                                    <div class="action-cell layout horizontal center no-flexible">
                                        <!--Secondary actions header goes here-->
                                    </div>
                                </div>
                                <!--body-->
                                <template is="dom-repeat" items="[[egiModel]]" as="egiEntity" index-as="entityIndex">
                                    <div class="action-cell layout horizontal center table-data-row no-flexible" selected$="[[egiEntity.selected]]" over$="[[egiEntity.over]]" on-mouseenter="_mouseRowEnter" on-mouseleave="_mouseRowLeave">
                                        <template is="dom-if" if="[[_isOnlyOneSecondaryActions(secondaryActions)]]">
                                            <tg-ui-action class="action" show-dialog="[[secondaryActions.0.showDialog]]" current-entity="[[egiEntity.entity]]" short-desc="[[secondaryActions.0.shortDesc]]" long-desc="[[secondaryActions.0.longDesc]]" icon="[[secondaryActions.0.icon]]" component-uri="[[secondaryActions.0.componentUri]]" element-name="[[secondaryActions.0.elementName]]" action-kind="[[secondaryActions.0.actionKind]]" number-of-action="[[secondaryActions.0.numberOfAction]]" attrs="[[secondaryActions.0.attrs]]" create-context-holder="[[secondaryActions.0.createContextHolder]]" require-selection-criteria="[[secondaryActions.0.requireSelectionCriteria]]" require-selected-entities="[[secondaryActions.0.requireSelectedEntities]]" require-master-entity="[[secondaryActions.0.requireMasterEntity]]" pre-action="[[secondaryActions.0.preAction]]" post-action-success="[[secondaryActions.0.postActionSuccess]]" post-action-error="[[secondaryActions.0.postActionError]]" should-refresh-parent-centre-after-save="[[secondaryActions.0.shouldRefreshParentCentreAfterSave]]" ui-role="[[secondaryActions.0.uiRole]]" icon-style="[[secondaryActions.0.iconStyle]]"></tg-ui-action>
                                        </template>
                                        <template is="dom-if" if="[[!_isOnlyOneSecondaryActions(secondaryActions)]]">
                                            <tg-secondary-action-button class="action" current-entity="[[egiEntity.entity]]" actions="[[secondaryActions]]"></tg-secondary-action-button>
                                        </template>
                                    </div>
                                </template>
                                <!--footer-->
                                <template is="dom-if" if="[[_isSummaryNotFixedAndPresent(totals, summaryFixed)]]">
                                    <template is="dom-repeat" items="[[_totalsRows]]">
                                        <div class="layout horizontal table-footer-row" style$="[[_calcFixedFooterRowStyle(index, fitToHeight)]]">
                                            <div class="action-cell layout horizontal center no-flexible">
                                                <!--Secondary actions header goes here-->
                                            </div>
                                        </div>
                                    </template>
                                </template>
                            </div>
                        </template>
                        <template is="dom-if" if="[[_isSecondaryActionsPresentAndFixed(secondaryActions, secondaryActionsFixed)]]">
                            <div id="topShadow" class="absolute" style$="[[_calcRightShadowStyle(secondaryActions, secondaryActionsFixed, _showRightShadow, _fixedColumnWidth, _scrollableColumnWidth)]]"></div>
                        </template>
                        <template is="dom-if" on-dom-change="_topLockPanelRendered" if="[[_isHeaderFixed(headerFixed)]]">
                            <div id="topLockPanel" class="absolutelyWhite layout horizontal table-header-row" style$="[[_calculateTopLockPanelStyle(canDragFrom, dragAnchorFixed, checkboxVisible, primaryAction, checkboxesFixed, checkboxesWithPrimaryActionsFixed, secondaryActions, secondaryActionsFixed, numOfFixedCols, _scrollLeft, _fixedColumnWidth, _scrollableColumnWidth)]]">
                                <div class="dummy-drag-box" hidden$="[[!_isDragAnchorNotFixedAndVisble(canDragFrom, dragAnchorFixed, checkboxesFixed, checkboxesWithPrimaryActionsFixed, numOfFixedCols)]]"></div>
                                <div class="table-cell layout horizontal center no-flexible" style$="[[_calcSelectCheckBoxStyle(canDragFrom)]]" hidden$="[[!_isCheckboxesNotFixedAndVisible(checkboxVisible, checkboxesFixed, checkboxesWithPrimaryActionsFixed, numOfFixedCols)]]" tooltip-text$="[[_selectAllTooltip(selectedAll)]]">
                                    <paper-checkbox class="blue header" checked="[[selectedAll]]" on-change="_allSelectionChanged"></paper-checkbox>
                                </div>
                                <template is="dom-if" if="[[_isPrimaryActionsNotFixedAndPresent(primaryAction, checkboxesWithPrimaryActionsFixed, numOfFixedCols)]]">
                                    <div class="action-cell layout horizontal center no-flexible">
                                        <!--Primary action stub header goes here-->
                                    </div>
                                </template>
                                <template is="dom-repeat" items="[[columns]]">
                                    <div class="table-cell layout horizontal center relative" hidden$="[[_isColumnFixed(index, numOfFixedCols)]]" style$="[[_calcColumnHeaderStyle(item, item.width, item.growFactor, index, numOfFixedCols)]]" on-mouseenter="_showResizingCue" on-mouseup="_showResizingCue" on-mouseleave="_hideResizingCue" tooltip-text$="[[item.columnDesc]]">
                                        <div class="truncate" style="width:100%">[[item.columnTitle]]</div>
                                        <div class="resizing-box" on-down="_makeEgiUnselectable" on-up="_makeEgiSelectable" on-track="_changeColumnSize"></div>
                                    </div>
                                </template>
                                <template is="dom-if" if="[[_isSecondaryActionsPresentAndNotFixed(secondaryActions, secondaryActionsFixed)]]">
                                    <div class="action-cell layout horizontal center no-flexible">
                                        <!--Secondary actions header goes here-->
                                    </div>
                                </template>
                            </div>
                        </template>
                        <template is="dom-if" on-dom-change="_bottomLockPanelRendered" if="[[_isSummaryPresentAndFixed(totals, summaryFixed)]]">
                            <div id="bottomLockPanel" class="absolutelyWhite layout horizontal" style$="[[_calculateBottomLockPanelStyle(canDragFrom, dragAnchorFixed, checkboxVisible, primaryAction, checkboxesFixed, checkboxesWithPrimaryActionsFixed, secondaryActions, secondaryActionsFixed, numOfFixedCols, _scrollLeft, _fixedColumnWidth, _scrollableColumnWidth)]]">
                                <div class="layout vertical flex" style="background-color:white;">
                                    <template is="dom-repeat" items="[[_totalsRows]]" as="summaryRow" index-as="summaryIndex">
                                        <div class="layout horizontal table-footer-row">
                                            <div class="dummy-drag-box" hidden$="[[!_isDragAnchorNotFixedAndVisble(canDragFrom, dragAnchorFixed, checkboxesFixed, checkboxesWithPrimaryActionsFixed, numOfFixedCols)]]"></div>
                                            <div class="table-cell layout horizontal center no-flexible" style$="[[_calcSelectCheckBoxStyle(canDragFrom)]]" hidden$="[[!_isCheckboxesNotFixedAndVisible(checkboxVisible, checkboxesFixed, checkboxesWithPrimaryActionsFixed, numOfFixedCols)]]" tooltip-text$="[[_selectAllTooltip(selectedAll)]]">
                                            </div>
                                            <template is="dom-if" if="[[_isPrimaryActionsNotFixedAndPresent(primaryAction, checkboxesWithPrimaryActionsFixed, numOfFixedCols)]]">
                                                <div class="action-cell layout horizontal center no-flexible">
                                                    <!--Primary action stub header goes here-->
                                                </div>
                                            </template>
                                            <template is="dom-repeat" items="[[columns]]" as="column" index-as="columnIndex">
                                                <template is="dom-if" if="[[!_isColumnFixed(columnIndex, numOfFixedCols)]]">
                                                    <template is="dom-if" if="[[_summaryExists(column, summaryIndex, columnIndex)]]" restamp>
                                                        <div class="table-cell layout horizontal center" style$="[[_calcSummaryColumnStyle(column, column.width, column.growFactor, columnIndex, numOfFixedCols)]]" tooltip-text$="[[_getTotalTooltip(columnIndex, summaryIndex)]]">
                                                            <iron-icon class="table-icon" hidden$="[[!_isSummaryBooleanProp(totals, columnIndex, summaryIndex, column)]]" icon="[[_getSummaryBooleanIcon(totals, columnIndex, summaryIndex, column)]]"></iron-icon>
                                                            <a class="truncate" hidden$="[[!_isSummaryHyperlinkProp(totals, columnIndex, summaryIndex, column)]]" href$="[[_getSummaryValue(totals, columnIndex, summaryIndex, column)]]">[[_getSummaryValue(totals, columnIndex, summaryIndex, column)]]</a>
                                                            <div class="truncate relative" hidden$="[[!_isSummaryNotBooleanOrHyperlinkProp(totals, columnIndex, summaryIndex, column)]]" style="width:100%">[[_getSummaryValue(totals, columnIndex, summaryIndex, column)]]</div>
                                                        </div>
                                                    </template>
                                                    <template is="dom-if" if="[[!_summaryExists(column, summaryIndex, columnIndex)]]" restamp>
                                                        <div class="table-cell" style$="[[_calcEmptyTotalStyle(column, column.width, column.growFactor, columnIndex, numOfFixedCols)]]">
                                                        </div>
                                                    </template>
                                                </template>
                                            </template>
                                            <template is="dom-if" if="[[_isSecondaryActionsPresentAndNotFixed(secondaryActions, secondaryActionsFixed)]]">
                                                <div class="action-cell layout horizontal center no-flexible">
                                                    <!--Secondary actions header goes here-->
                                                </div>
                                            </template>
                                        </div>
                                    </template>
                                </div>
                            </div>
                        </template>
                        <template is="dom-if" if="[[_isTopLeftPanelVisible(canDragFrom, dragAnchorFixed, checkboxVisible, checkboxesFixed, primaryAction, checkboxesWithPrimaryActionsFixed, numOfFixedCols, headerFixed)]]">
                            <div id="topLeftLockPanel" class="absolutelyWhite layout horizontal table-header-row" style="top:0;left:0">
                                <div class="dummy-drag-box" hidden$="[[!canDragFrom]]"></div>
                                <div class="table-cell layout horizontal center no-flexible" style$="[[_calcSelectCheckBoxStyle(canDragFrom)]]" hidden$="[[!_isCheckboxesVisibleAndFixed(checkboxVisible, checkboxesFixed, checkboxesWithPrimaryActionsFixed, numOfFixedCols)]]" tooltip-text$="[[_selectAllTooltip(selectedAll)]]">
                                    <paper-checkbox class="all-checkbox blue header" checked="[[selectedAll]]" on-change="_allSelectionChanged"></paper-checkbox>
                                </div>
                                <template is="dom-if" if="[[_isPrimaryActionVisibleAndFixed(primaryAction, checkboxesWithPrimaryActionsFixed, numOfFixedCols)]]">
                                    <div class="action-cell no-flexible">
                                        <!--Primary action stub header goes here-->
                                    </div>
                                </template>
                                <template is="dom-repeat" items="[[columns]]">
                                    <div class="table-cell layout horizontal center relative" hidden$="[[!_isColumnFixed(index, numOfFixedCols)]]" style$="[[_calcColumnHeaderStyle(item, item.width, item.growFactor, index, numOfFixedCols)]]" on-mouseenter="_showResizingCue" on-mouseup="_showResizingCue" on-mouseleave="_hideResizingCue" tooltip-text$="[[item.columnDesc]]">
                                        <div class="truncate" style="width:100%">[[item.columnTitle]]</div>
                                        <div class="resizing-box" on-down="_makeEgiUnselectable" on-up="_makeEgiSelectable" on-track="_changeColumnSize"></div>
                                    </div>
                                </template>
                            </div>
                        </template>
                        <template is="dom-if" if="[[_isTopRightPanelVisible(secondaryActions, secondaryActionsFixed, headerFixed)]]">
                            <div id="topRightLockPanel" class="absolutelyWhite layout horizontal table-header-row action-cell" style="top:0;right:0">
                                <!-- secondary action header column -->
                            </div>
                        </template>
                        <template is="dom-if" if="[[_isBottomLeftPanelVisible(totals, summaryFixed, canDragFrom, dragAnchorFixed, checkboxVisible, checkboxesFixed, primaryAction, checkboxesWithPrimaryActionsFixed, numOfFixedCols)]]">
                            <div id="bottomLeftLockPanel" class="absolutelyWhite layout vertical" style="bottom:0;left:0">
                                <template is="dom-repeat" items="[[_totalsRows]]" as="summaryRow" index-as="summaryIndex">
                                    <div class="layout horizontal table-footer-row">
                                        <div class="dummy-drag-box" hidden$="[[!canDragFrom]]"></div>
                                        <div class="table-cell no-flexible" style$="[[_calcSelectCheckBoxStyle(canDragFrom)]]" hidden$="[[!_isCheckboxesVisibleAndFixed(checkboxVisible, checkboxesFixed, checkboxesWithPrimaryActionsFixed, numOfFixedCols)]]">
                                            <!-- checkbox stub for table footer -->
                                        </div>
                                        <template is="dom-if" if="[[_isPrimaryActionVisibleAndFixed(primaryAction, checkboxesWithPrimaryActionsFixed, numOfFixedCols)]]">
                                            <div class="action-cell no-flexible">
                                                <!--Primary action footer goes here-->
                                            </div>
                                        </template>
                                        <template is="dom-repeat" items="[[columns]]" as="column" index-as="columnIndex">
                                            <template is="dom-if" if="[[_isColumnFixed(columnIndex, numOfFixedCols)]]">
                                                <template is="dom-if" if="[[_summaryExists(column, summaryIndex, columnIndex)]]" restamp>
                                                    <div class="table-cell layout horizontal center" style$="[[_calcSummaryColumnStyle(column, column.width, column.growFactor, columnIndex, numOfFixedCols)]]" tooltip-text$="[[_getTotalTooltip(columnIndex, summaryIndex)]]">
                                                        <iron-icon class="table-icon" hidden$="[[!_isSummaryBooleanProp(totals, columnIndex, summaryIndex, column)]]" icon="[[_getSummaryBooleanIcon(totals, columnIndex, summaryIndex, column)]]"></iron-icon>
                                                        <a class="truncate" hidden$="[[!_isSummaryHyperlinkProp(totals, columnIndex, summaryIndex, column)]]" href$="[[_getSummaryValue(totals, columnIndex, summaryIndex, column)]]">[[_getSummaryValue(totals, columnIndex, summaryIndex, column)]]</a>
                                                        <div class="truncate relative" hidden$="[[!_isSummaryNotBooleanOrHyperlinkProp(totals, columnIndex, summaryIndex, column)]]" style="width:100%">[[_getSummaryValue(totals, columnIndex, summaryIndex, column)]]</div>
                                                    </div>
                                                </template>
                                                <template is="dom-if" if="[[!_summaryExists(column, summaryIndex, columnIndex)]]" restamp>
                                                    <div class="table-cell" style$="[[_calcEmptyTotalStyle(column, column.width, column.growFactor, columnIndex, numOfFixedCols)]]">
                                                    </div>
                                                </template>
                                            </template>
                                        </template>
                                    </div>
                                </template>
                            </div>
                        </template>
                        <template is="dom-if" if="[[_isBottomRightPanelVisible(totals, summaryFixed, secondaryActions, secondaryActionsFixed)]]">
                            <div id="bottomRightLockPanel" class="absolutelyWhite layout vertical" style="bottom:0;right:0">
                                <template is="dom-repeat" items="[[_totalsRows]]">
                                    <template is="dom-if" if="[[_isSecondaryActionsPresent(secondaryActions)]]">
                                        <div class="table-footer-row action-cell">
                                            <!--Secondary actions header goes here-->
                                        </div>
                                    </template>
                                </template>
                            </div>
                        </template>
                        <div id="bottomShadow" class="absolute" hidden$="[[!_isSummaryPresentAndFixed(totals, summaryFixed)]]" style$="[[_calcBottomShadowStyle(_totalsRowCount, _showBottomShadow)]]"></div>
                        <div id="topShadow" class="absolute" hidden$="[[!_isHeaderFixed(headerFixed)]]" style$="[[_calcTopShadowStyle(_showTopShadow)]]"></div>
                        <div id="tbShadow" class="absolute" hidden$="[[_isHeaderFixed(headerFixed)]]" style$="[[_calcTBShadowStyle(_showTopShadow)]]"></div>
                    </div>
                </div>
                <!-- table lock layer -->
                <div class="lock-layer fit" lock$="[[lock]]"></div>
            </div>
        </paper-material>
    </template>
</dom-module>
<script>
    (function () {
        const _areEqual = function (a, b) {
            return a && b && a.get('id') === b.get('id');
        };
        const _findEntity = function (entity, entities) {
            for (var i = 0; i < entities.length; i += 1) {
                if (_areEqual(entity, entities[i])) {
                    return i;
                }
            }
            return -1;
        };
        const _processEntitySelection = function (selectedEntities, entity, select) {
            var selectedIndex = _findEntity(entity, selectedEntities);
            if (select) {
                if (selectedIndex < 0) {
                    selectedEntities.push(entity);
                }
            } else {
                if (selectedIndex >= 0) {
                    selectedEntities.splice(selectedIndex, 1);
                }
            }
        };
        const generateShortCollection = function (entity, property, typeObject) {
            var collectionValue = entity.get(property);
            var containerPropertyValue = entity.get(property.substr(0, property.lastIndexOf('.')));
            var keys = typeObject.compositeKeyNames();
            return collectionValue.map(function (subEntity) {
                var key = keys.find(function (key) {
                    if (subEntity.get(key) !== containerPropertyValue) {
                        return key;
                    }
                });
                return subEntity.get(key);
            });
        };
        const calculateFixedColumnWidth = function (columns, numOfFixedColumns) {
            return columns.reduce((accum, curr, index) => accum += (index < numOfFixedColumns ? curr.width : 0), 0);
        };
        const calculateScrollableColumnWidth = function (columns, numOfFixedColumns) {
            return columns.reduce((accum, curr, index) => accum += (index >= numOfFixedColumns ? curr.width : 0), 0);
        }
        const calculateColumnWidthExcept = function (egi, columnIndex, columnElements, columnLength, checkboxes, primaryActions, secondaryActions) {
            let columnWidth = 0;
            const indexCorrection = 1 + (+!!egi.primaryAction);
            if (egi.checkboxVisible && checkboxes()) {
                columnWidth += columnElements[0].offsetWidth;
            }
            if (egi.primaryAction && primaryActions()) {
                columnWidth += columnElements[1].offsetWidth;
            }
            for (let i = 0; i < columnLength; i++) {
                if (columnIndex !== i) {
                    columnWidth += columnElements[i + indexCorrection].offsetWidth;
                }
            }
            if (egi.secondaryActions.length > 0 && secondaryActions()) {
                columnWidth += columnElements[columnElements.length - 1].offsetWidth;
            }
            return columnWidth;
        };
        const updateSelectAll = function (egi, egiModel) {
            if (egiModel.length > 0 && egiModel.every(elem => elem.selected)) {
                egi.selectedAll = true;
            } else {
                egi.selectedAll = false;
            }
        };
        const removeColumn = function (column, fromColumns) {
            const index = fromColumns.indexOf(column);
            if (index >= 0) {
                fromColumns.splice(index, 1);
                return true;
            }
            return false;
        };
        const sign = (value) => value < 0 ? -1 : 1;
        const columnFilter = node => node.nodeType === Node.ELEMENT_NODE && node.tagName === "TG-PROPERTY-COLUMN";
        Polymer({
            is: "tg-entity-grid-inspector",

            properties: {
                /** An object that provides a number of useful delegated functions such as serialiser(), reflector(), and more as defined in tg-entity-binder-behavior.html. */
                delegatedFunctions: Object,
                
                entities: {
                    type: Array,
                    observer: "_entitiesChanged"
                },
                filteredEntities: {
                    type: Array,
                    observer: "_filteredEntitiesChanged"
                },
                totals: Object,
                columns: {
                    type: Array,
                    observer: "_columnsChanged"
                },
                /**
                 * The function to map column properties of the entity to the form [{ dotNotation: 'prop1.prop2', value: '56.67'}, ...]. The order is
                 * consistent with the order of columns.
                 *
                 * @param entity -- the entity to be processed with the mapper function
                 */
                columnPropertiesMapper: {
                    type: Function,
                    notify: true
                },
                /**
                 * Holds the entity centre selection and updates it's own selection model when it changes.
                 */
                centreSelection: {
                    type: Object,
                    observer: "_centreSelectionChanged"
                },
                lock: {
                    type: Boolean,
                    value: false
                },
                renderingHints: {
                    type: Array,
                    observer: "_renderingHintsChanged"
                },
                /**
                 * Defines the number of visible rows.
                 */
                visibleRowCount: {
                    type: Number,
                    value: 0
                },
                /**
                 * This is alternative to visible row count and default egi behaviour that allows one to configure egi's height independently from content height.
                 */
                constantHeight: {
                    type: String,
                    value: ""
                },
                /**
                 * Indicates whether content should be extended to EGI's height or not.
                 */
                fitToHeight: {
                    type: Boolean,
                    value: false
                },
                //Controls visibility of the toolbar.
                toolbarVisible: {
                    type: Boolean,
                    value: true
                },
                //Determines whether entities can be dragged from this EGI.
                canDragFrom: {
                    type: Boolean,
                    value: false
                },
                dragAnchorFixed: {
                    type: Boolean,
                    value: false
                },
                //Controls visiblity of checkboxes at the beginnig of the header and each data row.
                checkboxVisible: {
                    type: Boolean,
                    value: false
                },

                //Scrolling related properties.
                checkboxesFixed: {
                    type: Boolean,
                    value: false
                },
                checkboxesWithPrimaryActionsFixed: {
                    type: Boolean,
                    value: false
                },
                numOfFixedCols: {
                    type: Number,
                    value: 0
                },
                secondaryActionsFixed: {
                    type: Boolean,
                    value: false
                },
                headerFixed: {
                    type: Boolean,
                    value: false
                },
                summaryFixed: {
                    type: Boolean,
                    value: false
                },

                /**
                 * Provides custom key bindings.
                 */
                customShortcuts: {
                    type: String
                },

                /**
                 * The property that determines whether progress bar is visible or not.
                 */
                _showProgress: {
                    type: Boolean
                },

                //Private properties that defines config object for totals.
                _totalsRowCount: Number,
                _totalsRows: Array,
                //Shadow related properties
                _showBottomShadow: Boolean,
                _showTopShadow: Boolean,
                _showLeftShadow: Boolean,
                _showRightShadow: Boolean,
                //Scroling properties
                _scrollLeft: Number,
                _scrollTop: Number,
                //Need when resizing column to recalculate styles.
                _fixedColumnWidth: Number,
                _scrollableColumnWidth: Number,
                //miscelenia private variables
                _actionWidth: {
                    type: String,
                    value: "20px"
                },
                _cellPadding: {
                    type: String,
                    value: "1.2rem"
                },
                _bottomMargin: {
                    type: String,
                    value: "15px"
                },
                _rangeSelection: {
                    type: Boolean,
                    value: false
                },
                _lastSelectedIndex: Number
            },

            observers: [
          '_heightRelatedPropertiesChanged(visibleRowCount, constantHeight, fitToHeight, summaryFixed, _totalsRowCount, _bottomMargin)'
            ],

            behaviors: [Polymer.TgBehaviors.TgTooltipBehavior, Polymer.IronResizableBehavior, Polymer.IronA11yKeysBehavior, Polymer.TgBehaviors.TgShortcutProcessingBehavior, Polymer.TgBehaviors.TgDragFromBehavior],

            _leftLockPanelRendered: function (e) {
                this._leftLockPanel = this.$$("#leftLockPanel");
            },

            _scrollContainerEntitiesStampedCustomAction: function () {},

            _scrollContainerEntitiesStamped: function (event) {
                this._scrollContainerEntitiesStampedCustomAction();
            },

            _rightLockPanelRendered: function (e) {
                this._rightLockPanel = this.$$("#rightLockPanel");
            },

            _topLockPanelRendered: function (e) {
                this._topLockPanel = this.$$("#topLockPanel");
            },

            _bottomLockPanelRendered: function (e) {
                this._bottomLockPanel = this.$$("#bottomLockPanel");
            },

            _shortcutPressed: function (e) {
                this.processShortcut(e, ['paper-icon-button', 'tg-action', 'tg-ui-action']);
            },

            /**
             * Initialises selection model, primary action, secondary actions, property columns, card layout.
             */
            ready: function () {
                var primaryActions = Polymer.dom(this.$.primary_action_selector).getDistributedNodes();
                this._totalsRowCount = 0;
                this._showProgress = false;

                //Initialising shadows
                this._showTopShadow = false;
                this._showBottomShadow = false;
                this._showLeftShadow = false;
                this._showRightShadow = false;

                //Initilialising scrolling properties
                this._scrollLeft = 0;
                this._scrollTop = 0;

                //Initialising entities.
                this.totals = null;
                this.entities = [];

                //Initialising the egi model .
                this.egiModel = [];

                //initialising the arrays for selected entites.
                this.selectedAll = false;
                this.selectedEntities = [];

                //Initialise columns
                this.allColumns = [];
                this.columns = [];

                //Initialising the primary action.
                this.primaryAction = primaryActions.length > 0 ? primaryActions[0] : null;

                //Initialising the secondary actions' list.
                const secondaryActionsList = [];
                Array.prototype.forEach.call(Polymer.dom(this.$.secondary_action_selector).getDistributedNodes(), function (item) {
                    secondaryActionsList.push(item);
                }.bind(this));
                this.secondaryActions = secondaryActionsList;

                //Initialising event listeners.
                this.addEventListener("iron-resize", this._resizeEventListener.bind(this));

                //Observe column DOM changes
                Polymer.dom(this.$.column_selector).observeNodes(info => {
                    this._columnDomChanged(info.addedNodes.filter(columnFilter), info.removedNodes.filter(columnFilter));
                });
            },

            attached: function () {
                var self = this;
                this._updateTableSizeAsync();
                this._ownKeyBindings = {};
                if (this.customShortcuts) {
                    this._ownKeyBindings[this.customShortcuts] = '_shortcutPressed';
                }
                //Initialising property column mappings
                this.columnPropertiesMapper = (function (entity) {
                    const result = [];
                    for (let index = 0; index < this.columns.length; index++) {
                        const column = this.columns[index];
                        const entry = {
                            dotNotation: column.property,
                            value: this._getValue(entity, column.property, column.type)
                        };
                        result.push(entry);
                    }
                    return result;
                }).bind(this);
                this.async(function () {
                    this.keyEventTarget = this._getKeyEventTarget();
                }, 1)
            },

            /**
             * Updates entity when some of the properties were changed.
             */
            updateEntity: function (entity, propPath) {
                const entityIndex = _findEntity(entity, this.filteredEntities);
                if (entityIndex >= 0) {
                    const path = "egiModel." + entityIndex + ".entity" + (propPath.length > 0 ? "." + propPath : "");
                    this.notifyPath(path, entity.get(propPath));
                }
            },

            setRenderingHints: function (entity, property, renderingHints) {
                const entityIndex = _findEntity(entity, this.filteredEntities);
                if (entityIndex >= 0) {
                    this.set("egiModel." + entityIndex + ".renderingHints." + property, renderingHints);
                }
            },

            selectEntity: function (entity, select) {
                const entityIndex = _findEntity(entity, this.filteredEntities);
                if (entityIndex >= 0 && this.egiModel[entityIndex].selected !== select) {
                    this.set("egiModel." + entityIndex + ".selected", select);
                    _processEntitySelection(this.selectedEntities, this.filteredEntities[entityIndex], select, this);
                    this.fire("tg-entity-selected", {
                        shouldScrollToSelected: false,
                        entities: [{
                            entity: this.filteredEntities[entityIndex],
                            select: select
                        }]
                    });
                }
            },

            filter: function () {
                const tempFilteredEntities = [];
                this.entities.forEach(entity => {
                    if (this.isVisible(entity)) {
                        tempFilteredEntities.push(entity);
                    }
                });
                this.filteredEntities = tempFilteredEntities;
            },
            
            isVisible: function (entity) {
                return true;
            },

            getElementToDragFrom: function (target) {
                const elem = document.createElement('div');
                const entities = this.getSelectedEntities();
                elem.innerHTML = entities.map(entity => this._getValueFromEntity(entity, "key")).join(", ");
                elem.style["white-space"] = "nowrap";
                elem.style["overflow"] = "hidden";
                elem.style["text-overflow"] = "ellipsis";
                elem.style["width"] = "300px"
                return elem;
            },

            getDataToDragFrom: function (target) {
                const entities = this.getSelectedEntities();
                if (entities.length > 0) {
                    const type = "tg/" + entities[0].type()._simpleClassName();
                    const data = {};
                    data[type] = JSON.stringify(this.$.serialiser.serialise(this.getSelectedEntities()));
                    return data;
                }
            },

            _getKeyEventTarget: function () {
                var parent = this;
                while (parent && parent.tagName !== 'TG-CUSTOM-ACTION-DIALOG') {
                    parent = parent.parentElement;
                }
                return parent || this;
            },

            updateProgress: function (percentage, clazz, isVisible) {
                var progressBar = this.$$("#progressBar");
                this._showProgress = isVisible;
                progressBar.classList.remove("processing");
                progressBar.classList.remove("uploading");
                if (clazz !== "") {
                    progressBar.classList.add(clazz);
                }
                if (percentage >= 0 && percentage <= 100) {
                    progressBar.value = percentage;
                }
                progressBar.updateStyles();
            },

            _checkSelectionState: function (event) {
                this._rangeSelection = event.shiftKey;
            },

            _mouseRowEnter: function (event, detail) {
                var index = event.model.entityIndex;
                this.set("egiModel." + index + ".over", true);
            },

            _mouseRowLeave: function (event, detail) {
                var index = event.model.entityIndex;
                this.set("egiModel." + index + ".over", false);
            },

            _handleWheel: function (e, detail) {
                this._scrollLengthY = this._scrollLengthY || 0;
                this._scrollLengthX = this._scrollLengthX || 0;
                if (this._scrollLengthX !== 0 || this._scrollLengthY !== 0) {
                    if (sign(e.deltaX) === sign(this._scrollLengthX)) {
                        this._scrollLengthX += e.deltaX;
                    } else {
                        this._resetXscroll = e.deltaX;
                    }
                    if (sign(e.deltaY) === sign(this._scrollLengthY)) {
                        this._scrollLengthY += e.deltaY;
                    } else {
                        this._resetYscroll = e.deltaY;
                    }
                    e.preventDefault();
                } else {
                    this._scrollLengthX = e.deltaX;
                    this._scrollLengthY = e.deltaY;
                    if (this._scrollBy(7, 7)) {
                        e.preventDefault();
                    }
                }
            },

            _scrollBy: function (incrementX, incrementY) {
                const newIncrementX = this._scrollHorizontallyBy(incrementX);
                const newIncrementY = this._scrollVerticallyBy(incrementY);
                if (this._scrollLengthX !== 0 || this._scrollLengthY !== 0) {
                    setTimeout(() => this._scrollBy(newIncrementX, newIncrementY), 10);
                    return true;
                }
                return false;
            },

            _scrollHorizontallyBy: function (increment) {
                let newIncrement = increment;
                if (this._resetXscroll) {
                    this._scrollLengthX = this._resetXscroll;
                    delete this._resetXscroll;
                    newIncrement = 7;
                }
                if (this._scrollLengthX !== 0 && newIncrement !== 0) {
                    const s = sign(this._scrollLengthX);
                    //The expression below calculates speed and direction of scroll action
                    //s = sign(scrollLength) - determines the direction of scroll (to left or to right).
                    //Math.max(Math.abs(increment), Math.abs(this._scrollLengthX) / 10) - calculates the accelration of the scroll. It should be maximum value of previous speed or it's scroll length devided by 10 (10 - how many steps of animation should be performed. (i.e. if scroll length was increased then speed of scroll would rise comparing to initial speed. initial speed is 7 px.)).
                    //Math.min(... , Math.abs(this._scrollLengthX)) - calculates the last step of animation. The increment might be bigger then the scroll length to scroll. Then we should choose scroll length as a one step of animation. This situation happens only on the last step of animation. That looks like animation slows down.
                    newIncrement = s * Math.min(Math.max(Math.abs(newIncrement), Math.abs(this._scrollLengthX) / 10), Math.abs(this._scrollLengthX));
                    if (this.$.scrollContainer.scrollLeft + newIncrement < 0) {
                        this.$.scrollContainer.scrollLeft = 0;
                        this._scrollLengthX = 0;
                        return 0;
                    } else if (this.$.scrollContainer.scrollLeft + newIncrement > this.$.scrollContainer.scrollWidth - this.$.scrollContainer.clientWidth) {
                        this.$.scrollContainer.scrollLeft = this.$.scrollContainer.scrollWidth - this.$.scrollContainer.clientWidth;
                        this._scrollLengthX = 0;
                        return 0;
                    }
                    this.$.scrollContainer.scrollLeft += newIncrement;
                    this._scrollLengthX -= newIncrement;
                    return newIncrement;
                }
                return 0;
            },

            _scrollVerticallyBy: function (increment) {
                let newIncrement = increment;
                if (this._resetYscroll) {
                    this._scrollLengthY = this._resetYscroll;
                    delete this._resetYscroll;
                    newIncrement = 7;
                }
                if (this._scrollLengthY !== 0 && newIncrement !== 0) {
                    const s = sign(this._scrollLengthY);
                    //The expression below calculates speed and direction of scroll action
                    //s = sign(scrollLength) - determines the direction of scroll (top or down).
                    //Math.max(Math.abs(increment), Math.abs(this._scrollLengthY) / 10) - calculates the accelration of the scroll. It should be maximum value of previous speed or it's scroll length devided by 10 (10 - how many steps of animation should be performed. (i.e. if scroll length was increased then speed of scroll would rise comparing to initial speed. initial speed is 7 px.)).
                    //Math.min(... , Math.abs(this._scrollLengthY)) - calculates the last step of animation. The increment might be bigger then the scroll length to scroll. Then we should choose scroll length as a one step of animation. This situation happens only on the last step of animation. That looks like animation slows down.
                    newIncrement = s * Math.min(Math.max(Math.abs(newIncrement), Math.abs(this._scrollLengthY) / 10), Math.abs(this._scrollLengthY));
                    if (this.$.scrollContainer.scrollTop + newIncrement < 0) {
                        this.$.scrollContainer.scrollTop = 0;
                        this._scrollLengthY = 0;
                        return 0;
                    } else if (this.$.scrollContainer.scrollTop + newIncrement > this.$.scrollContainer.scrollHeight - this.$.scrollContainer.clientHeight) {
                        this.$.scrollContainer.scrollTop = this.$.scrollContainer.scrollHeight - this.$.scrollContainer.clientHeight;
                        this._scrollLengthY = 0;
                        return 0;
                    }
                    this.$.scrollContainer.scrollTop += newIncrement;
                    this._scrollLengthY -= newIncrement;
                    return newIncrement;
                }
                return 0;
            },

            _isTargetInSelectedContainer: function (target) {
                if (target) {
                    let targetParent = target;
                    while (targetParent) {
                        if (targetParent === this.$.scrollContainer || targetParent === this._leftLockPanel || targetParent === this._rightLockPanel) {
                            return true;
                        }
                        targetParent = targetParent.parentElement;
                    }
                }
                return false;
            },

            _baseContainerFocusIn: function (event) {
                const target = (event.target || event.srcElement);
                if (target && this._elementGainedFocus !== target && this._isTargetInSelectedContainer(target)) {
                    this._scrollToTarget(target);
                }
                event.preventDefault();
            },

            _baseContainerFocusOut: function (event) {
                const target = event.relatedTarget;
                if (target && this._isTargetInSelectedContainer(target)) {
                    this._elementGainedFocus = target;
                    this._scrollToTarget(target);
                } else {
                    delete this._elementGainedFocus;
                }
                event.preventDefault();
            },

            _lockContainerFocusIn: function () {
                this.$.lockContainer.scrollTop = 0;
            },

            _lockContainerFocusOut: function () {
                this.$.lockContainer.scrollTop = 0;
            },

            _scrollToTarget: function (target) {
                this.$.lockContainer.scrollTop = 0;
                const containerRect = this.$.lockContainer.getBoundingClientRect();
                //Get the top and bottom coordinates of the visible viewport.
                let viewTop = containerRect.top;
                let viewBottom = containerRect.bottom;
                //Correct the top coordinate of the visisble viewport so that it takes into account the top lock panel height.
                if (this._topLockPanel && this._topLockPanel.offsetParent !== null) {
                    viewTop = this._topLockPanel.getBoundingClientRect().bottom;
                }
                //Correct the bottom coordinate of the visisble viewport so that it takes into account the bottom lock panel height.
                if (this._bottomLockPanel && this._bottomLockPanel.offsetParent !== null) {
                    viewBottom = this._bottomLockPanel.getBoundingClientRect().top;
                }
                //Check whether the focused element is in range from viewTop to viewBottom. If it is outside the range then calculate the scroll differense and add to the scrollTop of scrollContainer. Otherwise do nothing.
                const focusedElementRect = target.getBoundingClientRect();
                let scrollIncrement = 0;
                if (focusedElementRect.top < viewTop) {
                    scrollIncrement = focusedElementRect.top - viewTop;
                } else if (focusedElementRect.bottom > viewBottom) {
                    scrollIncrement = focusedElementRect.bottom - viewBottom;
                }
                this.$.scrollContainer.scrollTop += scrollIncrement;
            },

            /**
             * Resize event handler that adjusts the lock container size and position.
             */
            _resizeEventListener: function (event, details) {
                this.$.lockContainer.style.bottom = this._calcHorizontalScrollBarHeight() + "px";
                this.$.lockContainer.style.right = this._calcVerticalScrollBarWidth() + "px";
                this._handleScrollEvent();
            },

            _heightRelatedPropertiesChanged: function (visibleRowCount, constantHeight, fitToHeight, summaryFixed, _totalsRowCount, _bottomMargin) {
                //Constant height take precedence over visible row count which takes precedence over default behaviour that extends the EGI's height to it's content height
                this.style.removeProperty("height");
                this.style.removeProperty("min-height");
                this.$.scrollContainer.style.removeProperty("height");
                this.$.scrollContainer.style.removeProperty("max-height");
                if (constantHeight) { //Set the height for the egi
                    this.style["height"] = constantHeight;
                } else if (visibleRowCount > 0) { //Set the height or max height for the scroll container so that only specified number of rows become visible.
                    this.style["min-height"] = "fit-content";
                    const rowCount = visibleRowCount + (summaryFixed ? _totalsRowCount : 0);
                    const height = "calc(3rem + " + rowCount + " * 1.5rem + " + rowCount + "px" + (this.summaryFixed && this._totalsRowCount > 0 ? (" + " + this._bottomMargin) : "") + ")";
                    if (fitToHeight) {
                        this.$.scrollContainer.style["height"] = height;
                    } else {
                        this.$.scrollContainer.style["max-height"] = height;
                    }
                }
                this._resizeEventListener();
            },

            _updateShadows: function () {
                this._showLeftShadow = this.$.scrollContainer.scrollLeft !== 0;
                this._showRightShadow = (this.$.scrollContainer.clientWidth + this.$.scrollContainer.scrollLeft) !== this.$.scrollContainer.scrollWidth;
                this._showTopShadow = this.$.scrollContainer.scrollTop !== 0;
                this._showBottomShadow = (this.$.scrollContainer.clientHeight + this.$.scrollContainer.scrollTop) !== this.$.scrollContainer.scrollHeight;
            },

            _calcVerticalScrollBarWidth: function () {
                return this.$.scrollContainer.offsetWidth - this.$.scrollContainer.clientWidth;
            },

            /**
             * Calculates the horizontal scrollbar height.
             */
            _calcHorizontalScrollBarHeight: function () {
                return this.$.scrollContainer.offsetHeight - this.$.scrollContainer.clientHeight;
            },

            /**
             * Scrolling related functions.
             */
            _handleScrollEvent: function () {
                this._scrollLeft = this.$.scrollContainer.scrollLeft;
                this._scrollTop = this.$.scrollContainer.scrollTop;
                this._updateShadows();
            },

            _isAnchorFixed: function (dargAnchorFixed, checkboxesFixed, checkboxesWithPrimaryActionsFixed, numOfFixedCols) {
                return dargAnchorFixed || this._isCheckboxesFixed(checkboxesFixed, checkboxesWithPrimaryActionsFixed, numOfFixedCols);
            },

            _isCheckboxesOrHeaderFixed: function (checkboxesFixed, checkboxesWithPrimaryActionsFixed, headerFixed, numOfFixedCols) {
                return this._isCheckboxesFixed(checkboxesFixed, checkboxesWithPrimaryActionsFixed, numOfFixedCols) || headerFixed;
            },

            _isCheckboxesFixed: function (checkboxesFixed, checkboxesWithPrimaryActionsFixed, numOfFixedCols) {
                return checkboxesFixed || checkboxesWithPrimaryActionsFixed || (numOfFixedCols > 0);
            },

            _isDragAnchorNotFixedAndVisble: function (canDragFrom, dragAnchorFixed, checkboxesFixed, checkboxesWithPrimaryActionsFixed, numOfFixedCols) {
                return canDragFrom && !this._isAnchorFixed(dragAnchorFixed, checkboxesFixed, checkboxesWithPrimaryActionsFixed, numOfFixedCols);
            },

            _isCheckboxesNotFixedAndVisible: function (checkboxVisible, checkboxesFixed, checkboxesWithPrimaryActionsFixed, numOfFixedCols) {
                return checkboxVisible && !this._isCheckboxesFixed(checkboxesFixed, checkboxesWithPrimaryActionsFixed, numOfFixedCols);
            },

            _isPrimaryActionsFixed: function (checkboxesWithPrimaryActionsFixed, numOfFixedCols) {
                return checkboxesWithPrimaryActionsFixed || (numOfFixedCols > 0);
            },

            _isPrimaryActionsNotFixedAndPresent: function (primaryAction, checkboxesWithPrimaryActionsFixed, numOfFixedCols) {
                return primaryAction && !checkboxesWithPrimaryActionsFixed && (numOfFixedCols <= 0);
            },

            _isSecondaryActionsFixed: function (secondaryActionsFixed) {
                return secondaryActionsFixed;
            },

            _isSecondaryActionsPresentAndFixed: function (secondaryActions, secondaryActionsFixed) {
                return this._isSecondaryActionsPresent(secondaryActions) && secondaryActionsFixed;
            },

            _isSecondaryActionsPresentAndNotFixed: function (secondaryActions, secondaryActionsFixed) {
                return this._isSecondaryActionsPresent(secondaryActions) && !secondaryActionsFixed;
            },

            _isHeaderFixed: function (headerFixed) {
                return headerFixed;
            },

            _isHeaderColumnHidden: function (headerFixed, index, numOfFixedCols) {
                return headerFixed || this._isColumnFixed(index, numOfFixedCols);
            },

            _isColumnFixed: function (index, numOfFixedCols) {
                return index < numOfFixedCols;
            },

            _isSummaryPresentAndFixed: function (totals, summaryFixed) {
                return totals && summaryFixed;
            },

            _isSummaryNotFixedAndPresent: function (totals, summaryFixed) {
                return totals && !summaryFixed;
            },

            _isLeftLockPanelVisble: function (canDragFrom, dragAnchorFixed, checkboxVisible, checkboxesFixed, primaryAction, checkboxesWithPrimaryActionsFixed, numOfFixedCols) {
                return (canDragFrom && (dragAnchorFixed || checkboxesFixed || checkboxesWithPrimaryActionsFixed)) || (checkboxVisible && (checkboxesFixed || checkboxesWithPrimaryActionsFixed)) || (primaryAction && checkboxesWithPrimaryActionsFixed) || (numOfFixedCols > 0);
            },

            _isTopLeftPanelVisible: function (canDragFrom, dragAnchorFixed, checkboxVisible, checkboxesFixed, primaryAction, checkboxesWithPrimaryActionsFixed, numOfFixedCols, headerFixed) {
                return this._isLeftLockPanelVisble(canDragFrom, dragAnchorFixed, checkboxVisible, checkboxesFixed, primaryAction, checkboxesWithPrimaryActionsFixed, numOfFixedCols) && headerFixed;
            },

            _isCheckboxesVisibleAndFixed: function (checkboxVisible, checkboxesFixed, checkboxesWithPrimaryActionsFixed, numOfFixedCols) {
                return checkboxVisible && this._isCheckboxesFixed(checkboxesFixed, checkboxesWithPrimaryActionsFixed, numOfFixedCols);
            },

            _isPrimaryActionVisibleAndFixed: function (primaryAction, checkboxesWithPrimaryActionsFixed, numOfFixedCols) {
                return primaryAction && (checkboxesWithPrimaryActionsFixed || numOfFixedCols > 0);
            },

            _isTopRightPanelVisible: function (secondaryActions, secondaryActionsFixed, headerFixed) {
                return this._isSecondaryActionsPresent(secondaryActions) && secondaryActionsFixed && headerFixed;
            },

            _isBottomLeftPanelVisible: function (totals, summaryFixed, canDragFrom, dragAnchorFixed, checkboxVisible, checkboxesFixed, primaryAction, checkboxesWithPrimaryActionsFixed, numOfFixedCols) {
                return totals && summaryFixed && this._isLeftLockPanelVisble(canDragFrom, dragAnchorFixed, checkboxVisible, checkboxesFixed, primaryAction, checkboxesWithPrimaryActionsFixed, numOfFixedCols);
            },

            _isBottomRightPanelVisible: function (totals, summaryFixed, secondaryActions, secondaryActionsFixed) {
                return totals && summaryFixed && ((this._isSecondaryActionsPresent(secondaryActions) && secondaryActionsFixed));
            },

            /**
             * Tooltip related functions.
             */
            _selectAllTooltip: function (selectedAll) {
                return (selectedAll ? 'Unselect' : 'Select') + ' all entities';
            },

            _selectTooltip: function (selected) {
                return (selected ? 'Unselect' : 'Select') + ' this entity';
            },

            _getTooltip: function (entity, column, action) {
                try {
                    let tooltip = this.getValueTooltip(entity, column);
                    const columnDescPart = this.getDescTooltip(entity, column);
                    const actionDescPart = this.getActionTooltip(entity, column, action);
                    tooltip += (columnDescPart && tooltip && "<br><br>") + columnDescPart;
                    tooltip += (actionDescPart && tooltip && "<br><br>") + actionDescPart;
                    return tooltip;
                } catch (e) {
                    return '';
                }
            },

            getValueTooltip: function (entity, column) {
                const validationResult = entity.prop(column.property).validationResult();
                if (this.$.reflector.isWarning(validationResult) || this.$.reflector.isError(validationResult)) {
                    return validationResult.message && ("<b>" + validationResult.message + "</b>");
                } else if (column.tooltipProperty) {
                    const value = this._getValue(entity, column.tooltipProperty, "String").toString();
                    return value && ("<b>" + value + "</b>");
                } else if (this.$.reflector.findTypeByName(column.type)) {
                    return this._generateEntityTooltip(entity, column);
                } else {
                    const value = this._getValue(entity, column.property, column.type).toString();
                    return value && ("<b>" + value + "</b>");
                }
                return "";
            },

            getDescTooltip: function (entity, column) {
                if (column.columnDesc) {
                    return column.columnDesc;
                }
                return "";
            },

            getActionTooltip: function (entity, column, action) {
                if (action && (action.shortDesc || action.longDesc)) {
                    return this._generateActionTooltip(action);
                } else if (this._getAttachmentIfPossible(entity, column)) {
                    return this._generateActionTooltip({
                        shortDesc: 'Download',
                        longDesc: 'Click to download attachment.'
                    });
                }
                return "";
            },

            _generateEntityTooltip: function (entity, column) {
                var key = this._getValue(entity, column.property, column.type);
                var desc;
                try {
                    if (Array.isArray(this._getValueFromEntity(entity, column.property))) {
                        desc = generateShortCollection(entity, column.property, this.$.reflector.findTypeByName(column.type))
                            .map(function (subEntity) {
                                return subEntity.get("desc");
                            }).join(", ");
                    } else {
                        desc = entity.get(column.property === '' ? "desc" : (column.property + ".desc"));
                    }
                } catch (e) {
                    desc = ""; // TODO consider leaving the exception (especially strict proxies) to be able to see the problems of 'badly fetched columns'
                }
                return (key && ("<b>" + key + "</b>")) + (desc ? "<br>" + desc : "");
            },

            _generateActionTooltip: function (action) {
                var shortDesc = "<b>" + action.shortDesc + "</b>";
                var longDesc;
                if (shortDesc) {
                    longDesc = action.longDesc ? "<br>" + action.longDesc : "";
                } else {
                    longDesc = action.longDesc ? "<b>" + action.longDesc + "</b>" : "";
                }
                var tooltip = shortDesc + longDesc;
                return tooltip && "<div style='display:flex;'>" +
                    "<div style='margin-right:10px;'>With action: </div>" +
                    "<div style='flex-grow:1;'>" + tooltip + "</div>" +
                    "</div>"
            },

            _getTotalTooltip: function (columnIndex, summaryIndex) {
                const summary = this.columns[columnIndex].summary[summaryIndex];
                var tooltip = summary.columnTitle ? "<b>" + summary.columnTitle + "</b>" : "";
                tooltip += summary.columnDesc ? (tooltip ? "<br>" + summary.columnDesc : summary.columnDesc) : "";
                return tooltip;
            },
            //End of Tooltip related functions

            _summaryExists: function (column, summaryIndex, columnIndex) {
                return !!(column.summary && column.summary[summaryIndex]);
            },

            _isSummaryBooleanProp: function (totals, columnIndex, summaryIndex, column) {
                return column.summary && column.summary[summaryIndex] && this._isBooleanProp(totals, column.summary[summaryIndex]);
            },

            _isSummaryHyperlinkProp: function (totals, columnIndex, summaryIndex, column) {
                return column.summary && column.summary[summaryIndex] && this._isHyperlinkProp(totals, column.summary[summaryIndex]);
            },

            _isSummaryNotBooleanOrHyperlinkProp: function (totals, columnIndex, summaryIndex, column) {
                return column.summary && column.summary[summaryIndex] && this._isNotBooleanOrHyperlinkProp(totals, column.summary[summaryIndex]);
            },

            _getSummaryBooleanIcon: function (totals, columnIndex, summaryIndex, column) {
                return column.summary && column.summary[summaryIndex] && this._getBooleanIcon(totals, column.summary[summaryIndex].property);
            },

            _getSummaryValue: function (totals, columnIndex, summaryIndex, column) {
                const summary = column.summary && column.summary[summaryIndex];
                return summary && this._getValue(totals, summary.property, summary.type);
            },

            _calcSummaryColumnStyle: function (column, columnWidth, columnGrowFactor, summaryIndex, columnIndex, numOfFixedCols) {
                return this._calcColumnStyle(column, columnWidth, columnGrowFactor, columnIndex, numOfFixedCols);
            },

            /**
             * Calculates the card's header style.
             */
            _calcCardHeaderStyle: function (primaryAction, secondaryActions) {
                if (primaryAction || secondaryActions.length > 0) {
                    return "padding-left: 8px;";
                } else {
                    return "padding: 8px;";
                }
            },
            
            _entitiesChanged: function (newValue, oldValue) {
                this.filter();
            },

            /**
             * Observs the changes to entities property.
             */
            _filteredEntitiesChanged: function (newValue, oldValue) {
                const tempEgiModel = [];
                const self = this;
                newValue.forEach(function (newEntity) {
                    const selectEntInd = _findEntity(newEntity, self.selectedEntities);
                    if (selectEntInd >= 0) {
                        self.selectedEntities[selectEntInd] = newEntity;
                    }
                });
                newValue.forEach(function (newEntity) {
                    const isSelected = self.selectedEntities.indexOf(newEntity) > -1;
                    const oldIndex = _findEntity(newEntity, oldValue);
                    const newRendHints = oldIndex < 0 ? {} : (self.renderingHints && self.renderingHints[oldIndex]) || {};
                    const egiEntity = {
                        over: false,
                        selected: isSelected,
                        entity: newEntity,
                        renderingHints: newRendHints
                    };
                    tempEgiModel.push(egiEntity);
                });
                updateSelectAll(this, tempEgiModel);
                self.egiModel = tempEgiModel;
                this._updateTableSizeAsync();
                this.fire("tg-egi-entities-loaded", newValue);
            },

            _renderingHintsChanged: function (newValue, oldValue) {
                if (this.egiModel) {
                    this.egiModel.forEach((egiEntity, index) => {
                        egiEntity.renderingHints = (newValue && newValue[index]) || {};
                    });
                    this._updateTableSizeAsync();
                }
            },

            _columnDomChanged: function (addedColumns, removedColumns) {
                const columnsCopy = this.columns.slice();
                let columnsChanged = false;
                removedColumns.forEach(col => {
                    removeColumn(col, this.allColumns);
                    columnsChanged = removeColumn(col, columnsCopy);
                });

                addedColumns.forEach(col => {
                    const index = this.allColumns.findIndex(column => column.property === col.property);
                    if (index < 0) {
                        this.allColumns.push(col);
                        columnsCopy.push(col);
                        columnsChanged = true;
                    }
                });
                if (columnsChanged) {
                    this._adjustColumns(columnsCopy.map(column => column.property));
                }
            },

            _columnsChanged: function (newColumns, oldColumns) {
                let summaryRowsCount = 0;
                newColumns.forEach(function (item) {
                    if (item.summary && item.summary.length > summaryRowsCount) {
                        summaryRowsCount = item.summary.length;
                    }
                });
                //Initialising totals.
                const gridSummary = [];
                if (summaryRowsCount > 0) {
                    for (let summaryRowCounter = 0; summaryRowCounter < summaryRowsCount; summaryRowCounter += 1) {
                        const totalsRow = [];
                        newColumns.forEach(function (item) {
                            if (item.summary && item.summary[summaryRowCounter]) {
                                const total = item.summary[summaryRowCounter]
                                totalsRow.push(true);
                            } else {
                                totalsRow.push(false);
                            }
                        });
                        gridSummary.push(totalsRow);
                    }
                }
                //Set the _totalsRowCount property so that calculation of the scroll container height would be triggered.
                this._totalsRowCount = summaryRowsCount;
                this._totalsRows = gridSummary;
            },

            _updateColumnsWidthProperties: function () {
                this._fixedColumnWidth = calculateFixedColumnWidth(this.columns, this.numOfFixedCols);
                this._scrollableColumnWidth = calculateScrollableColumnWidth(this.columns, this.numOfFixedCols);
                this._updateTableSizeAsync();
            },

            _updateTableSizeAsync: function () {
                this.async(function () {
                    this._resizeEventListener();
                }.bind(this), 1);
            },

            _centreSelectionChanged: function (newSelection, oldSelection) {
                let numOfSelected = 0;
                let lastSelectedIndex = -1;
                newSelection.entities.forEach(entitySelection => {
                    const entityIndex = _findEntity(entitySelection.entity, this.filteredEntities);
                    if (entityIndex >= 0 && this.egiModel[entityIndex].selected !== entitySelection.select) {
                        this.set("egiModel." + entityIndex + ".selected", entitySelection.select);
                        _processEntitySelection(this.selectedEntities, this.filteredEntities[entityIndex], entitySelection.select, this);
                    } else {
                        const hiddenEntityIndex = _findEntity(entitySelection.entity, this.entities);
                        if (hiddenEntityIndex >= 0) {
                            _processEntitySelection(this.selectedEntities, this.entities[hiddenEntityIndex], entitySelection.select, this);
                        }
                    }
                    if (entitySelection.select) {
                        numOfSelected += 1;
                        lastSelectedIndex = entityIndex;
                    }
                });
                //update selectAll parameter according to entity selection.
                updateSelectAll(this, this.egiModel);
                //Scroll to the selected one if it is the only one and should scroll is true.
                if (newSelection.shouldScrollToSelected && numOfSelected === 1 && lastSelectedIndex >= 0) {
                    const entityRows = this.$.scrollContainer.querySelectorAll('.table-data-row');
                    const entityRow = entityRows[lastSelectedIndex];
                    if (entityRow) {
                        this._scrollToTarget(entityRow);
                    } else { // in case where selected entity is outside existing stamped EGI rows, which means that entity rows stamping still needs to be occured, defer _scrollTo invocation until dom stamps
                        const oldAction = this._scrollContainerEntitiesStampedCustomAction;
                        this._scrollContainerEntitiesStampedCustomAction = (function () {
                            oldAction();
                            const entityRows = this.$.scrollContainer.querySelectorAll('.table-data-row');
                            const entityRow = entityRows[lastSelectedIndex];
                            this._scrollToTarget(entityRow);
                            this._scrollContainerEntitiesStampedCustomAction = oldAction;
                        }).bind(this);
                    }
                }
            },
            /**
             * Event handler for select all checkbox
             */
            _allSelectionChanged: function (e) {
                const target = e.target || e.srcElement;
                this.selectAll(target.checked);
            },

            /**
             * Selects/unselects all entities.
             */
            selectAll: function (checked) {
                if (this.egiModel) {
                    const selectionDetails = [];
                    for (let i = 0; i < this.egiModel.length; i += 1) {
                        if (this.egiModel[i].selected !== checked) {
                            this.set("egiModel." + i + ".selected", checked);
                            _processEntitySelection(this.selectedEntities, this.filteredEntities[i], checked);
                            selectionDetails.push({
                                entity: this.filteredEntities[i],
                                select: checked
                            });
                        }
                    }
                    this.selectedAll = checked;
                    if (selectionDetails.length > 0) {
                        this.fire("tg-entity-selected", {
                            shouldScrollToSelected: false,
                            entities: selectionDetails
                        });
                    }
                }
            },

            /**
             * Event handler for selecting concrete entity
             */
            _selectionChanged: function (e) {
                if (this.egiModel) {
                    const index = e.model.entityIndex;
                    var target = e.target || e.srcElement;
                    //Perform selection range selection or single selection.
                    if (target.checked && this._rangeSelection && this._lastSelectedIndex >= 0) {
                        this._selectRange(this._lastSelectedIndex, index);
                    } else {
                        this.set("egiModel." + index + ".selected", target.checked);
                        _processEntitySelection(this.selectedEntities, this.filteredEntities[index], target.checked, this);
                        this.fire("tg-entity-selected", {
                            shouldScrollToSelected: false,
                            entities: [{
                                entity: this.filteredEntities[index],
                                select: target.checked
                        }]
                        });
                    }
                    //Set up the last selection index (it will be used for range selection.)
                    if (target.checked) {
                        this._lastSelectedIndex = index;
                    } else {
                        this._lastSelectedIndex = -1;
                    }
                    //Set up selecteAll property.
                    if (this.selectedAll && !target.checked) {
                        this.selectedAll = false;
                    } else if (this.egiModel.length > 0 && this.egiModel.every(elem => elem.selected)) {
                        this.selectedAll = true;
                    }
                }
            },

            /**
             * Selects the range fromIndex toIndex of entities.
             */
            _selectRange: function (fromIndex, toIndex) {
                const from = fromIndex < toIndex ? fromIndex : toIndex;
                const to = fromIndex < toIndex ? toIndex : fromIndex;
                const selectionDetails = [];
                for (let i = from; i <= to; i++) {
                    if (!this.egiModel[i].selected) {
                        this.set("egiModel." + i + ".selected", true);
                        _processEntitySelection(this.selectedEntities, this.filteredEntities[i], true);
                        selectionDetails.push({
                            entity: this.filteredEntities[i],
                            select: true
                        });
                    }
                }
                if (selectionDetails.length > 0) {
                    this.fire("tg-entity-selected", {
                        shouldScrollToSelected: false,
                        entities: selectionDetails
                    });
                }
            },

            /**
             * Determines whether secondary actions are present.
             */
            _isSecondaryActionsPresent: function (secondaryActions) {
                return secondaryActions && secondaryActions.length > 0;
            },
            /**
             * Calculates the column's header style.
             */
            _calcColumnHeaderStyle: function (item, itemWidth, columnGrowFactor, index, numOfFixedCols) {
                var colStyle = "min-width: " + itemWidth + "px;" + "width: " + itemWidth + "px;"
                if (columnGrowFactor === 0 || index < numOfFixedCols) {
                    colStyle += "flex-grow: 0;flex-shrink:0;";
                } else {
                    colStyle += "flex-grow: " + columnGrowFactor + ";";
                }
                if (itemWidth === 0) {
                    colStyle += "display: none;";
                }
                if (item.type === 'Integer' || item.type === 'BigDecimal' || item.type === 'Money') {
                    colStyle += "text-align: right;"
                }
                return colStyle;
            },

            /**
             * Calculates the column's style.
             */
            _calcColumnStyle: function (item, itemWidth, columnGrowFactor, index, numOfFixedCols) {
                return this._calcColumnHeaderStyle(item, itemWidth, columnGrowFactor, index, numOfFixedCols);
            },
            /**
             * Calculates style for fotter row (e.a. summary row should be hidden if the grid has fixed summaries or it should be visible otherwise).
             */
            _calcFooterRowStyle: function (summaryFixed, summaryIndex, fitToHeight) {
                let styleStr = summaryFixed ? "visibility:hidden;" : "";
                if (fitToHeight && summaryIndex === 0) {
                    styleStr += "margin-top:auto;"
                }
                return styleStr;
            },

            _calcFixedFooterRowStyle: function (summaryIndex, fitToHeight) {
                return (summaryIndex === 0 && fitToHeight) ? "margin-top: auto" : "";
            },

            /**
             * Calculates style for the visibility of drag anchor.
             */
            _calcDragAnchorStyle: function (canDragFrom, dragAnchorFixed, checkboxesFixed, checkboxesWithPrimaryActionsFixed, numOfFixedCols, isSelected, isSelected) {
                return canDragFrom && !this._isAnchorFixed(dragAnchorFixed, checkboxesFixed, checkboxesWithPrimaryActionsFixed, numOfFixedCols) && isSelected ? "" : "visibility:hidden";
            },

            _calcFixedDragAnchorStyle: function (canDragFrom, isSelected) {
                return canDragFrom && isSelected ? "" : "visibility:hidden";
            },

            _calcSelectCheckBoxStyle: function (canDragFrom) {
                return "width:18px; padding-left:" + (canDragFrom ? "0;" : "0.6rem;");
            },
            /**
             * Calculates the style for cell that represents rendering hints.
             */
            _calcBackgroundRenderingHintsStyle: function (change, entityIndex, property) {
                const renderingHints = change.base;
                let style = "opacity: 0.3;";
                let rendHints = (renderingHints && renderingHints[property]) || {};
                rendHints = rendHints.backgroundStyles || rendHints;
                for (let property in rendHints) {
                    if (rendHints.hasOwnProperty(property)) {
                        style += " " + property + ": " + rendHints[property] + ";";
                    }
                }
                return style;
            },
            /**
             * Calculates the style for cell that contains the property value.
             */
            _calcValueRenderingHintsStyle: function (change, entityIndex, property, isBoolean) {
                const renderingHints = change.base;
                let style = isBoolean === 'true' ? "" : "width: 100%;";
                let rendHints = (renderingHints && renderingHints[property] && renderingHints[property].valueStyles) || {};
                for (let property in rendHints) {
                    if (rendHints.hasOwnProperty(property)) {
                        style += " " + property + ": " + rendHints[property] + ";";
                    }
                }
                return style;
            },

            /**
             * Adjusts widths for columns based on current widths values, which could be altered by dragging column right border.
             */
            _adjustColumnWidths: function (columnWidths) {
                this.columns.forEach((column, columnIndex) => {
                    this.set("columns." + columnIndex + ".growFactor", columnWidths[column.property].newGrowFactor);
                    this.set("columns." + columnIndex + ".width", columnWidths[column.property].newWidth);
                });
                this._updateColumnsWidthProperties();
            },

            /**
             * Adjusts columns visibility and order.
             */
            _adjustColumns: function (newColumns) {
                const resultantColumns = [];
                newColumns.forEach(columnName => {
                    const column = this.allColumns.find(item => item.property === columnName);
                    if (column) {
                        resultantColumns.push(column);
                    }
                });
                if (!this.$.reflector.equalsEx(this.columns, resultantColumns)) {
                    this.columns = resultantColumns;
                    const columnWithGrowFactor = this.columns.find((item, index) => index >= this.numOfFixedCols && item.growFactor > 0);
                    if (!columnWithGrowFactor && this.columns.length > 0 && this.columns.length >= this.numOfFixedCols) {
                        this.set("columns." + (this.columns.length - 1) + ".growFactor", 1);
                        const column = this.columns[this.columns.length - 1];
                        const parameters = {};
                        parameters[column.property] = {
                            growFactor: 1
                        }
                        this.fire("tg-egi-column-change", parameters);
                    }
                }
                this._updateColumnsWidthProperties();
            },

            /**
             * Calculates the style for empty total's cell.
             */
            _calcEmptyTotalStyle: function (column, columnWidth, columnGrowFactor, columnIndex, numOfFixedCols) {
                return this._calcColumnHeaderStyle(column, columnWidth, columnGrowFactor, columnIndex, numOfFixedCols);
            },

            /**
             * Below are function related to lock panels position calculation logic.
             */
            _calculateLeftLockPanelStyle: function (_showLeftShadow, _scrollTop, headerFixed) {
                return "left:0;top:calc(" + (headerFixed ? "3rem" : "0px") + " - " + _scrollTop + "px);bottom:0";
            },

            _calculateRightLockPanelStyle: function (_showRightShadow, _scrollTop, headerFixed) {
                return "right:0;top:calc(" + (headerFixed ? "3rem" : "0px") + " - " + _scrollTop + "px);bottom:0";
            },

            _calculateTopLockPanelStyle: function (canDragFrom, dragAnchorFixed, checkboxVisible, primaryAction, checkboxesFixed, checkboxesWithPrimaryActionsFixed, secondaryActions, secondaryActionsFixed, numOfFixedCols, _scrollLeft, _fixedColumnWidth, _scrollableColumnWidth) {
                const anchorFixed = this._isAnchorFixed(dragAnchorFixed, checkboxesFixed, checkboxesWithPrimaryActionsFixed, numOfFixedCols);
                const checkboxFixed = this._isCheckboxesFixed(checkboxesFixed, checkboxesWithPrimaryActionsFixed, numOfFixedCols);
                const primaryActionFixed = this._isPrimaryActionsFixed(checkboxesWithPrimaryActionsFixed, numOfFixedCols);
                return "top:0;left:calc(" + this._calculateDragAnchorWidth(canDragFrom, anchorFixed) + " + " + this._calculateCheckboxWidth(canDragFrom, checkboxVisible, checkboxFixed) + " + " + this._calculatePrimaryActionWidth(primaryAction, primaryActionFixed) + " + " + this._calculateFixedColsWidth(numOfFixedCols) + " - " + _scrollLeft + "px);right:calc(" + this._calculateSecondaryActionWidth(secondaryActions, secondaryActionsFixed) + " + " + _scrollLeft + "px)";
            },

            _calculateBottomLockPanelStyle: function (canDragFrom, dragAnchorFixed, checkboxVisible, primaryAction, checkboxesFixed, checkboxesWithPrimaryActionsFixed, secondaryActions, secondaryActionsFixed, numOfFixedCols, _scrollLeft, _fixedColumnWidth, _scrollableColumnWidth) {
                const anchorFixed = this._isAnchorFixed(dragAnchorFixed, checkboxesFixed, checkboxesWithPrimaryActionsFixed, numOfFixedCols);
                const checkboxFixed = this._isCheckboxesFixed(checkboxesFixed, checkboxesWithPrimaryActionsFixed, numOfFixedCols);
                const primaryActionFixed = this._isPrimaryActionsFixed(checkboxesWithPrimaryActionsFixed, numOfFixedCols);
                return "bottom:0;left:calc(" + this._calculateDragAnchorWidth(canDragFrom, anchorFixed) + " + " + this._calculateCheckboxWidth(canDragFrom, checkboxVisible, checkboxFixed) + " + " + this._calculatePrimaryActionWidth(primaryAction, primaryActionFixed) + " + " + this._calculateFixedColsWidth(numOfFixedCols) + " - " + _scrollLeft + "px);right:calc(" + this._calculateSecondaryActionWidth(secondaryActions, secondaryActionsFixed) + " + " + _scrollLeft + "px)";
            },

            _calculateCheckboxWidth: function (canDragFrom, checkboxVisible, fixed) {
                return (checkboxVisible && fixed) ? "18px + " + (canDragFrom ? "0.6" : "1.2") + "rem" : "0px";
            },

            _calculateDragAnchorWidth: function (canDragFrom, fixed) {
                return (fixed && canDragFrom) ? "1.5rem" : "0px";
            },

            _calculatePrimaryActionWidth: function (primaryAction, fixed) {
                return (primaryAction && fixed) ? this._actionWidth + " + 0.6rem" : "0px";
            },

            _calculateFixedColsWidth: function (numOfFixedCols) {
                var colIndex, fixedColsWidth = 0,
                    numOfFixedPaddings = 0;
                for (colIndex = 0; colIndex < numOfFixedCols && colIndex < this.columns.length; colIndex++) {
                    if (this.columns[colIndex].width > 0) {
                        fixedColsWidth += this.columns[colIndex].width;
                        numOfFixedPaddings++;
                    }
                }
                return fixedColsWidth + "px + " + this._cellPadding + " * " + numOfFixedPaddings;
            },

            _calculateSecondaryActionWidth: function (secondaryActions, fixed) {
                return (this._isSecondaryActionsPresent(secondaryActions) && fixed) ? this._actionWidth + " + 0.6rem" : "0px";
            },

            /**
             * Returns the property value of the specified entity.
             */
            _getValueFromEntity: function (entity, property) {
                return entity && entity.get(property);
            },

            _getBindedValue: function (change, property, type) {
                return this._getValue(change.base, property, type);
            },
            /**
             * Returns the property value of the specified entity and converts it to string.
             */
            _getValue: function (entity, property, type) {
                if (entity === null || property === null || type === null || this._getValueFromEntity(entity, property) === null) {
                    return "";
                } else if (this.$.reflector.findTypeByName(type)) {
                    var propertyValue = this._getValueFromEntity(entity, property);
                    if (Array.isArray(propertyValue)) {
                        propertyValue = generateShortCollection(entity, property, this.$.reflector.findTypeByName(type));
                    }
                    return Array.isArray(propertyValue) ? this.$.reflector.convert(propertyValue).join(", ") : this.$.reflector.convert(propertyValue);
                } else if (type.lastIndexOf('Date', 0) === 0) { // check whether type startsWith 'Date'. Type can be like 'Date', 'Date:UTC:' or 'Date:Europe/London:'
                    var splitedType = type.split(':');
                    return _millisDateRepresentation(entity.get(property), splitedType[1] || null, splitedType[2] || null);
                } else if (typeof entity.get(property) === 'number') {
                    if (type === 'BigDecimal') {
                        const metaProp = this.$.reflector.getEntityTypeProp(entity, property);
                        return this.$.reflector.formatDecimal(entity.get(property), this.$.appConfig.locale, metaProp && metaProp.scale(), metaProp && metaProp.trailingZeros());
                    } else {
                        return this.$.reflector.formatNumber(entity.get(property), this.$.appConfig.locale);
                    }
                } else if (type === 'Money') {
                    const metaProp = this.$.reflector.getEntityTypeProp(entity, property);
                    return this.$.reflector.formatMoney(entity.get(property), this.$.appConfig.locale, metaProp && metaProp.scale(), metaProp && metaProp.trailingZeros());
                } else if (type === 'Colour') {
                    return '#' + entity.get(property)['hashlessUppercasedColourValue'];
                } else if (type === 'Hyperlink') {
                    return entity.get(property)['value'];
                } else {
                    return entity.get(property);
                }
            },

            /**
             * Returns true if egi conatains at least one entity from entitiesToSearch list, otherwise returns false.
             */
            containsAnyEntity: function (entitiesToSearch) {
                var entityIndex;
                for (entityIndex = 0; entityIndex < entitiesToSearch.length; entityIndex++) {
                    if (_findEntity(entitiesToSearch[entityIndex], this.filteredEntities) !== -1) {
                        return true;
                    }
                }
                return false;
            },

            /**
             * Determines whether property is boolean or not.
             */
            _isBooleanProp: function (entity, column) {
                return column.type === 'Boolean' && this._getValueFromEntity(entity, column.property) !== null
            },
            /**
             * Determines whether property is Hypelink or not.
             */
            _isHyperlinkProp: function (entity, column) {
                return column.type === 'Hyperlink' && this._getValueFromEntity(entity, column.property) !== null
            },

            /**
             * Determines whether property is or belongs to type Attachment.
             */
            _getAttachmentIfPossible: function (entity, column) {
                if (entity.type && entity.type().notEnhancedFullClassName() === "ua.com.fielden.platform.attachment.Attachment") {
                    return entity;
                } else if (this._getValueFromEntity(entity, column.property) && this._getValueFromEntity(entity, column.property).type &&
                    this._getValueFromEntity(entity, column.property).type().notEnhancedFullClassName() === "ua.com.fielden.platform.attachment.Attachment") {
                    return this._getValueFromEntity(entity, column.property);
                } else if (this.$.reflector.entityPropOwner(entity, column.property)) {
                    const owner = this.$.reflector.entityPropOwner(entity, column.property);
                    if (owner.type().notEnhancedFullClassName() === "ua.com.fielden.platform.attachment.Attachment") {
                        return owner;
                    }
                    return null;
                } else {
                    return null;
                }
            },

            /**
             * Determines whether property is not boolean property or is.
             */
            _isNotBooleanOrHyperlinkProp: function (entity, column) {
                return !(this._isBooleanProp(entity, column) || this._isHyperlinkProp(entity, column));
            },
            /**
             * determines whether secondary actions is only one or not.
             */
            _isOnlyOneSecondaryActions: function (_secondaryActions) {
                return _secondaryActions.length === 1;
            },
            /**
             * Returns icon that represents the boolean value.
             */
            _getBooleanIcon: function (entity, property) {
                if (this._getValueFromEntity(entity, property) === true) {
                    return "icons:check";
                } else {
                    return "noicon";
                }
            },

            /** Identifies if there is a column action for the specified entity and column. */
            hasAction: function (entity, column) {
                return column.customAction || this._isHyperlinkProp(entity, column) === true || this._getAttachmentIfPossible(entity, column);
            },

            /**
             * Tap action on data column. TODO: implement this.
             */
            _tapAction: function (e, detail) {
                this.tap(this.filteredEntities[e.model.entityIndex], e.model.index, this.columns[e.model.index]);
            },

            tap: function (entity, index, column) {
                if (column.runAction(entity) === false) {
                    // if the clicked property is a hyperlink and there was no custom action associted with it
                    // then let's open the linked resources
                    if (this._isHyperlinkProp(entity, column) === true) {
                        const url = this._getValue(entity, column.property, column.type);
                        const win = window.open(url, '_blank');
                        win.focus();
                    } else {
                        const attachment = this._getAttachmentIfPossible(entity, column);
                        if (attachment) {
                            const url = '/download-attachment/' + attachment.id;
                            // AJAX approach to the file download
                            const xhr = new XMLHttpRequest();
                            xhr.open("GET", url, true);
                            xhr.responseType = 'blob';
                            xhr.onload = function (e) {
                                if (xhr.status === 200) {
                                    console.log('File received', xhr.getResponseHeader('Content-Disposition'));
                                    const bySemicolon = xhr.getResponseHeader('Content-Disposition').split(';');
                                    const filename = bySemicolon.filter(part => part.includes('filename=')).map(part => part.split('=')[1])[0];
                                    if (filename) {
                                        // create a Blob object from the response and a URL for it
                                        const blob = new Blob([xhr.response]);
                                        const blobUrl = window.URL.createObjectURL(blob);
                                        // the blob URL can be used for the <a> element for the user to download/open the file
                                        const a = document.createElement("a");
                                        a.href = blobUrl;
                                        a.download = filename;
                                        a.click();
                                        // release the reference to the file by revoking the Object URL
                                        window.URL.revokeObjectURL(url);                                        
                                    }
                                } else {
                                    console.error('Error occurred when trying to download the attachment.', 'Error code:', xhr.status);
                                    if (this.delegatedFunctions) {
                                        const delegatedFunctions = this.delegatedFunctions;
                                        const reader = new FileReader();
                                        reader.onload = function() {
                                            const resultAsObj = JSON.parse(reader.result);
                                            const result = delegatedFunctions.serialiser().deserialise(resultAsObj);
                                            console.log('delegatedFunctions result', result);
                                            delegatedFunctions.openToastForError(result.message, delegatedFunctions.toastMsgForError(result), true);
                                        }
                                        reader.readAsText(xhr.response);
                                    }
                                }
                                
                            }.bind(this);
                            xhr.onerror = function (e) {
                                const msg = "Error occured when sending request to download the attachment.";
                                console.error(msg, e);
                                if (this.delegatedFunctions) {
                                    this.delegatedFunctions.openToastForError(msg, msg + ' Request status: ' + xhr.status, true);
                                }
                                
                            }.bind(this);
                            xhr.send();
                        }
                    }
                }
            },
            /**
             * Returns the list entitles selected on the current page.
             */
            getSelectedEntities: function () {
                var currentSelectedEntities = [];
                this.egiModel.forEach(function (elem) {
                    if (elem.selected) {
                        currentSelectedEntities.push(elem.entity);
                    }
                }.bind(this));
                return currentSelectedEntities;
            },
            /**
             * Returns the list of all selected entites.
             */
            getAllSelectedEntities: function () {
                return this.selectedEntities;
            },
            /**
             * Returns the indexes of entites selected on current page.
             */
            getSelectedRows: function () {
                var selectedRows = [];
                this.egiModel.forEach(function (elem, elemIndex) {
                    if (elem.selected) {
                        selectedRows.push(elemIndex);
                    }
                }.bind(this));
                return selectedRows;
            },

            /**
             * Clears the selection on current page.
             */
            clearPageSelection: function () {
                this.selectAll(false);
            },

            /**
             * Clears selection.
             */
            clearSelection: function () {
                for (let i = 0; i < this.egiModel.length; i++) {
                    this.set("egiModel." + i + ".selected", false);
                }
                this.selectedAll = false;
                // First clear all selection and then fire event
                const prevSelectedEntities = this.selectedEntities;
                this.selectedEntities = [];
                if (prevSelectedEntities.length > 0) {
                    this.fire("tg-entity-selected", {
                        shouldScrollToSelected: false,
                        entities: prevSelectedEntities.map(entity => {
                            return {
                                entity: entity,
                                select: false
                            }
                        })
                    });
                }
            },
            /*
             * Below are functions those are related to shadow style calculation.
             */
            _calcBottomShadowStyle: function (_totalsRowCount, _showBottomShadow) {
                var shadowStyle = "left:0;right:0;bottom:0;";
                shadowStyle += "height:calc(1.5rem * " + _totalsRowCount + " + " + _totalsRowCount + "px);";
                if (_showBottomShadow) {
                    shadowStyle += "box-shadow: 0px -3px 6px -2px rgba(0,0,0,0.7);";
                }
                return shadowStyle;
            },

            _calcTopShadowStyle: function (_showTopShadow) {
                var shadowStyle = "left:0;right:0;top:0;height:3rem;";
                if (_showTopShadow) {
                    shadowStyle += "box-shadow: 0px 3px 6px -2px rgba(0,0,0,0.7);";
                }
                return shadowStyle;
            },

            _calcLeftShadowStyle: function (canDragFrom, dragAnchorFixed, checkboxVisible, checkboxesFixed, primaryAction, checkboxesWithPrimaryActionsFixed, numOfFixedCols, _showLeftShadow, _fixedColumnWidth, _scrollableColumnWidth) {
                const anchorFixed = this._isAnchorFixed(dragAnchorFixed, checkboxesFixed, checkboxesWithPrimaryActionsFixed, numOfFixedCols);
                const checkboxFixed = this._isCheckboxesFixed(checkboxesFixed, checkboxesWithPrimaryActionsFixed, numOfFixedCols);
                const primaryActionFixed = this._isPrimaryActionsFixed(checkboxesWithPrimaryActionsFixed, numOfFixedCols);
                let shadowStyle = "left:0;top:0;bottom:0;width:calc(" + this._calculateDragAnchorWidth(canDragFrom, anchorFixed) + " + " + this._calculateCheckboxWidth(canDragFrom, checkboxVisible, checkboxFixed) + " + " + this._calculatePrimaryActionWidth(primaryAction, primaryActionFixed) + " + " + this._calculateFixedColsWidth(numOfFixedCols) + ");";
                if (_showLeftShadow) {
                    shadowStyle += "box-shadow: 3px 0px 6px -2px rgba(0,0,0,0.7);";
                }
                return shadowStyle;
            },

            _calcRightShadowStyle: function (secondaryActions, secondaryActionsFixed, _showRightShadow, _fixedColumnWidth, _scrollableColumnWidth) {
                var shadowStyle = "right:0;top:0;bottom:0;width:calc(" + this._calculateSecondaryActionWidth(secondaryActions, secondaryActionsFixed) + ");";
                if (_showRightShadow) {
                    shadowStyle += "box-shadow: -3px 0px 6px -2px rgba(0,0,0,0.7);";
                }
                return shadowStyle;
            },

            _calcTBShadowStyle: function (_showTopShadow) {
                var shadowStyle = "left:0;right:0;top:-50px;height:50px;";
                if (_showTopShadow) {
                    shadowStyle += "box-shadow: 0px 3px 6px -2px rgba(0,0,0,0.7);";
                }
                return shadowStyle;
            },

            _changeColumnSize: function (e) {
                switch (e.detail.state) {
                case 'start':
                    this._startColumnResize(e);
                    break;
                case 'track':
                    this._trackColumnSize(e);
                    break;
                case 'end':
                    this._endColumnResizing(e);
                    break;
                }
                if (e.stopPropagation) e.stopPropagation();
                if (e.preventDefault) e.preventDefault();
                e.cancelBubble = true;
                e.returnValue = false;
            },

            _startColumnResize: function (e) {
                //Change the style to visualise column resizing.
                //this.style.cursor = "col-resize";
                e.target.classList.toggle("resizing-action", true);
                //Calculate all properties needed for column resizing logic and create appropriate object
                const columnElements = this.$.scrollContainer.querySelector(".table-header-row").querySelectorAll(".table-cell, .action-cell");
                let containerWidth = this.$.lockContainer.offsetWidth;
                let containerLeft = 0;
                if (this._leftLockPanel && this._leftLockPanel.offsetParent !== null) {
                    if (e.model.index < this.numOfFixedCols) {
                        containerLeft = calculateColumnWidthExcept(this, 0, columnElements, 0, () => true, () => true, () => false);
                    } else {
                        containerLeft = this._leftLockPanel.offsetWidth;
                    }
                }
                if (this._rightLockPanel && this._rightLockPanel.offsetParent !== null) {
                    containerWidth -= this._rightLockPanel.offsetWidth;
                }
                const self = this;
                this._columnResizingObject = {
                    oldColumnWidth: e.model.item.width,
                    oldColumnGrowFactor: e.model.item.growFactor,
                    containerWidth: containerWidth,
                    containerLeft: containerLeft,
                    otherColumnWidth: calculateColumnWidthExcept(this, e.model.index, columnElements, this.columns.length, () => true, () => true, () => true),
                    widthCorrection: e.target.parentElement.offsetWidth - e.target.previousElementSibling.offsetWidth,
                    hasAnyFlex: this.columns.find((column, index) => index >= this.numOfFixedCols && index !== e.model.index && column.growFactor !== 0)
                };
            },

            _trackColumnSize: function (e) {
                if (this._columnResizingObject) {
                    const columnWidth = e.target.previousElementSibling.offsetWidth;
                    let newWidth = columnWidth + e.detail.ddx;
                    //Correct size for mouse out of EGI.
                    const mousePos = getRelativePos(e.detail.x, e.detail.y, this.$.lockContainer);
                    if (mousePos.x > this._columnResizingObject.containerWidth && e.model.index >= this.numOfFixedCols) {
                        newWidth += mousePos.x - this._columnResizingObject.containerWidth;
                    } else if (mousePos.x < this._columnResizingObject.containerLeft && e.model.index >= this.numOfFixedCols) {
                        newWidth -= this._columnResizingObject.containerLeft - mousePos.x;
                    }
                    //Correct size if EGI is less then min width.
                    if (newWidth < e.model.item.minWidth) {
                        newWidth = e.model.item.minWidth;
                    }
                    //Correct new width when dragging last column or other column and overall width is less then width of container.
                    if ((e.model.index >= this.numOfFixedCols) && (this._columnResizingObject.otherColumnWidth + newWidth + this._columnResizingObject.widthCorrection < this.$.lockContainer.offsetWidth)) {
                        if (e.model.index === this.columns.length - 1) {
                            newWidth = this.$.lockContainer.offsetWidth - this._columnResizingObject.otherColumnWidth - this._columnResizingObject.widthCorrection;
                        } else {
                            if (!this._columnResizingObject.hasAnyFlex) {
                                this.set("columns." + (this.columns.length - 1) + ".growFactor", 1);
                                this._columnResizingObject.hasAnyFlex = true;
                                const columnParameters = this._columnResizingObject.columnParameters || {}; // this.$.reflector.newEntity("ua.com.fielden.platform.web.centre.ColumnParameter");
                                columnParameters[this.columns[this.columns.length - 1].property] = {
                                    growFactor: 1
                                };
                                this._columnResizingObject.columnParameters = columnParameters;
                            }
                        }
                    }
                    //Change the column width if it is needed
                    if (columnWidth !== newWidth) {
                        if (e.model.item.growFactor !== 0) {
                            this.set("columns." + e.model.index + ".growFactor", 0);
                            const columnParameters = this._columnResizingObject.columnParameters || {};
                            columnParameters[e.model.item.property] = {
                                growFactor: 1
                            };
                            this._columnResizingObject.columnParameters = columnParameters;
                        }
                        this.set("columns." + e.model.index + ".width", newWidth);
                        this._updateColumnsWidthProperties();
                        //scroll if needed.
                        if (e.model.index >= this.numOfFixedCols && (mousePos.x > this._columnResizingObject.containerWidth || mousePos.x < this._columnResizingObject.containerLeft)) {
                            this.$.scrollContainer.scrollLeft += newWidth - columnWidth;
                        }
                    }

                }
            },

            _endColumnResizing: function (e) {
                //this.style.cursor = "default";
                e.target.classList.toggle("resizing-action", false);
                if (this._columnResizingObject && (this._columnResizingObject.oldColumnWidth !== e.model.item.width || this._columnResizingObject.oldColumnGrowFactor !== e.model.item.growFactor)) {
                    const columnParameters = this._columnResizingObject.columnParameters || {};
                    const columnParameter = columnParameters[e.model.item.property] || {};
                    if (this._columnResizingObject.oldColumnWidth !== e.model.item.width) {
                        columnParameter.width = (+(e.model.item.width.toFixed(0)));
                    }
                    if (this._columnResizingObject.oldColumnGrowFactor !== e.model.item.growFactor) {
                        columnParameter.growFactor = e.model.item.growFactor;
                    }
                    columnParameters[e.model.item.property] = columnParameter;
                    this._columnResizingObject.columnParameters = columnParameters;
                }
                if (this._columnResizingObject && this._columnResizingObject.columnParameters) {
                    this.fire("tg-egi-column-change", this._columnResizingObject.columnParameters);
                }
                delete this._columnResizingObject;
            },

            _makeEgiUnselectable: function (e) {
                this.$.baseContainer.classList.toggle("noselect", true);
                document.body.style["cursor"] = "col-resize";
            },

            _makeEgiSelectable: function (e) {
                this.$.baseContainer.classList.toggle("noselect", false);
                document.body.style["cursor"] = "";
            },

            _showResizingCue: function (e) {
                if (!e.buttons) {
                    e.currentTarget.classList.toggle("resizing-column", true);
                }
            },

            _hideResizingCue: function (e) {
                e.currentTarget.classList.toggle("resizing-column", false);
            }
        })
    })()
</script>