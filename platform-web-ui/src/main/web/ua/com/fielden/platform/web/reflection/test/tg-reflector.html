<!doctype html>
<html>

<head>
	<meta charset="UTF-8">
	<title>tg-reflector basic tests</title>
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">
	
	<script src="/resources/polymer/webcomponentsjs/webcomponents-lite.js"></script>
	<script src="/resources/polymer/web-component-tester/browser.js"></script>
	<script src="/resources/polymer/test-fixture/test-fixture-mocha.js"></script>
	<script src="/resources/polymer/iron-test-helpers/mock-interactions.js"></script>
	
	<link rel="import" href="/resources/polymer/test-fixture/test-fixture.html">
  
    <link rel="import" href="/app/tg-reflector.html">
</head>

<body>
	<tg-reflector id="reflector"></tg-reflector>

    <script>
        suite('reflector\'s', function() {
            let reflector;
            const typeName1 = 'ua.com.fielden.platform.sample.domain.TgPersistentEntityWithProperties';
            const typeName2 = 'ua.com.fielden.platform.sample.domain.TgPersistentCompositeEntity';
            const typeName3 = 'ua.com.fielden.platform.sample.domain.TgBogieLocation';
            const typeName4 = 'ua.com.fielden.platform.sample.domain.TgWorkshop';
            const typeName5 = 'ua.com.fielden.platform.sample.domain.TgWagonSlot';
            const typeName6 = 'ua.com.fielden.platform.sample.domain.TgWagon';
            
            setup(function() {
                reflector = document.querySelector('#reflector');
            });
            
            // Testing the access to 'key' property of different kinds of entities.
            // This property is of high importance and should be much in sync with server-side implementation.
            // At this stage only equality and toString implementation is used when accessing properties.
            // However client-side code is not restricted to that.
            
            /////////////////////// entity.get('key') tests ///////////////////////
            test('test empty object convertion should be fine', function (done) {
                assert.deepEqual(reflector.convert({}), {});
                done();
            });
            
            test('test object with arbitrary properties convertion should not be acceptable', function (done) {
                try {
                    reflector.convert({testProp: "testProp"});
                } catch (ex) {
                    done();
                }
            });
            
            test('simple entity: key access is forbidden if not fetched', function (done) {
                const e1 = reflector.newEntity(typeName1);
                try {
                    e1.get('key');
                    assert.fail('Strict proxy exception is required.');
                } catch (ex) {
                    done();
                }
            });
            
            test('simple entity: key access returns concrete value if fetched', function (done) {
                const e1 = reflector.newEntity(typeName1);
                e1.key = 'DEMO01';
                assert.strictEqual(e1.get('key'), 'DEMO01');
                done();
            });
            
            test('simple entity: equality comparison is forbidden if key is not fetched', function (done) {
                const entity1 = reflector.newEntity(typeName1);
                entity1.key = 'DEMO01';
                const entity2 = reflector.newEntity(typeName1); // key is not fetched
                try {
                    reflector.equalsEx(entity1, entity2);
                    assert.fail('Strict proxy exception is required.');
                } catch (ex) {
                    done();
                }
            });
            
            test('simple entity: equality comparison succeeds if key is fetched', function (done) {
                const entity1 = reflector.newEntity(typeName1);
                entity1.key = 'DEMO01';
                const entity2 = reflector.newEntity(typeName1);
                entity2.key = 'DEMO01';
                
                assert.strictEqual(reflector.equalsEx(entity1, entity2), true);
                done();
            });
            
            test('simple entity: conversion is forbidden if key is not fetched', function (done) {
                const entity1 = reflector.newEntity(typeName1);
                try {
                    reflector.convert(entity1);
                    assert.fail('Strict proxy exception is required.');
                } catch (ex) {
                    done();
                }
            });
            
            test('simple entity: conversion succeeds if key is fetched', function (done) {
                const entity1 = reflector.newEntity(typeName1);
                entity1.key = 'DEMO01';
                
                assert.strictEqual(reflector.convert(entity1), 'DEMO01');
                done();
            });
            
            test('composite entity: key access returns DynamicEntityKey instance for fully-fetched composite keys', function (done) {
                const e1 = reflector.newEntity(typeName1);
                e1.key = 'DEMO01';
                const entity1 = reflector.newEntity(typeName2);
                entity1.key1 = e1;
                entity1.key2 = 7;
                assert.strictEqual(entity1.get('key') instanceof reflector.getDynamicEntityKeyPrototype(), true);
                done();
            });
            
            test('composite entity: key access also returns DynamicEntityKey instance for partly-fetched composite keys', function (done) {
                const entity1 = reflector.newEntity(typeName2);
                entity1.key2 = 7; // key1 is not fetched
                assert.strictEqual(entity1.get('key') instanceof reflector.getDynamicEntityKeyPrototype(), true);
                done();
            });
            
            test('composite entity: equality comparison is forbidden for partly-fetched composite keys', function (done) {
                const entity1 = reflector.newEntity(typeName2);
                entity1.key2 = 7; // key1 is not fetched
                
                const e1 = reflector.newEntity(typeName1);
                e1.key = 'DEMO01';
                const entity2 = reflector.newEntity(typeName2);
                entity2.key1 = e1;
                entity2.key2 = 7;
                
                try {
                    reflector.equalsEx(entity1, entity2);
                    assert.fail('Strict proxy exception is required.');
                } catch (ex) {
                    done();
                }
            });
            
            test('composite entity: equality comparison succeeds for fully-fetched composite keys', function (done) {
                const e1 = reflector.newEntity(typeName1);
                e1.key = 'DEMO01';
                const entity1 = reflector.newEntity(typeName2);
                entity1.key1 = e1;
                entity1.key2 = 7;
                
                const entity2 = reflector.newEntity(typeName2);
                entity2.key1 = e1;
                entity2.key2 = 7;
                
                assert.strictEqual(reflector.equalsEx(entity1, entity2), true);
                done();
            });
            
            test('composite entity: conversion is forbidden for partly-fetched composite keys', function (done) {
                const entity1 = reflector.newEntity(typeName2);
                entity1.key2 = 7; // key1 is not fetched
                try {
                    reflector.convert(entity1);
                    assert.fail('Strict proxy exception is required.');
                } catch (ex) {
                    done();
                }
            });
            
            test('composite entity: conversion succeeds for fully-fetched composite keys', function (done) {
                const e1 = reflector.newEntity(typeName1);
                e1.key = 'DEMO01';
                const entity1 = reflector.newEntity(typeName2);
                entity1.key1 = e1;
                entity1.key2 = 7;
                
                assert.strictEqual(reflector.convert(entity1), 'DEMO01 7');
                done();
            });
            
            test('union entity: key access for empty union entity returns empty value', function (done) {
                const uEntity = reflector.newEntity(typeName3); // TgBogieLocation union entity (no active entity)
                
                assert.strictEqual(uEntity.get('key'), null);
                done();
            });
            
            test('union entity: equality comparison succeeds for empty union entity', function (done) {
                const uEntity1 = reflector.newEntity(typeName3); // TgBogieLocation union entity (no active entity)
                const uEntity2 = reflector.newEntity(typeName3); // TgBogieLocation union entity (no active entity)
                assert.strictEqual(reflector.equalsEx(uEntity1, uEntity2), true);
                done();
            });
            
            test('union entity: conversion succeeds for empty union entity', function (done) {
                const uEntity1 = reflector.newEntity(typeName3); // TgBogieLocation union entity (no active entity)
                assert.strictEqual(reflector.convert(uEntity1), null);
                done();
            });
            
            test('union entity: key access for union entity with simple entity being active returns key of this active entity', function (done) {
                const uEntity = reflector.newEntity(typeName3); // TgBogieLocation union entity (simple active entity)
                const workshop1 = reflector.newEntity(typeName4); // TgWorkshop
                workshop1.key = 'W1';
                uEntity.workshop = workshop1;
                
                assert.strictEqual(uEntity.get('key'), 'W1');
                done();
            });
            
            test('union entity: equality comparison for union entity with simple entity being active succeeds', function (done) {
                const uEntity1 = reflector.newEntity(typeName3); // TgBogieLocation union entity (simple active entity)
                const workshop1 = reflector.newEntity(typeName4); // TgWorkshop
                workshop1.key = 'W1';
                uEntity1.workshop = workshop1;
                const uEntity2 = reflector.newEntity(typeName3); // TgBogieLocation union entity (simple active entity)
                const workshop2 = reflector.newEntity(typeName4); // TgWorkshop
                workshop2.key = 'W1';
                uEntity2.workshop = workshop2;
                
                assert.strictEqual(reflector.equalsEx(uEntity1, uEntity2), true);
                done();
            });
            
            test('union entity: conversion for union entity with simple entity being active succeeds', function (done) {
                const uEntity1 = reflector.newEntity(typeName3); // TgBogieLocation union entity (simple active entity)
                const workshop1 = reflector.newEntity(typeName4); // TgWorkshop
                workshop1.key = 'W1';
                uEntity1.workshop = workshop1;
                
                assert.strictEqual(reflector.convert(uEntity1), 'W1');
                done();
            });
            
            test('union entity: key access for union entity with composite entity being active returns key of this active entity', function (done) {
                const uEntity = reflector.newEntity(typeName3); // TgBogieLocation union entity (composite active entity)
                const wagonSlot1 = reflector.newEntity(typeName5); // TgWagonSlot
                const wagon1 = reflector.newEntity(typeName6); // TgWagon
                wagon1.key = 'WAG1';
                wagonSlot1.wagon = wagon1;
                wagonSlot1.position = 7;
                uEntity.wagonSlot = wagonSlot1;
                
                assert.strictEqual(uEntity.get('key') instanceof reflector.getDynamicEntityKeyPrototype(), true);
                done();
            });
            
            test('union entity: equality comparison for union entity with composite entity being active succeeds', function (done) {
                const uEntity1 = reflector.newEntity(typeName3); // TgBogieLocation union entity (composite active entity)
                const wagonSlot1 = reflector.newEntity(typeName5); // TgWagonSlot
                const wagon1 = reflector.newEntity(typeName6); // TgWagon
                wagon1.key = 'WAG1';
                wagonSlot1.wagon = wagon1;
                wagonSlot1.position = 7;
                uEntity1.wagonSlot = wagonSlot1;
                const uEntity2 = reflector.newEntity(typeName3); // TgBogieLocation union entity (composite active entity)
                const wagonSlot2 = reflector.newEntity(typeName5); // TgWagonSlot
                const wagon2 = reflector.newEntity(typeName6); // TgWagon
                wagon2.key = 'WAG1';
                wagonSlot2.wagon = wagon2;
                wagonSlot2.position = 7;
                uEntity2.wagonSlot = wagonSlot2;
                
                assert.strictEqual(reflector.equalsEx(uEntity1, uEntity2), true);
                done();
            });
            
            test('union entity: conversion for union entity with composite entity being active succeeds', function (done) {
                const uEntity1 = reflector.newEntity(typeName3); // TgBogieLocation union entity (composite active entity)
                const wagonSlot1 = reflector.newEntity(typeName5); // TgWagonSlot
                const wagon1 = reflector.newEntity(typeName6); // TgWagon
                wagon1.key = 'WAG1';
                wagonSlot1.wagon = wagon1;
                wagonSlot1.position = 7;
                uEntity1.wagonSlot = wagonSlot1;
                
                assert.strictEqual(reflector.convert(uEntity1), 'WAG1 7');
                done();
            });
            
            test('union entity: key access for union entity with simple entity being active is forbidden for partly-fetched active entity', function (done) {
                const uEntity = reflector.newEntity(typeName3); // TgBogieLocation union entity (simple active entity)
                const workshop1 = reflector.newEntity(typeName4); // TgWorkshop
                uEntity.workshop = workshop1;
                
                try {
                    uEntity.get('key');
                    assert.fail('Strict proxy exception is required.');
                } catch (ex) {
                    done();
                }
            });
            
            test('union entity: equality comparison for union entity with simple entity being active is forbidden for partly-fetched active entity', function (done) {
                const uEntity1 = reflector.newEntity(typeName3); // TgBogieLocation union entity (simple active entity)
                const workshop1 = reflector.newEntity(typeName4); // TgWorkshop
                uEntity1.workshop = workshop1;
                const uEntity2 = reflector.newEntity(typeName3); // TgBogieLocation union entity (simple active entity)
                const workshop2 = reflector.newEntity(typeName4); // TgWorkshop
                workshop2.key = 'W1';
                uEntity2.workshop = workshop1;
                
                try {
                    reflector.equalsEx(uEntity1, uEntity2);
                    assert.fail('Strict proxy exception is required.');
                } catch (ex) {
                    done();
                }
            });
            
            test('union entity: conversion for union entity with simple entity being active is forbidden for partly-fetched active entity', function (done) {
                const uEntity1 = reflector.newEntity(typeName3); // TgBogieLocation union entity (simple active entity)
                const workshop1 = reflector.newEntity(typeName4); // TgWorkshop
                uEntity1.workshop = workshop1;
                
                try {
                    reflector.convert(uEntity1);
                    assert.fail('Strict proxy exception is required.');
                } catch (ex) {
                    done();
                }
            });
            
            test('union entity: key access for union entity with composite entity being active succeeds for partly-fetched active entity', function (done) {
                const uEntity = reflector.newEntity(typeName3); // TgBogieLocation union entity (composite active entity)
                const wagonSlot1 = reflector.newEntity(typeName5); // TgWagonSlot
                wagonSlot1.position = 7; // wagon is not fetched
                uEntity.wagonSlot = wagonSlot1;
                
                assert.strictEqual(uEntity.get('key') instanceof reflector.getDynamicEntityKeyPrototype(), true);
                done();
            });
            
            test('union entity: equality comparison for union entity with composite entity being active is forbidden for partly-fetched active entity', function (done) {
                const uEntity1 = reflector.newEntity(typeName3); // TgBogieLocation union entity (composite active entity)
                const wagonSlot1 = reflector.newEntity(typeName5); // TgWagonSlot
                wagonSlot1.position = 7; // wagon is not fetched
                uEntity1.wagonSlot = wagonSlot1;
                const uEntity2 = reflector.newEntity(typeName3); // TgBogieLocation union entity (composite active entity)
                const wagonSlot2 = reflector.newEntity(typeName5); // TgWagonSlot
                const wagon2 = reflector.newEntity(typeName6); // TgWagon
                wagon2.key = 'WAG1';
                wagonSlot2.wagon = wagon2;
                wagonSlot2.position = 7;
                uEntity2.wagonSlot = wagonSlot2;
                
                try {
                    reflector.equalsEx(uEntity1, uEntity2);
                    assert.fail('Strict proxy exception is required.');
                } catch (ex) {
                    done();
                }
            });
            
            test('union entity: conversion for union entity with composite entity being active is forbidden for partly-fetched active entity', function (done) {
                const uEntity1 = reflector.newEntity(typeName3); // TgBogieLocation union entity (composite active entity)
                const wagonSlot1 = reflector.newEntity(typeName5); // TgWagonSlot
                wagonSlot1.position = 7; // wagon is not fetched
                uEntity1.wagonSlot = wagonSlot1;
                
                try {
                    reflector.convert(uEntity1);
                    assert.fail('Strict proxy exception is required.');
                } catch (ex) {
                    done();
                }
            });
            
            /////////////////////// entity.get('key') tests [END] /////////////////
            
            test('equalsEx method works for regular values', function (done) {
                assert.strictEqual(reflector.equalsEx('ok', 'ok'), true, "Equal values should return 'true' from equalsEx method.");
                assert.strictEqual(reflector.equalsEx('ok', 'not_ok'), false, "Not equal values should return 'false' from equalsEx method.");
                
                done();
            });
            
            test('equalsEx method works for money values', function (done) {
                assert.strictEqual(reflector.equalsEx({ amount: 45.6 }, undefined), false);
                assert.strictEqual(reflector.equalsEx({ amount: 45.6 }, null), false);
                assert.strictEqual(reflector.equalsEx({ amount: 45.6 }, {}), false);
                assert.strictEqual(reflector.equalsEx({ amount: 45.6 }, { amount: 45.6 }), true);
                assert.strictEqual(reflector.equalsEx({ amount: 45.6 }, { amount: 44.6 }), false);
                assert.strictEqual(reflector.equalsEx({ amount: 45.6, currency: 'AUD' }, { amount: 45.6 }), true);
                assert.strictEqual(reflector.equalsEx({ amount: 45.6 }, { amount: 45.6, currency: 'AUD' }), true);
                assert.strictEqual(reflector.equalsEx({ amount: 45.6 }, { amount: 45.6, taxPercent: null }), true);
                assert.strictEqual(reflector.equalsEx({ amount: 45.6 }, { amount: 45.6, currency: 'AUD', taxPercent: null }), true);
                
                assert.strictEqual(reflector.equalsEx(undefined, { amount: 45.6 }), false);
                assert.strictEqual(reflector.equalsEx(null, { amount: 45.6 }), false);
                assert.strictEqual(reflector.equalsEx({}, { amount: 45.6 }), false);
                assert.strictEqual(reflector.equalsEx({ amount: 45.6 }, { amount: 45.6, currency: 'AUD' }), true);
                assert.strictEqual(reflector.equalsEx({ amount: 45.6, currency: 'AUD' }, { amount: 45.6 }), true);
                assert.strictEqual(reflector.equalsEx({ amount: 45.6, taxPercent: null }, { amount: 45.6 }), true);
                assert.strictEqual(reflector.equalsEx({ amount: 45.6, currency: 'AUD', taxPercent: null }, { amount: 45.6 }), true);
                
                done();
            });
            
            test('equalsEx method works for colour values', function (done) {
                assert.strictEqual(reflector.equalsEx({ hashlessUppercasedColourValue: 'F44336' }, undefined), false);
                assert.strictEqual(reflector.equalsEx({ hashlessUppercasedColourValue: 'F44336' }, null), false);
                assert.strictEqual(reflector.equalsEx({ hashlessUppercasedColourValue: 'F44336' }, {}), false);
                assert.strictEqual(reflector.equalsEx({ hashlessUppercasedColourValue: 'F44336' }, { hashlessUppercasedColourValue: 'F44336' }), true);
                assert.strictEqual(reflector.equalsEx({ hashlessUppercasedColourValue: 'F44336' }, { hashlessUppercasedColourValue: 'F44338' }), false);
                assert.strictEqual(reflector.equalsEx({ hashlessUppercasedColourValue: 'F44336', redundantProp: '3' }, { hashlessUppercasedColourValue: 'F44336' }), true);
                assert.strictEqual(reflector.equalsEx({ hashlessUppercasedColourValue: 'F44336' }, { hashlessUppercasedColourValue: 'F44336', redundantProp: '3' }), true);
                
                assert.strictEqual(reflector.equalsEx(undefined, { hashlessUppercasedColourValue: 'F44336' }), false);
                assert.strictEqual(reflector.equalsEx(null, { hashlessUppercasedColourValue: 'F44336' }), false);
                assert.strictEqual(reflector.equalsEx({}, { hashlessUppercasedColourValue: 'F44336' }), false);
                
                done();
            });
            
            test('equalsEx method works for hyperlink values', function (done) {
                assert.strictEqual(reflector.equalsEx({ value: 'https://fielden.com.ua' }, undefined), false);
                assert.strictEqual(reflector.equalsEx({ value: 'https://fielden.com.ua' }, null), false);
                assert.strictEqual(reflector.equalsEx({ value: 'https://fielden.com.ua' }, {}), false);
                assert.strictEqual(reflector.equalsEx({ value: 'https://fielden.com.ua' }, { value: 'https://fielden.com.ua' }), true);
                assert.strictEqual(reflector.equalsEx({ value: 'https://fielden.com.ua' }, { value: 'https://fielden.com.au' }), false);
                assert.strictEqual(reflector.equalsEx({ value: 'https://fielden.com.ua', redundantProp: '3' }, { value: 'https://fielden.com.ua' }), true);
                assert.strictEqual(reflector.equalsEx({ value: 'https://fielden.com.ua' }, { value: 'https://fielden.com.ua', redundantProp: '3' }), true);
                
                assert.strictEqual(reflector.equalsEx(undefined, { value: 'https://fielden.com.ua' }), false);
                assert.strictEqual(reflector.equalsEx(null, { value: 'https://fielden.com.ua' }), false);
                assert.strictEqual(reflector.equalsEx({}, { value: 'https://fielden.com.ua' }), false);
                
                done();
            });
            
            test('equalsEx method works for falsey values', function (done) {
                assert.strictEqual(reflector.equalsEx(null, null), true, "Equal values should return 'true' from equalsEx method.");
                assert.strictEqual(reflector.equalsEx(undefined, undefined), true, "Equal values should return 'true' from equalsEx method.");
                assert.strictEqual(reflector.equalsEx(null, undefined), false, "Not equal values should return 'false' from equalsEx method.");
                
                done();
            });
            
            test('equalsEx method works for entity values', function (done) {
                var entity1 = reflector.newEntity(typeName1);
                var entity2 = reflector.newEntity(typeName2);
                var entity3 = reflector.newEntity(typeName1);
                
                assert.strictEqual(reflector.equalsEx(entity1, null), false, "The non-empty entity should be not equal to 'null'.");
                assert.strictEqual(reflector.equalsEx(undefined, entity1), false, "'undefined' value should be not equal to non-empty entity.");
                
                assert.strictEqual(reflector.equalsEx(entity1, entity1), true, "The same entity references should be equal.");
                
                assert.strictEqual(reflector.equalsEx(entity1, entity2), false, "Entities with different types should be not-equal.");
                
                done();
            });
            
            test('isEntity method works for falsey values', function (done) {
                assert.strictEqual(reflector.isEntity(null), false, "'null' should not be 'is entity'.");
                assert.strictEqual(reflector.isEntity(undefined), false, "'undefined' should not be 'is entity'.");
                
                done();
            });
            
            test('equalsEx method works for entity values with regular keys', function (done) {
                var entity1 = reflector.newEntity(typeName1);
                entity1.key = 'DEMO01';
                var entity2 = reflector.newEntity(typeName1);
                entity2.key = 'DEMO02';
                var entity1copy = reflector.newEntity(typeName1);
                entity1copy.key = 'DEMO01';
                var entityWithoutKey = reflector.newEntity(typeName1);
                
                assert.strictEqual(reflector.equalsEx(entity1, entity1copy), true, "Entities with same keys should be equal.");
                assert.strictEqual(reflector.equalsEx(entity1, entity2), false, "Entities with different keys should be not equal.");
                
                try {
                    reflector.equalsEx(entity1, entityWithoutKey);
                    assert.fail('Second entity should cause failure during comparison, the \'key\' property is not defined.');
                } catch (msg) {
                    console.log(msg);
                }
                
                try {
                    reflector.equalsEx(entityWithoutKey, entity1);
                    assert.fail('First entity should cause failure during comparison, the \'key\' property is not defined.');
                } catch (msg) {
                    console.log(msg);
                }
                
                done();
            });
            
            test('equalsEx method works for entity values with composite keys', function (done) {
                var e1 = reflector.newEntity(typeName1); e1.key = 'DEMO01';
                var e1copy = reflector.newEntity(typeName1); e1copy.key = 'DEMO01';
                
                var entity1 = reflector.newEntity(typeName2);
                entity1.key1 = e1;
                entity1.key2 = 7;
                var entity2 = reflector.newEntity(typeName2);
                entity2.key1 = e1;
                entity2.key2 = 9;
                var entity1copy = reflector.newEntity(typeName2);
                entity1copy.key1 = e1copy;
                entity1copy.key2 = 7;
                var entityWithoutKey = reflector.newEntity(typeName2);
                entityWithoutKey.key2 = 7;
                
                assert.strictEqual(reflector.equalsEx(entity1, entity1copy), true, "Entities with same composite keys should be equal.");
                assert.strictEqual(reflector.equalsEx(entity1, entity2), false, "Entities with different composite keys should be not equal.");
                
                try {
                    reflector.equalsEx(entity1, entityWithoutKey);
                    assert.fail('Second entity should cause failure during comparison, the \'key1\' property is not defined.');
                } catch (msg) {
                    console.log(msg);
                }
                
                try {
                    reflector.equalsEx(entityWithoutKey, entity1);
                    assert.fail('First entity should cause failure during comparison, the \'key1\' property is not defined.');
                } catch (msg) {
                    console.log(msg);
                }
                
                done();
            });
            
            test('equalsEx method works for arrays', function (done) {
                var entity1 = reflector.newEntity(typeName1);
                entity1.key = 'DEMO01';
                var entity2 = reflector.newEntity(typeName1);
                entity2.key = 'DEMO02';
                var entity1copy = reflector.newEntity(typeName1);
                entity1copy.key = 'DEMO01';
                var entityWithoutKey = reflector.newEntity(typeName1);
                
                assert.strictEqual(reflector.equalsEx([], null), false, "Array should not be equal to null.");
                assert.strictEqual(reflector.equalsEx(null, []), false, "Null should not be equal to array.");
                assert.strictEqual(reflector.equalsEx([], undefined), false, "Array should not be equal to null.");
                assert.strictEqual(reflector.equalsEx(undefined, []), false, "Null should not be equal to array.");
                var arr1 = [];
                var arr1copy = [];
                assert.strictEqual(reflector.equalsEx(arr1, arr1), true, "Array should be equal to itself.");
                assert.strictEqual(reflector.equalsEx(arr1, arr1copy), true, "Two empty arrays should be equal.");
                var arr2 = [entity1];
                assert.strictEqual(reflector.equalsEx(arr1, arr2), false, "Non-empty array should not be equal to empty.");
                assert.strictEqual(reflector.equalsEx(arr2, arr1), false, "Non-empty array should not be equal to empty.");
                var arr2copy = [entity1];
                assert.strictEqual(reflector.equalsEx(arr2, arr2copy), true, "Two arrays with the same item should be equal.");
                assert.strictEqual(reflector.equalsEx(arr2copy, arr2), true, "Two arrays with the same item should be equal.");
                var arr2copy2 = [entity1copy];
                assert.strictEqual(reflector.equalsEx(arr2, arr2copy2), true, "Two arrays with the equal item should be equal.");
                assert.strictEqual(reflector.equalsEx(arr2copy2, arr2), true, "Two arrays with the equal item should be equal.");
                var arr3 = [entity2];
                assert.strictEqual(reflector.equalsEx(arr1, arr3), false, "Two arrays with non-equal item should not be equal.");

                done();
            });
            
            test('shouldDisplayDescription method works', function (done) {
                var entity1 = reflector.newEntity(typeName1);
                var entity2 = reflector.newEntity(typeName2);
                
                assert.strictEqual(entity1.type().shouldDisplayDescription(), true, "shouldDisplayDescription for entity type TgPersistentEntityWithProperties should be true.");
                assert.strictEqual(entity2.type().shouldDisplayDescription(), false, "shouldDisplayDescription for entity type TgPersistentCompositeEntity should be false.");
                
                done();
            });
            
            test('empty union entity gives empty values for id, key and desc properties', function (done) {
                const union = reflector.newEntity('ua.com.fielden.platform.sample.domain.UnionEntity');
                union.key = 'bad key'; // should not really exist, but is provided for stronger checks
                union.desc = 'bad desc'; // should not really exist, but is provided for stronger checks
                union.id = 1; // should not really exist, but is provided for stronger checks
                
                union.propertyOne = null;
                union.propertyTwo = null;
                
                assert.strictEqual(union.get('key'), null);
                assert.strictEqual(union.get('desc'), null);
                assert.strictEqual(union.get('id'), null);
                
                done();
            });
            
            test('non-empty union entity gives values for id, key and desc properties from its active entity', function (done) {
                const union = reflector.newEntity('ua.com.fielden.platform.sample.domain.UnionEntity');
                union.key = 'bad key'; // should not really exist, but is provided for stronger checks
                union.desc = 'bad desc'; // should not really exist, but is provided for stronger checks
                union.id = 1; // should not really exist, but is provided for stronger checks
                
                const propertyOneVal = reflector.newEntity('ua.com.fielden.platform.sample.domain.EntityOne');
                propertyOneVal.key = 'EO1';
                propertyOneVal.desc = 'EO1 desc';
                propertyOneVal.id = 101;
                union.propertyOne = propertyOneVal;
                
                union.propertyTwo = null;
                
                assert.strictEqual(union.get('key'), 'EO1');
                assert.strictEqual(union.get('desc'), 'EO1 desc');
                assert.strictEqual(union.get('id'), 101);
                
                done();
            });
            
            test('foramtting: formatting 123.3 decimal with scale and trailing zeros should return 123.3000', function (done) {
                assert.equal(reflector.formatDecimal(123.3, 'en-AU', 4, true), "123.3000");
                done();
            });
            
            test('foramtting: formatting 123.3121 decimal with scale and trailing zeros should return 123.3121', function (done) {
                assert.equal(reflector.formatDecimal(123.3121, 'en-AU', 4, true), "123.3121");
                done();
            });
            
            test('foramtting: formatting 123.3 decimal with scale and without trailing zeros should return 123.3', function (done) {
                assert.equal(reflector.formatDecimal(123.3, 'en-AU', 4, false), "123.3");
                done();
            });
            
            test('foramtting: formatting 123.3121 decimal with scale and without trailing zeros should return 123.3121', function (done) {
                assert.equal(reflector.formatDecimal(123.3121, 'en-AU', 4, false), "123.3121");
                done();
            });
            
            test('foramtting: formatting 123.3 money with scale and trailing zeros should return $123.3000', function (done) {
                assert.equal(reflector.formatMoney({amount: 123.3}, 'en-AU', 4, true), "$123.3000");
                done();
            });
            
            test('foramtting: formatting 123.3121 money with scale and trailing zeros should return $123.3121', function (done) {
                assert.equal(reflector.formatMoney({amount: 123.3121}, 'en-AU', 4, true), "$123.3121");
                done();
            });
            
            test('foramtting: formatting 123.3 money with scale and without trailing zeros should return $123.3', function (done) {
                assert.equal(reflector.formatMoney({amount: 123.3}, 'en-AU', 4, false), "$123.3");
                done();
            });
            
             test('foramtting: formatting 123.3121 decimal with scale and without trailing zeros should return $123.3121', function (done) {
                assert.equal(reflector.formatMoney({amount: 123.3121}, 'en-AU', 4, false), "$123.3121");
                done();
            });
            
            test('foramtting: formatting 123.3 decimal with default scale and trailing zeros should return 123.30', function (done) {
                assert.equal(reflector.formatDecimal(123.3, 'en-AU', undefined, true), "123.30");
                done();
            });
            
            test('foramtting: formatting 123.3121 decimal with default scale and trailing zeros should return 123.31', function (done) {
                assert.equal(reflector.formatDecimal(123.3121, 'en-AU', undefined, true), "123.31");
                done();
            });
            
            test('foramtting: formatting 123.3 decimal with default scale and without trailing zeros should return 123.30', function (done) {
                assert.equal(reflector.formatDecimal(123.3, 'en-AU'), "123.30");
                done();
            });
            
            test('foramtting: formatting 123.3121 decimal with default scale and without trailing zeros should return 123.31', function (done) {
                assert.equal(reflector.formatDecimal(123.3121, 'en-AU'), "123.31");
                done();
            });
            
            test('foramtting: formatting 123.3 money with default scale and trailing zeros should return $123.30', function (done) {
                assert.equal(reflector.formatMoney({amount: 123.3}, 'en-AU', undefined, true), "$123.30");
                done();
            });
            
            test('foramtting: formatting 123.3121 money with default scale and trailing zeros should return $123.31', function (done) {
                assert.equal(reflector.formatMoney({amount: 123.3121}, 'en-AU', undefined, true), "$123.31");
                done();
            });
            
            test('foramtting: formatting 123.3 money with default scale and without trailing zeros should return $123.30', function (done) {
                assert.equal(reflector.formatMoney({amount: 123.3}, 'en-AU'), "$123.30");
                done();
            });
            
            test('foramtting: formatting 123.3121 money with default scale and without trailing zeros should return $123.31', function (done) {
                assert.equal(reflector.formatMoney({amount: 123.3121}, 'en-AU'), "$123.31");
                done();
            });
            
            test('prop retrieving: retrieveing of second level property should work fine', function (done) {
                const entity = reflector.newEntity(typeName1); 
                entity.key = 'DEMO01';
                const compositeEntity = reflector.newEntity(typeName2);
                compositeEntity.key1 = entity;
                compositeEntity.key2 = 7;
                const metaProp = reflector.getEntityTypeProp(compositeEntity, "key1.bigDecimalProp");
                assert.equal(metaProp.precision(), 18);
                assert.equal(metaProp.scale(), 5);
                assert.equal(metaProp.trailingZeros(), true);
                done();
            });
            
            test('prop retrieving: retrieveing of first level property should work fine', function (done) {
                const entity = reflector.newEntity(typeName1); 
                entity.key = 'DEMO01';
                const metaProp = reflector.getEntityTypeProp(entity, "bigDecimalProp");
                assert.equal(metaProp.precision(), 18);
                assert.equal(metaProp.scale(), 5);
                assert.equal(metaProp.trailingZeros(), true);
                done();
            });
            
            test('prop retrieving: retrieveing of empty property should return undefined', function (done) {
                const entity = reflector.newEntity(typeName1); 
                entity.key = 'DEMO01';
                const metaProp = reflector.getEntityTypeProp(entity, "");
                assert.equal(typeof metaProp, 'undefined');
                done();
            });
            
            test('prop retrieving: retrieveing of non exisiting property should return undefined', function (done) {
                const entity = reflector.newEntity(typeName1); 
                entity.key = 'DEMO01';
                const metaProp = reflector.getEntityTypeProp(entity, "nonExisting");
                assert.equal(typeof metaProp, 'undefined');
                done();
            });
        });
    </script>
</body>

</html>