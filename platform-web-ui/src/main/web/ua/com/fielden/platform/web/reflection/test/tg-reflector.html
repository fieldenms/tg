<!doctype html>
<html>

<head>
	<meta charset="UTF-8">
	<title>tg-reflector basic tests</title>
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">
	
	<script src="/resources/polymer/@webcomponents/webcomponentsjs/webcomponents-bundle.js"></script>
    <script src='/resources/polymer/web-animations-js/web-animations-next-lite.min.js'></script>
    <script src="/resources/filesaver/FileSaver.min.js"></script>
    <script src="/resources/polymer/wct-browser-legacy/browser.js"></script>
</head>

<body>
	<tg-reflector id="reflector"></tg-reflector>

    <script type="module">

        import '/app/tg-reflector.js';
        import '/app/tg-app-config.js'; // this is to trigger setting of LTS, LT and L formats in moment library instance to convert dates properly
        import { _millisDateRepresentation } from '/resources/reflection/tg-date-utils.js';

        suite('reflector\'s', function() {
            let reflector;
            const typeName1 = 'ua.com.fielden.platform.sample.domain.TgPersistentEntityWithProperties';
            const typeName2 = 'ua.com.fielden.platform.sample.domain.TgPersistentCompositeEntity';
            const typeName3 = 'ua.com.fielden.platform.sample.domain.TgBogieLocation';
            const typeName4 = 'ua.com.fielden.platform.sample.domain.TgWorkshop';
            const typeName5 = 'ua.com.fielden.platform.sample.domain.TgWagonSlot';
            const typeName6 = 'ua.com.fielden.platform.sample.domain.TgWagon';
            
            setup(function() {
                reflector = document.querySelector('#reflector');
            });
            
            test('Entity.toString: key converts (empty)', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityStringKey');
                entity.key = null;
                assert.strictEqual(entity.toString(), '[key is not assigned]');
                done();
            });
            
            test('Entity.toString: String key converts', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityStringKey');
                entity.key = 'KEY1';
                assert.strictEqual(entity.toString(), 'KEY1');
                done();
            });
            
            test('Entity.toString: String key converts (empty string)', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityStringKey');
                entity.key = '';
                assert.strictEqual(entity.toString(), '[key is not assigned]');
                done();
            });
            
            test('Entity.toString: boolean key converts (true)', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityBooleanKey');
                entity.key = true;
                assert.strictEqual(entity.toString(), 'true');
                done();
            });
            
            test('Entity.toString: boolean key converts (empty)', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityBooleanKey');
                entity.key = null;
                assert.strictEqual(entity.toString(), 'false');
                done();
            });
            
            test('Entity.toString: boolean key converts (false)', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityBooleanKey');
                entity.key = false;
                assert.strictEqual(entity.toString(), 'false');
                done();
            });
            
            test('Entity.toString: Date key converts', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityDateKey');
                entity.key = 0;
                assert.strictEqual(entity.toString(), _millisDateRepresentation(entity.key, null, null));
                done();
            });
            
            test('Entity.toString: Integer key converts', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityIntegerKey');
                entity.key = 1700;
                assert.strictEqual(entity.toString(), '1700');
                done();
            });
            
            test('Entity.toString: Long key converts', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityLongKey');
                entity.key = 17000000000;
                assert.strictEqual(entity.toString(), '17000000000');
                done();
            });
            
            test('Entity.toString: Entity key converts', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityEntityKey');
                entity.key = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityStringKey');
                entity.key.key = 'KEY1';
                assert.strictEqual(entity.toString(), 'KEY1');
                done();
            });
            // (Money keys are not supported as part of Hibernate configuration; Colour and Hyperlink are not Comparable and thus not suitable for key definition too.)
            
            test('tg_convert simple entity: key converts (empty)', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityStringKey');
                entity.key = null;
                assert.strictEqual(reflector.tg_convert(entity), '[key is not assigned]');
                done();
            });
            
            test('tg_convert simple entity: String key converts', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityStringKey');
                entity.key = 'KEY1';
                assert.strictEqual(reflector.tg_convert(entity), 'KEY1');
                done();
            });
            
            test('tg_convert simple entity: String key converts (empty string)', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityStringKey');
                entity.key = '';
                assert.strictEqual(reflector.tg_convert(entity), '[key is not assigned]');
                done();
            });
            
            test('tg_convert simple entity: boolean key converts (true)', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityBooleanKey');
                entity.key = true;
                assert.strictEqual(reflector.tg_convert(entity), 'true');
                done();
            });
            
            test('tg_convert simple entity: boolean key converts (empty)', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityBooleanKey');
                entity.key = null;
                assert.strictEqual(reflector.tg_convert(entity), 'false');
                done();
            });
            
            test('tg_convert simple entity: boolean key converts (false)', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityBooleanKey');
                entity.key = false;
                assert.strictEqual(reflector.tg_convert(entity), 'false');
                done();
            });
            
            test('tg_convert simple entity: Date key converts', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityDateKey');
                entity.key = 0;
                assert.strictEqual(reflector.tg_convert(entity), _millisDateRepresentation(entity.key, null, null));
                done();
            });
            
            test('tg_convert simple entity: Integer key converts', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityIntegerKey');
                entity.key = 1700;
                assert.strictEqual(reflector.tg_convert(entity), '1700');
                done();
            });
            
            test('tg_convert simple entity: Long key converts', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityLongKey');
                entity.key = 17000000000;
                assert.strictEqual(reflector.tg_convert(entity), '17000000000');
                done();
            });
            
            test('tg_convert simple entity: Entity key converts', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityEntityKey');
                entity.key = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityStringKey');
                entity.key.key = 'KEY1';
                assert.strictEqual(reflector.tg_convert(entity), 'KEY1');
                done();
            });
            // (Money keys are not supported as part of Hibernate configuration; Colour and Hyperlink are not Comparable and thus not suitable for key definition too.)
            
            test('tg_convert composite entity: key converts (empty)', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityCompositeKey');
                entity.stringKey = null;
                entity.dateKey = null;
                entity.integerKey = null;
                entity.longKey = null;
                entity.moneyKey = null;
                entity.colourKey = null;
                entity.hyperlinkKey = null;
                entity.entityKey = null;
                entity.selfKey = null;
                assert.strictEqual(reflector.tg_convert(entity), '[key is not assigned]');
                done();
            });
            
            test('tg_convert composite entity: String key converts', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityCompositeKey');
                entity.stringKey = 'KEY1';
                entity.dateKey = null;
                entity.integerKey = null;
                entity.longKey = null;
                entity.moneyKey = null;
                entity.colourKey = null;
                entity.hyperlinkKey = null;
                entity.entityKey = null;
                entity.selfKey = null;
                assert.strictEqual(reflector.tg_convert(entity), 'KEY1');
                done();
            });
            
            test('tg_convert composite entity: String key converts (empty string)', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityCompositeKey');
                entity.stringKey = '';
                entity.dateKey = null;
                entity.integerKey = null;
                entity.longKey = null;
                entity.moneyKey = null;
                entity.colourKey = null;
                entity.hyperlinkKey = null;
                entity.entityKey = null;
                entity.selfKey = null;
                assert.strictEqual(reflector.tg_convert(entity), '[key is not assigned]');
                done();
            });
            
            test('tg_convert composite entity: boolean key converts (true)', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityCompositeBooleanKey');
                entity.booleanKey = true;
                assert.strictEqual(reflector.tg_convert(entity), 'true');
                done();
            });
            
            test('tg_convert composite entity: boolean key converts (empty)', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityCompositeBooleanKey');
                entity.booleanKey = null;
                assert.strictEqual(reflector.tg_convert(entity), 'false');
                done();
            });
            
            test('tg_convert composite entity: boolean key converts (false)', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityCompositeBooleanKey');
                entity.booleanKey = false;
                assert.strictEqual(reflector.tg_convert(entity), 'false');
                done();
            });
            
            test('tg_convert composite entity: Date key converts', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityCompositeKey');
                entity.stringKey = null;
                entity.dateKey = 0;
                entity.integerKey = null;
                entity.longKey = null;
                entity.moneyKey = null;
                entity.colourKey = null;
                entity.hyperlinkKey = null;
                entity.entityKey = null;
                entity.selfKey = null;
                assert.strictEqual(reflector.tg_convert(entity), _millisDateRepresentation(entity.dateKey, null, null));
                done();
            });
            
            test('tg_convert composite entity: Integer key converts', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityCompositeKey');
                entity.stringKey = null;
                entity.dateKey = null;
                entity.integerKey = 1700;
                entity.longKey = null;
                entity.moneyKey = null;
                entity.colourKey = null;
                entity.hyperlinkKey = null;
                entity.entityKey = null;
                entity.selfKey = null;
                assert.strictEqual(reflector.tg_convert(entity), '1700');
                done();
            });
            
            test('tg_convert composite entity: Long key converts', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityCompositeKey');
                entity.stringKey = null;
                entity.dateKey = null;
                entity.integerKey = null;
                entity.longKey = 17000000000;
                entity.moneyKey = null;
                entity.colourKey = null;
                entity.hyperlinkKey = null;
                entity.entityKey = null;
                entity.selfKey = null;
                assert.strictEqual(reflector.tg_convert(entity), '17000000000');
                done();
            });
            
            test('tg_convert composite entity: Entity key converts', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityCompositeKey');
                entity.stringKey = null;
                entity.dateKey = null;
                entity.integerKey = null;
                entity.longKey = null;
                entity.moneyKey = null;
                entity.colourKey = null;
                entity.hyperlinkKey = null;
                entity.entityKey = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityStringKey');
                entity.entityKey.key = 'KEY1';
                entity.selfKey = null;
                assert.strictEqual(reflector.tg_convert(entity), 'KEY1');
                done();
            });
            
            test('tg_convert composite entity: Money key converts', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityCompositeKey');
                entity.stringKey = null;
                entity.dateKey = null;
                entity.integerKey = null;
                entity.longKey = null;
                entity.moneyKey = { amount: 1700, currency: 'AUD', taxPercent: null };
                entity.colourKey = null;
                entity.hyperlinkKey = null;
                entity.entityKey = null;
                entity.selfKey = null;
                assert.strictEqual(reflector.tg_convert(entity), '1700');
                done();
            });
            
            test('tg_convert composite entity: Colour key converts', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityCompositeKey');
                entity.stringKey = null;
                entity.dateKey = null;
                entity.integerKey = null;
                entity.longKey = null;
                entity.moneyKey = null;
                entity.colourKey = { hashlessUppercasedColourValue: 'FFCC80' };
                entity.hyperlinkKey = null;
                entity.entityKey = null;
                entity.selfKey = null;
                assert.strictEqual(reflector.tg_convert(entity), 'FFCC80');
                done();
            });
            
            test('tg_convert composite entity: Hyperlink key converts', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityCompositeKey');
                entity.stringKey = null;
                entity.dateKey = null;
                entity.integerKey = null;
                entity.longKey = null;
                entity.moneyKey = null;
                entity.colourKey = null;
                entity.hyperlinkKey = { value: 'https://www.example.com' };
                entity.entityKey = null;
                entity.selfKey = null;
                assert.strictEqual(reflector.tg_convert(entity), 'https://www.example.com');
                done();
            });
            
            test('tg_convert composite entity: custom separator is used and order of keys is correct', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityCompositeKey');
                entity.stringKey = 'KEY1';
                entity.dateKey = 0;
                entity.integerKey = 1500;
                entity.longKey = 16000000000;
                entity.moneyKey = { amount: 1700, currency: 'AUD', taxPercent: null };
                entity.colourKey = { hashlessUppercasedColourValue: 'FFCC80' };
                entity.hyperlinkKey = { value: 'https://www.example.com' };
                entity.entityKey = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityStringKey');
                entity.entityKey.key = 'KEY2';
                entity.selfKey = null;
                assert.strictEqual(reflector.tg_convert(entity), 'KEY1:' + _millisDateRepresentation(entity.dateKey, null, null) + ':1500:16000000000:1700:FFCC80:https://www.example.com:KEY2');
                done();
            });
            
            test('tg_convert composite entity: empty values are skipped regardless of their types', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityCompositeKey');
                entity.stringKey = 'KEY1';
                entity.dateKey = 0;
                entity.integerKey = null;
                entity.longKey = 16000000000;
                entity.moneyKey = null;
                entity.colourKey = { hashlessUppercasedColourValue: 'FFCC80' };
                entity.hyperlinkKey = null;
                entity.entityKey = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityStringKey');
                entity.entityKey.key = 'KEY2';
                entity.selfKey = null;
                assert.strictEqual(reflector.tg_convert(entity), 'KEY1:' + _millisDateRepresentation(entity.dateKey, null, null) + ':16000000000:FFCC80:KEY2');
                done();
            });
            
            const typeName7 = 'ua.com.fielden.platform.sample.domain.TgEntityCompositeKey';
            const typeName8 = 'ua.com.fielden.platform.sample.domain.TgEntityCompositeBooleanKey';
            const typeName9 = 'ua.com.fielden.platform.sample.domain.TgEntityStringKey';
            const typeName10 = 'ua.com.fielden.platform.sample.domain.TgEntityTwoEntityKeys';
            
            test('EntityTypeProp.type: boolean prop type is defined', function (done) {
                assert.strictEqual(reflector.getType(typeName8).prop('booleanKey').type(), 'boolean');
                done();
            });
            
            test('EntityTypeProp.type: String prop type is defined', function (done) {
                assert.strictEqual(reflector.getType(typeName7).prop('stringKey').type(), 'String');
                done();
            });
            
            test('EntityTypeProp.type: Date prop type is defined', function (done) {
                assert.strictEqual(reflector.getType(typeName7).prop('dateKey').type(), 'Date');
                done();
            });
            
            test('EntityTypeProp.type: Integer prop type is defined', function (done) {
                assert.strictEqual(reflector.getType(typeName7).prop('integerKey').type(), 'Integer');
                done();
            });
            
            test('EntityTypeProp.type: Long prop type is defined', function (done) {
                assert.strictEqual(reflector.getType(typeName7).prop('longKey').type(), 'Long');
                done();
            });
            
            test('EntityTypeProp.type: Money prop type is defined', function (done) {
                assert.strictEqual(reflector.getType(typeName7).prop('moneyKey').type(), 'Money');
                done();
            });
            
            test('EntityTypeProp.type: collection prop type is not defined', function (done) {
                assert.strictEqual(reflector.getType(typeName7).prop('listOfStringsProp').type(), null);
                assert.strictEqual(reflector.getType(typeName7).prop('setOfEntitiesProp').type(), null);
                done();
            });
            
            test('EntityTypeProp.type: Colour prop type is defined', function (done) {
                assert.strictEqual(reflector.getType(typeName7).prop('colourKey').type(), 'Colour');
                done();
            });
            
            test('EntityTypeProp.type: Hyperlink prop type is defined', function (done) {
                assert.strictEqual(reflector.getType(typeName7).prop('hyperlinkKey').type(), 'Hyperlink');
                done();
            });
            
            test('EntityTypeProp.type: entity prop type is defined', function (done) {
                assert.strictEqual(reflector.getType(typeName7).prop('entityKey').type(), reflector.getType(typeName9));
                done();
            });
            
            test('EntityTypeProp.shortCollectionKey: collection of raw values is not short-collectional and does not have shortCollectionKey', function (done) {
                assert.strictEqual(reflector.getType(typeName7).prop('listOfStringsProp').shortCollectionKey(), null);
                done();
            });
            
            test('EntityTypeProp.shortCollectionKey: collection of entities is not is not always short-collectional and in that case does not have shortCollectionKey', function (done) {
                assert.strictEqual(reflector.getType(typeName7).prop('setOfEntitiesProp').shortCollectionKey(), null);
                done();
            });
            
            test('EntityTypeProp.shortCollectionKey: short-collection does have shortCollectionKey', function (done) {
                assert.strictEqual(reflector.getType(typeName7).prop('shortCollectionalProp').shortCollectionKey(), 'entityKey');
                done();
            });
            
            test('EntityType.prop: two-level dot-notated property is defined (String)', function (done) {
                assert.strictEqual(reflector.getType(typeName10).prop('entityKey.key'), reflector.getType(typeName9).prop('key'));
                done();
            });
            
            test('EntityType.prop: two-level dot-notated property is defined (Date)', function (done) {
                assert.strictEqual(reflector.getType(typeName10).prop('parentKey.dateKey'), reflector.getType(typeName7).prop('dateKey'));
                done();
            });
            
            test('EntityType.prop: three-level dot-notated property is defined', function (done) {
                assert.strictEqual(reflector.getType(typeName10).prop('parentKey.entityKey.key'), reflector.getType(typeName9).prop('key'));
                done();
            });
            
            test('tg_determinePropertyType: boolean prop type is defined', function (done) {
                assert.strictEqual(reflector.tg_determinePropertyType(reflector.getType(typeName8), 'booleanKey'), 'boolean');
                done();
            });
            
            test('tg_determinePropertyType: String prop type is defined', function (done) {
                assert.strictEqual(reflector.tg_determinePropertyType(reflector.getType(typeName7), 'stringKey'), 'String');
                done();
            });
            
            test('tg_determinePropertyType: Date prop type is defined', function (done) {
                assert.strictEqual(reflector.tg_determinePropertyType(reflector.getType(typeName7), 'dateKey'), 'Date');
                done();
            });
            
            test('tg_determinePropertyType: Integer prop type is defined', function (done) {
                assert.strictEqual(reflector.tg_determinePropertyType(reflector.getType(typeName7), 'integerKey'), 'Integer');
                done();
            });
            
            test('tg_determinePropertyType: Long prop type is defined', function (done) {
                assert.strictEqual(reflector.tg_determinePropertyType(reflector.getType(typeName7), 'longKey'), 'Long');
                done();
            });
            
            test('tg_determinePropertyType: Money prop type is defined', function (done) {
                assert.strictEqual(reflector.tg_determinePropertyType(reflector.getType(typeName7), 'moneyKey'), 'Money');
                done();
            });
            
            test('tg_determinePropertyType: collection prop type is not defined', function (done) {
                assert.strictEqual(reflector.tg_determinePropertyType(reflector.getType(typeName7), 'listOfStringsProp'), null);
                assert.strictEqual(reflector.tg_determinePropertyType(reflector.getType(typeName7), 'setOfEntitiesProp'), null);
                done();
            });
            
            test('tg_determinePropertyType: Colour prop type is defined', function (done) {
                assert.strictEqual(reflector.tg_determinePropertyType(reflector.getType(typeName7), 'colourKey'), 'Colour');
                done();
            });
            
            test('tg_determinePropertyType: Hyperlink prop type is defined', function (done) {
                assert.strictEqual(reflector.tg_determinePropertyType(reflector.getType(typeName7), 'hyperlinkKey'), 'Hyperlink');
                done();
            });
            
            test('tg_determinePropertyType: entity prop type is defined', function (done) {
                assert.strictEqual(reflector.tg_determinePropertyType(reflector.getType(typeName7), 'entityKey'), reflector.getType(typeName9));
                done();
            });
            
            test('tg_determinePropertyType: entity-itself prop type is defined', function (done) {
                assert.strictEqual(reflector.tg_determinePropertyType(reflector.getType(typeName7), ''), reflector.getType(typeName7));
                done();
            });
            
            test('tg_determinePropertyType: key prop type of composite entity type is defined', function (done) {
                assert.strictEqual(reflector.tg_determinePropertyType(reflector.getType(typeName7), 'key'), 'DynamicEntityKey');
                done();
            });
            
            test('tg_determinePropertyType: two-level dot-notated prop type is defined (String)', function (done) {
                assert.strictEqual(reflector.tg_determinePropertyType(reflector.getType(typeName10), 'entityKey.key'), 'String');
                done();
            });
            
            test('tg_determinePropertyType: two-level dot-notated prop type is defined (Date)', function (done) {
                assert.strictEqual(reflector.tg_determinePropertyType(reflector.getType(typeName10), 'parentKey.dateKey'), 'Date');
                done();
            });
            
            test('tg_determinePropertyType: two-level dot-notated prop type is defined (DynamicEntityKey)', function (done) {
                assert.strictEqual(reflector.tg_determinePropertyType(reflector.getType(typeName10), 'parentKey.key'), 'DynamicEntityKey');
                done();
            });
            
            test('tg_determinePropertyType: three-level dot-notated prop type is defined', function (done) {
                assert.strictEqual(reflector.tg_determinePropertyType(reflector.getType(typeName10), 'parentKey.entityKey.key'), 'String');
                done();
            });
            
            test('tg_toString: dot-notated composite entity-typed prop', function (done) {
                const parentEntity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityEntityKey');
                parentEntity.compositeProp = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityTwoEntityKeys');
                parentEntity.compositeProp.parentKey = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityCompositeKey');
                parentEntity.compositeProp.parentKey.stringKey = 'KEY1';
                parentEntity.compositeProp.parentKey.dateKey = null;
                parentEntity.compositeProp.parentKey.integerKey = null;
                parentEntity.compositeProp.parentKey.longKey = null;
                parentEntity.compositeProp.parentKey.moneyKey = null;
                parentEntity.compositeProp.parentKey.colourKey = null;
                parentEntity.compositeProp.parentKey.hyperlinkKey = null;
                parentEntity.compositeProp.parentKey.entityKey = null;
                parentEntity.compositeProp.parentKey.selfKey = null;
                assert.strictEqual(reflector.tg_toString(parentEntity.get('compositeProp.parentKey'), parentEntity.type(), 'compositeProp.parentKey'), 'KEY1');
                done();
            });
            
            test('tg_toString: dot-notated composite entity-typed prop and accessing its key', function (done) {
                const parentEntity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityEntityKey');
                parentEntity.compositeProp = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityTwoEntityKeys');
                parentEntity.compositeProp.parentKey = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityCompositeKey');
                parentEntity.compositeProp.parentKey.stringKey = 'KEY1';
                parentEntity.compositeProp.parentKey.dateKey = null;
                parentEntity.compositeProp.parentKey.integerKey = null;
                parentEntity.compositeProp.parentKey.longKey = null;
                parentEntity.compositeProp.parentKey.moneyKey = null;
                parentEntity.compositeProp.parentKey.colourKey = null;
                parentEntity.compositeProp.parentKey.hyperlinkKey = null;
                parentEntity.compositeProp.parentKey.entityKey = null;
                parentEntity.compositeProp.parentKey.selfKey = null;
                assert.strictEqual(reflector.tg_toString(parentEntity.get('compositeProp.parentKey.key'), parentEntity.type(), 'compositeProp.parentKey.key'), 'KEY1');
                done();
            });
            
            test('tg_toString standard: empty (null) converts', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityCompositeKey');
                entity.stringKey = null;
                assert.strictEqual(reflector.tg_toString(entity.get('stringKey'), entity.type(), 'stringKey'), '');
                entity.dateKey = null;
                assert.strictEqual(reflector.tg_toString(entity.get('dateKey'), entity.type(), 'dateKey'), '');
                entity.integerKey = null;
                assert.strictEqual(reflector.tg_toString(entity.get('integerKey'), entity.type(), 'integerKey'), '');
                entity.longKey = null;
                assert.strictEqual(reflector.tg_toString(entity.get('longKey'), entity.type(), 'longKey'), '');
                entity.moneyKey = null;
                assert.strictEqual(reflector.tg_toString(entity.get('moneyKey'), entity.type(), 'moneyKey'), '');
                entity.colourKey = null;
                assert.strictEqual(reflector.tg_toString(entity.get('colourKey'), entity.type(), 'colourKey'), '');
                entity.hyperlinkKey = null;
                assert.strictEqual(reflector.tg_toString(entity.get('hyperlinkKey'), entity.type(), 'hyperlinkKey'), '');
                entity.entityKey = null;
                assert.strictEqual(reflector.tg_toString(entity.get('entityKey'), entity.type(), 'entityKey'), '');
                entity.listOfStringsProp = null;
                assert.strictEqual(reflector.tg_toString(entity.get('listOfStringsProp'), entity.type(), 'listOfStringsProp'), '');
                entity.setOfEntitiesProp = null;
                assert.strictEqual(reflector.tg_toString(entity.get('setOfEntitiesProp'), entity.type(), 'setOfEntitiesProp'), '');
                entity.shortCollectionalProp = null;
                assert.strictEqual(reflector.tg_toString(entity.get('shortCollectionalProp'), entity.type(), 'shortCollectionalProp'), '');
                done();
            });
            
            test('tg_toString standard: String converts', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityCompositeKey');
                entity.stringKey = 'KEY1';
                assert.strictEqual(reflector.tg_toString(entity.get('stringKey'), entity.type(), 'stringKey'), 'KEY1');
                done();
            });
            
            test('tg_toString standard: String converts (empty string)', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityCompositeKey');
                entity.stringKey = '';
                assert.strictEqual(reflector.tg_toString(entity.get('stringKey'), entity.type(), 'stringKey'), '');
                done();
            });
            
            test('tg_toString standard: boolean converts (true)', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityCompositeBooleanKey');
                entity.booleanKey = true;
                assert.strictEqual(reflector.tg_toString(entity.get('booleanKey'), entity.type(), 'booleanKey'), 'true');
                done();
            });
            
            test('tg_toString standard: boolean converts (empty)', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityCompositeBooleanKey');
                entity.booleanKey = null;
                assert.strictEqual(reflector.tg_toString(entity.get('booleanKey'), entity.type(), 'booleanKey'), 'false');
                done();
            });
            
            test('tg_toString standard: boolean converts (false)', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityCompositeBooleanKey');
                entity.booleanKey = false;
                assert.strictEqual(reflector.tg_toString(entity.get('booleanKey'), entity.type(), 'booleanKey'), 'false');
                done();
            });
            
            test('tg_toString standard: Date converts', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityCompositeKey');
                entity.dateKey = 0;
                assert.strictEqual(reflector.tg_toString(entity.get('dateKey'), entity.type(), 'dateKey'), _millisDateRepresentation(entity.dateKey, null, null));
                done();
            });
            
            test('tg_toString standard: Integer converts', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityCompositeKey');
                entity.integerKey = 1700;
                assert.strictEqual(reflector.tg_toString(entity.get('integerKey'), entity.type(), 'integerKey'), '1700');
                done();
            });
            
            test('tg_toString standard: Long converts', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityCompositeKey');
                entity.longKey = 17000000000;
                assert.strictEqual(reflector.tg_toString(entity.get('longKey'), entity.type(), 'longKey'), '17000000000');
                done();
            });
            
            test('tg_toString standard: Entity converts', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityCompositeKey');
                entity.entityKey = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityStringKey');
                entity.entityKey.key = 'KEY1';
                assert.strictEqual(reflector.tg_toString(entity.get('entityKey'), entity.type(), 'entityKey'), 'KEY1');
                done();
            });
            
            test('tg_toString standard: Money converts', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityCompositeKey');
                entity.moneyKey = { amount: 1700, currency: 'AUD', taxPercent: null };
                assert.strictEqual(reflector.tg_toString(entity.get('moneyKey'), entity.type(), 'moneyKey'), '1700');
                done();
            });
            
            test('tg_toString standard: empty collection converts', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityCompositeKey');
                entity.listOfStringsProp = [];
                assert.strictEqual(reflector.tg_toString(entity.get('listOfStringsProp'), entity.type(), 'listOfStringsProp'), '');
                entity.setOfEntitiesProp = [];
                assert.strictEqual(reflector.tg_toString(entity.get('setOfEntitiesProp'), entity.type(), 'setOfEntitiesProp'), '');
                entity.shortCollectionalProp = [];
                assert.strictEqual(reflector.tg_toString(entity.get('shortCollectionalProp'), entity.type(), 'shortCollectionalProp'), '');
                done();
            });
            
            test('tg_toString standard: list of strings converts', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityCompositeKey');
                entity.listOfStringsProp = ['str1', '', 'str2', null, 'str3', null];
                assert.strictEqual(reflector.tg_toString(entity.get('listOfStringsProp'), entity.type(), 'listOfStringsProp'), 'str1, str2, str3');
                done();
            });
            
            test('tg_toString standard: long collection converts', function (done) {
                const master = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityCompositeKey');
                master.stringKey = 'MASTER';
                master.dateKey = null;
                master.integerKey = null;
                master.longKey = null;
                master.moneyKey = null;
                master.colourKey = null;
                master.hyperlinkKey = null;
                master.entityKey = null;
                master.selfKey = null;
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityCompositeKey');
                entity.stringKey = 'STR1';
                entity.dateKey = null;
                entity.integerKey = null;
                entity.longKey = null;
                entity.moneyKey = null;
                entity.colourKey = null;
                entity.hyperlinkKey = null;
                entity.entityKey = null;
                entity.selfKey = master;
                master.setOfEntitiesProp = [entity, null, entity, null, entity, null];
                assert.strictEqual(reflector.tg_toString(master.get('setOfEntitiesProp'), master.type(), 'setOfEntitiesProp'), 'STR1:MASTER, STR1:MASTER, STR1:MASTER');
                done();
            });
            
            test('tg_toString standard: short collection converts', function (done) {
                const master = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityCompositeKey');
                master.stringKey = 'MASTER';
                master.dateKey = null;
                master.integerKey = null;
                master.longKey = null;
                master.moneyKey = null;
                master.colourKey = null;
                master.hyperlinkKey = null;
                master.entityKey = null;
                master.selfKey = null;
                const entity1 = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityTwoEntityKeys');
                entity1.parentKey = master;
                entity1.entityKey = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityStringKey');
                entity1.entityKey.key = 'STR1';
                const entity2 = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityTwoEntityKeys');
                entity2.parentKey = master;
                entity2.entityKey = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityStringKey');
                entity2.entityKey.key = 'STR2';
                const entity3 = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityTwoEntityKeys');
                entity3.parentKey = master;
                entity3.entityKey = null;
                master.shortCollectionalProp = [entity1, null, entity2, null, entity3, null];
                assert.strictEqual(reflector.tg_toString(master.get('shortCollectionalProp'), master.type(), 'shortCollectionalProp'), 'STR1, STR2');
                done();
            });
            
            test('tg_toString standard: Colour converts', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityCompositeKey');
                entity.colourKey = { hashlessUppercasedColourValue: 'FFCC80' };
                assert.strictEqual(reflector.tg_toString(entity.get('colourKey'), entity.type(), 'colourKey'), 'FFCC80');
                done();
            });
            
            test('tg_toString standard: Hyperlink converts', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityCompositeKey');
                entity.hyperlinkKey = { value: 'https://www.example.com' };
                assert.strictEqual(reflector.tg_toString(entity.get('hyperlinkKey'), entity.type(), 'hyperlinkKey'), 'https://www.example.com');
                done();
            });
            
            test('tg_toString for display: empty (null) converts', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityCompositeKey');
                entity.stringKey = null;
                assert.strictEqual(reflector.tg_toString(entity.get('stringKey'), entity.type(), 'stringKey', { display: true }), '');
                entity.dateKey = null;
                assert.strictEqual(reflector.tg_toString(entity.get('dateKey'), entity.type(), 'dateKey', { display: true }), '');
                entity.integerKey = null;
                assert.strictEqual(reflector.tg_toString(entity.get('integerKey'), entity.type(), 'integerKey', { display: true }), '');
                entity.longKey = null;
                assert.strictEqual(reflector.tg_toString(entity.get('longKey'), entity.type(), 'longKey', { display: true }), '');
                entity.moneyKey = null;
                assert.strictEqual(reflector.tg_toString(entity.get('moneyKey'), entity.type(), 'moneyKey', { display: true }), '');
                entity.colourKey = null;
                assert.strictEqual(reflector.tg_toString(entity.get('colourKey'), entity.type(), 'colourKey', { display: true }), '');
                entity.hyperlinkKey = null;
                assert.strictEqual(reflector.tg_toString(entity.get('hyperlinkKey'), entity.type(), 'hyperlinkKey', { display: true }), '');
                entity.entityKey = null;
                assert.strictEqual(reflector.tg_toString(entity.get('entityKey'), entity.type(), 'entityKey', { display: true }), '');
                entity.listOfStringsProp = null;
                assert.strictEqual(reflector.tg_toString(entity.get('listOfStringsProp'), entity.type(), 'listOfStringsProp', { display: true }), '');
                entity.setOfEntitiesProp = null;
                assert.strictEqual(reflector.tg_toString(entity.get('setOfEntitiesProp'), entity.type(), 'setOfEntitiesProp', { display: true }), '');
                entity.shortCollectionalProp = null;
                assert.strictEqual(reflector.tg_toString(entity.get('shortCollectionalProp'), entity.type(), 'shortCollectionalProp', { display: true }), '');
                done();
            });
            
            test('tg_toString for display: String converts', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityCompositeKey');
                entity.stringKey = 'KEY1';
                assert.strictEqual(reflector.tg_toString(entity.get('stringKey'), entity.type(), 'stringKey', { display: true }), 'KEY1');
                done();
            });
            
            test('tg_toString for display: String converts (empty string)', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityCompositeKey');
                entity.stringKey = '';
                assert.strictEqual(reflector.tg_toString(entity.get('stringKey'), entity.type(), 'stringKey', { display: true }), '');
                done();
            });
            
            test('tg_toString for display: boolean converts (true)', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityCompositeBooleanKey');
                entity.booleanKey = true;
                assert.strictEqual(reflector.tg_toString(entity.get('booleanKey'), entity.type(), 'booleanKey', { display: true }), 'true');
                done();
            });
            
            test('tg_toString for display: boolean converts (empty)', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityCompositeBooleanKey');
                entity.booleanKey = null;
                assert.strictEqual(reflector.tg_toString(entity.get('booleanKey'), entity.type(), 'booleanKey', { display: true }), 'false');
                done();
            });
            
            test('tg_toString for display: boolean converts (false)', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityCompositeBooleanKey');
                entity.booleanKey = false;
                assert.strictEqual(reflector.tg_toString(entity.get('booleanKey'), entity.type(), 'booleanKey', { display: true }), 'false');
                done();
            });
            
            test('tg_toString for display: Date converts', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityCompositeKey');
                entity.dateKey = 0;
                assert.strictEqual(reflector.tg_toString(entity.get('dateKey'), entity.type(), 'dateKey', { display: true }), _millisDateRepresentation(entity.dateKey, null, null));
                done();
            });
            
            const locale = 'en-AU';
            
            test('tg_toString for display: Integer converts', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityCompositeKey');
                entity.integerKey = 1700;
                assert.strictEqual(reflector.tg_toString(entity.get('integerKey'), entity.type(), 'integerKey', { display: true, locale: locale }), reflector.tg_formatInteger(entity.get('integerKey'), locale));
                done();
            });
            
            test('tg_toString for display: Long converts', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityCompositeKey');
                entity.longKey = 17000000000;
                assert.strictEqual(reflector.tg_toString(entity.get('longKey'), entity.type(), 'longKey', { display: true, locale: locale }), reflector.tg_formatInteger(entity.get('longKey'), locale));
                done();
            });
            
            test('tg_toString for display: Entity converts', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityCompositeKey');
                entity.entityKey = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityStringKey');
                entity.entityKey.key = 'KEY1';
                assert.strictEqual(reflector.tg_toString(entity.get('entityKey'), entity.type(), 'entityKey', { display: true }), 'KEY1');
                done();
            });
            
            test('tg_toString for display: Money converts', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityCompositeKey');
                entity.moneyKey = { amount: 1700, currency: 'AUD', taxPercent: null };
                assert.strictEqual(reflector.tg_toString(entity.get('moneyKey'), entity.type(), 'moneyKey', { display: true, locale: locale }), reflector.tg_formatMoney(entity.get('moneyKey'), locale, entity.type().prop('moneyKey').scale(), entity.type().prop('moneyKey').trailingZeros()));
                done();
            });
            
            test('tg_toString for display: empty collection converts', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityCompositeKey');
                entity.listOfStringsProp = [];
                assert.strictEqual(reflector.tg_toString(entity.get('listOfStringsProp'), entity.type(), 'listOfStringsProp', { display: true }), '');
                entity.setOfEntitiesProp = [];
                assert.strictEqual(reflector.tg_toString(entity.get('setOfEntitiesProp'), entity.type(), 'setOfEntitiesProp', { display: true }), '');
                entity.shortCollectionalProp = [];
                assert.strictEqual(reflector.tg_toString(entity.get('shortCollectionalProp'), entity.type(), 'shortCollectionalProp', { display: true }), '');
                done();
            });
            
            test('tg_toString for display: list of strings converts', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityCompositeKey');
                entity.listOfStringsProp = ['str1', '', 'str2', null, 'str3', null];
                assert.strictEqual(reflector.tg_toString(entity.get('listOfStringsProp'), entity.type(), 'listOfStringsProp', { display: true }), 'str1, str2, str3');
                done();
            });
            
            test('tg_toString for display: long collection converts', function (done) {
                const master = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityCompositeKey');
                master.stringKey = 'MASTER';
                master.dateKey = null;
                master.integerKey = null;
                master.longKey = null;
                master.moneyKey = null;
                master.colourKey = null;
                master.hyperlinkKey = null;
                master.entityKey = null;
                master.selfKey = null;
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityCompositeKey');
                entity.stringKey = 'STR1';
                entity.dateKey = null;
                entity.integerKey = null;
                entity.longKey = null;
                entity.moneyKey = null;
                entity.colourKey = null;
                entity.hyperlinkKey = null;
                entity.entityKey = null;
                entity.selfKey = master;
                master.setOfEntitiesProp = [entity, null, entity, null, entity, null];
                assert.strictEqual(reflector.tg_toString(master.get('setOfEntitiesProp'), master.type(), 'setOfEntitiesProp', { display: true }), 'STR1:MASTER, STR1:MASTER, STR1:MASTER');
                done();
            });
            
            test('tg_toString for display: short collection converts', function (done) {
                const master = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityCompositeKey');
                master.stringKey = 'MASTER';
                master.dateKey = null;
                master.integerKey = null;
                master.longKey = null;
                master.moneyKey = null;
                master.colourKey = null;
                master.hyperlinkKey = null;
                master.entityKey = null;
                master.selfKey = null;
                const entity1 = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityTwoEntityKeys');
                entity1.parentKey = master;
                entity1.entityKey = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityStringKey');
                entity1.entityKey.key = 'STR1';
                const entity2 = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityTwoEntityKeys');
                entity2.parentKey = master;
                entity2.entityKey = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityStringKey');
                entity2.entityKey.key = 'STR2';
                const entity3 = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityTwoEntityKeys');
                entity3.parentKey = master;
                entity3.entityKey = null;
                master.shortCollectionalProp = [entity1, null, entity2, null, entity3, null];
                assert.strictEqual(reflector.tg_toString(master.get('shortCollectionalProp'), master.type(), 'shortCollectionalProp', { display: true }), 'STR1, STR2');
                done();
            });
            
            test('tg_toString for display: Colour converts', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityCompositeKey');
                entity.colourKey = { hashlessUppercasedColourValue: 'FFCC80' };
                assert.strictEqual(reflector.tg_toString(entity.get('colourKey'), entity.type(), 'colourKey', { display: true }), '#FFCC80');
                done();
            });
            
            test('tg_toString for display: Hyperlink converts', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityCompositeKey');
                entity.hyperlinkKey = { value: 'https://www.example.com' };
                assert.strictEqual(reflector.tg_toString(entity.get('hyperlinkKey'), entity.type(), 'hyperlinkKey', { display: true }), 'https://www.example.com');
                done();
            });
            
            // Testing the access to 'key' property of different kinds of entities.
            // This property is of high importance and should be much in sync with server-side implementation.
            // At this stage only equality and toString implementation is used when accessing properties.
            // However client-side code is not restricted to that.
            
            /////////////////////// entity.get('key') tests ///////////////////////
            test('test empty object convertion should be fine', function (done) {
                assert.deepEqual(reflector.tg_convert({}), {});
                done();
            });
            
            test('test object with arbitrary properties convertion should not be acceptable', function (done) {
                try {
                    reflector.tg_convert({testProp: "testProp"});
                } catch (ex) {
                    done();
                }
            });
            
            test('simple entity: key access is forbidden if not fetched', function (done) {
                const e1 = reflector.newEntity(typeName1);
                try {
                    e1.get('key');
                    assert.fail('Strict proxy exception is required.');
                } catch (ex) {
                    done();
                }
            });
            
            test('simple entity: key access returns concrete value if fetched', function (done) {
                const e1 = reflector.newEntity(typeName1);
                e1.key = 'DEMO01';
                assert.strictEqual(e1.get('key'), 'DEMO01');
                done();
            });
            
            test('simple entity: equality comparison is forbidden if key is not fetched', function (done) {
                const entity1 = reflector.newEntity(typeName1);
                entity1.key = 'DEMO01';
                const entity2 = reflector.newEntity(typeName1); // key is not fetched
                try {
                    reflector.equalsEx(entity1, entity2);
                    assert.fail('Strict proxy exception is required.');
                } catch (ex) {
                    done();
                }
            });
            
            test('simple entity: equality comparison succeeds if key is fetched', function (done) {
                const entity1 = reflector.newEntity(typeName1);
                entity1.key = 'DEMO01';
                const entity2 = reflector.newEntity(typeName1);
                entity2.key = 'DEMO01';
                
                assert.strictEqual(reflector.equalsEx(entity1, entity2), true);
                done();
            });
            
            test('simple entity: conversion is forbidden if key is not fetched', function (done) {
                const entity1 = reflector.newEntity(typeName1);
                try {
                    reflector.tg_convert(entity1);
                    assert.fail('Strict proxy exception is required.');
                } catch (ex) {
                    done();
                }
            });
            
            test('simple entity: conversion succeeds if key is fetched', function (done) {
                const entity1 = reflector.newEntity(typeName1);
                entity1.key = 'DEMO01';
                
                assert.strictEqual(reflector.tg_convert(entity1), 'DEMO01');
                done();
            });
            
            test('composite entity: key access returns DynamicEntityKey instance for fully-fetched composite keys', function (done) {
                const e1 = reflector.newEntity(typeName1);
                e1.key = 'DEMO01';
                const entity1 = reflector.newEntity(typeName2);
                entity1.key1 = e1;
                entity1.key2 = 7;
                assert.strictEqual(entity1.get('key') instanceof reflector.getDynamicEntityKeyPrototype(), true);
                done();
            });
            
            test('composite entity: key access also returns DynamicEntityKey instance for partly-fetched composite keys', function (done) {
                const entity1 = reflector.newEntity(typeName2);
                entity1.key2 = 7; // key1 is not fetched
                assert.strictEqual(entity1.get('key') instanceof reflector.getDynamicEntityKeyPrototype(), true);
                done();
            });
            
            test('composite entity: equality comparison is forbidden for partly-fetched composite keys', function (done) {
                const entity1 = reflector.newEntity(typeName2);
                entity1.key2 = 7; // key1 is not fetched
                
                const e1 = reflector.newEntity(typeName1);
                e1.key = 'DEMO01';
                const entity2 = reflector.newEntity(typeName2);
                entity2.key1 = e1;
                entity2.key2 = 7;
                
                try {
                    reflector.equalsEx(entity1, entity2);
                    assert.fail('Strict proxy exception is required.');
                } catch (ex) {
                    done();
                }
            });
            
            test('composite entity: equality comparison succeeds for fully-fetched composite keys', function (done) {
                const e1 = reflector.newEntity(typeName1);
                e1.key = 'DEMO01';
                const entity1 = reflector.newEntity(typeName2);
                entity1.key1 = e1;
                entity1.key2 = 7;
                
                const entity2 = reflector.newEntity(typeName2);
                entity2.key1 = e1;
                entity2.key2 = 7;
                
                assert.strictEqual(reflector.equalsEx(entity1, entity2), true);
                done();
            });
            
            test('composite entity: conversion is forbidden for partly-fetched composite keys', function (done) {
                const entity1 = reflector.newEntity(typeName2);
                entity1.key2 = 7; // key1 is not fetched
                try {
                    reflector.tg_convert(entity1);
                    assert.fail('Strict proxy exception is required.');
                } catch (ex) {
                    done();
                }
            });
            
            test('composite entity: conversion succeeds for fully-fetched composite keys', function (done) {
                const e1 = reflector.newEntity(typeName1);
                e1.key = 'DEMO01';
                const entity1 = reflector.newEntity(typeName2);
                entity1.key1 = e1;
                entity1.key2 = 7;
                
                assert.strictEqual(reflector.tg_convert(entity1), 'DEMO01 7');
                done();
            });
            
            test('union entity: key access for empty union entity returns empty value', function (done) {
                const uEntity = reflector.newEntity(typeName3); // TgBogieLocation union entity (no active entity)
                
                assert.strictEqual(uEntity.get('key'), null);
                done();
            });
            
            test('union entity: equality comparison succeeds for empty union entity', function (done) {
                const uEntity1 = reflector.newEntity(typeName3); // TgBogieLocation union entity (no active entity)
                const uEntity2 = reflector.newEntity(typeName3); // TgBogieLocation union entity (no active entity)
                assert.strictEqual(reflector.equalsEx(uEntity1, uEntity2), true);
                done();
            });
            
            test('union entity: conversion succeeds for empty union entity', function (done) {
                const uEntity1 = reflector.newEntity(typeName3); // TgBogieLocation union entity (no active entity)
                assert.strictEqual(reflector.tg_convert(uEntity1), '');
                done();
            });
            
            test('union entity: key access for union entity with simple entity being active returns key of this active entity', function (done) {
                const uEntity = reflector.newEntity(typeName3); // TgBogieLocation union entity (simple active entity)
                const workshop1 = reflector.newEntity(typeName4); // TgWorkshop
                workshop1.key = 'W1';
                uEntity.workshop = workshop1;
                
                assert.strictEqual(uEntity.get('key'), 'W1');
                done();
            });
            
            test('union entity: equality comparison for union entity with simple entity being active succeeds', function (done) {
                const uEntity1 = reflector.newEntity(typeName3); // TgBogieLocation union entity (simple active entity)
                const workshop1 = reflector.newEntity(typeName4); // TgWorkshop
                workshop1.key = 'W1';
                uEntity1.workshop = workshop1;
                const uEntity2 = reflector.newEntity(typeName3); // TgBogieLocation union entity (simple active entity)
                const workshop2 = reflector.newEntity(typeName4); // TgWorkshop
                workshop2.key = 'W1';
                uEntity2.workshop = workshop2;
                
                assert.strictEqual(reflector.equalsEx(uEntity1, uEntity2), true);
                done();
            });
            
            test('union entity: conversion for union entity with simple entity being active succeeds', function (done) {
                const uEntity1 = reflector.newEntity(typeName3); // TgBogieLocation union entity (simple active entity)
                const workshop1 = reflector.newEntity(typeName4); // TgWorkshop
                workshop1.key = 'W1';
                uEntity1.workshop = workshop1;
                
                assert.strictEqual(reflector.tg_convert(uEntity1), 'W1');
                done();
            });
            
            test('union entity: key access for union entity with composite entity being active returns key of this active entity', function (done) {
                const uEntity = reflector.newEntity(typeName3); // TgBogieLocation union entity (composite active entity)
                const wagonSlot1 = reflector.newEntity(typeName5); // TgWagonSlot
                const wagon1 = reflector.newEntity(typeName6); // TgWagon
                wagon1.key = 'WAG1';
                wagonSlot1.wagon = wagon1;
                wagonSlot1.position = 7;
                uEntity.wagonSlot = wagonSlot1;
                
                assert.strictEqual(uEntity.get('key') instanceof reflector.getDynamicEntityKeyPrototype(), true);
                done();
            });
            
            test('union entity: equality comparison for union entity with composite entity being active succeeds', function (done) {
                const uEntity1 = reflector.newEntity(typeName3); // TgBogieLocation union entity (composite active entity)
                const wagonSlot1 = reflector.newEntity(typeName5); // TgWagonSlot
                const wagon1 = reflector.newEntity(typeName6); // TgWagon
                wagon1.key = 'WAG1';
                wagonSlot1.wagon = wagon1;
                wagonSlot1.position = 7;
                uEntity1.wagonSlot = wagonSlot1;
                const uEntity2 = reflector.newEntity(typeName3); // TgBogieLocation union entity (composite active entity)
                const wagonSlot2 = reflector.newEntity(typeName5); // TgWagonSlot
                const wagon2 = reflector.newEntity(typeName6); // TgWagon
                wagon2.key = 'WAG1';
                wagonSlot2.wagon = wagon2;
                wagonSlot2.position = 7;
                uEntity2.wagonSlot = wagonSlot2;
                
                assert.strictEqual(reflector.equalsEx(uEntity1, uEntity2), true);
                done();
            });
            
            test('union entity: conversion for union entity with composite entity being active succeeds', function (done) {
                const uEntity1 = reflector.newEntity(typeName3); // TgBogieLocation union entity (composite active entity)
                const wagonSlot1 = reflector.newEntity(typeName5); // TgWagonSlot
                const wagon1 = reflector.newEntity(typeName6); // TgWagon
                wagon1.key = 'WAG1';
                wagonSlot1.wagon = wagon1;
                wagonSlot1.position = 7;
                uEntity1.wagonSlot = wagonSlot1;
                
                assert.strictEqual(reflector.tg_convert(uEntity1), 'WAG1 7');
                done();
            });
            
            test('union entity: key access for union entity with simple entity being active is forbidden for partly-fetched active entity', function (done) {
                const uEntity = reflector.newEntity(typeName3); // TgBogieLocation union entity (simple active entity)
                const workshop1 = reflector.newEntity(typeName4); // TgWorkshop
                uEntity.workshop = workshop1;
                
                try {
                    uEntity.get('key');
                    assert.fail('Strict proxy exception is required.');
                } catch (ex) {
                    done();
                }
            });
            
            test('union entity: equality comparison for union entity with simple entity being active is forbidden for partly-fetched active entity', function (done) {
                const uEntity1 = reflector.newEntity(typeName3); // TgBogieLocation union entity (simple active entity)
                const workshop1 = reflector.newEntity(typeName4); // TgWorkshop
                uEntity1.workshop = workshop1;
                const uEntity2 = reflector.newEntity(typeName3); // TgBogieLocation union entity (simple active entity)
                const workshop2 = reflector.newEntity(typeName4); // TgWorkshop
                workshop2.key = 'W1';
                uEntity2.workshop = workshop1;
                
                try {
                    reflector.equalsEx(uEntity1, uEntity2);
                    assert.fail('Strict proxy exception is required.');
                } catch (ex) {
                    done();
                }
            });
            
            test('union entity: conversion for union entity with simple entity being active is forbidden for partly-fetched active entity', function (done) {
                const uEntity1 = reflector.newEntity(typeName3); // TgBogieLocation union entity (simple active entity)
                const workshop1 = reflector.newEntity(typeName4); // TgWorkshop
                uEntity1.workshop = workshop1;
                
                try {
                    reflector.tg_convert(uEntity1);
                    assert.fail('Strict proxy exception is required.');
                } catch (ex) {
                    done();
                }
            });
            
            test('union entity: key access for union entity with composite entity being active succeeds for partly-fetched active entity', function (done) {
                const uEntity = reflector.newEntity(typeName3); // TgBogieLocation union entity (composite active entity)
                const wagonSlot1 = reflector.newEntity(typeName5); // TgWagonSlot
                wagonSlot1.position = 7; // wagon is not fetched
                uEntity.wagonSlot = wagonSlot1;
                
                assert.strictEqual(uEntity.get('key') instanceof reflector.getDynamicEntityKeyPrototype(), true);
                done();
            });
            
            test('union entity: equality comparison for union entity with composite entity being active is forbidden for partly-fetched active entity', function (done) {
                const uEntity1 = reflector.newEntity(typeName3); // TgBogieLocation union entity (composite active entity)
                const wagonSlot1 = reflector.newEntity(typeName5); // TgWagonSlot
                wagonSlot1.position = 7; // wagon is not fetched
                uEntity1.wagonSlot = wagonSlot1;
                const uEntity2 = reflector.newEntity(typeName3); // TgBogieLocation union entity (composite active entity)
                const wagonSlot2 = reflector.newEntity(typeName5); // TgWagonSlot
                const wagon2 = reflector.newEntity(typeName6); // TgWagon
                wagon2.key = 'WAG1';
                wagonSlot2.wagon = wagon2;
                wagonSlot2.position = 7;
                uEntity2.wagonSlot = wagonSlot2;
                
                try {
                    reflector.equalsEx(uEntity1, uEntity2);
                    assert.fail('Strict proxy exception is required.');
                } catch (ex) {
                    done();
                }
            });
            
            test('union entity: conversion for union entity with composite entity being active is forbidden for partly-fetched active entity', function (done) {
                const uEntity1 = reflector.newEntity(typeName3); // TgBogieLocation union entity (composite active entity)
                const wagonSlot1 = reflector.newEntity(typeName5); // TgWagonSlot
                wagonSlot1.position = 7; // wagon is not fetched
                uEntity1.wagonSlot = wagonSlot1;
                
                try {
                    reflector.tg_convert(uEntity1);
                    assert.fail('Strict proxy exception is required.');
                } catch (ex) {
                    done();
                }
            });
            
            /////////////////////// entity.get('key') tests [END] /////////////////
            
            test('equalsEx method works for regular values', function (done) {
                assert.strictEqual(reflector.equalsEx('ok', 'ok'), true, "Equal values should return 'true' from equalsEx method.");
                assert.strictEqual(reflector.equalsEx('ok', 'not_ok'), false, "Not equal values should return 'false' from equalsEx method.");
                
                done();
            });
            
            test('equalsEx method works for money values', function (done) {
                assert.strictEqual(reflector.equalsEx({ amount: 45.6 }, undefined), false);
                assert.strictEqual(reflector.equalsEx({ amount: 45.6 }, null), false);
                assert.strictEqual(reflector.equalsEx({ amount: 45.6 }, {}), false);
                assert.strictEqual(reflector.equalsEx({ amount: 45.6 }, { amount: 45.6 }), true);
                assert.strictEqual(reflector.equalsEx({ amount: 45.6 }, { amount: 44.6 }), false);
                assert.strictEqual(reflector.equalsEx({ amount: 45.6, currency: 'AUD' }, { amount: 45.6 }), true);
                assert.strictEqual(reflector.equalsEx({ amount: 45.6 }, { amount: 45.6, currency: 'AUD' }), true);
                assert.strictEqual(reflector.equalsEx({ amount: 45.6 }, { amount: 45.6, taxPercent: null }), true);
                assert.strictEqual(reflector.equalsEx({ amount: 45.6 }, { amount: 45.6, currency: 'AUD', taxPercent: null }), true);
                
                assert.strictEqual(reflector.equalsEx(undefined, { amount: 45.6 }), false);
                assert.strictEqual(reflector.equalsEx(null, { amount: 45.6 }), false);
                assert.strictEqual(reflector.equalsEx({}, { amount: 45.6 }), false);
                assert.strictEqual(reflector.equalsEx({ amount: 45.6 }, { amount: 45.6, currency: 'AUD' }), true);
                assert.strictEqual(reflector.equalsEx({ amount: 45.6, currency: 'AUD' }, { amount: 45.6 }), true);
                assert.strictEqual(reflector.equalsEx({ amount: 45.6, taxPercent: null }, { amount: 45.6 }), true);
                assert.strictEqual(reflector.equalsEx({ amount: 45.6, currency: 'AUD', taxPercent: null }, { amount: 45.6 }), true);
                
                done();
            });
            
            test('equalsEx method works for colour values', function (done) {
                assert.strictEqual(reflector.equalsEx({ hashlessUppercasedColourValue: 'F44336' }, undefined), false);
                assert.strictEqual(reflector.equalsEx({ hashlessUppercasedColourValue: 'F44336' }, null), false);
                assert.strictEqual(reflector.equalsEx({ hashlessUppercasedColourValue: 'F44336' }, {}), false);
                assert.strictEqual(reflector.equalsEx({ hashlessUppercasedColourValue: 'F44336' }, { hashlessUppercasedColourValue: 'F44336' }), true);
                assert.strictEqual(reflector.equalsEx({ hashlessUppercasedColourValue: 'F44336' }, { hashlessUppercasedColourValue: 'F44338' }), false);
                assert.strictEqual(reflector.equalsEx({ hashlessUppercasedColourValue: 'F44336', redundantProp: '3' }, { hashlessUppercasedColourValue: 'F44336' }), true);
                assert.strictEqual(reflector.equalsEx({ hashlessUppercasedColourValue: 'F44336' }, { hashlessUppercasedColourValue: 'F44336', redundantProp: '3' }), true);
                
                assert.strictEqual(reflector.equalsEx(undefined, { hashlessUppercasedColourValue: 'F44336' }), false);
                assert.strictEqual(reflector.equalsEx(null, { hashlessUppercasedColourValue: 'F44336' }), false);
                assert.strictEqual(reflector.equalsEx({}, { hashlessUppercasedColourValue: 'F44336' }), false);
                
                done();
            });
            
            test('equalsEx method works for hyperlink values', function (done) {
                assert.strictEqual(reflector.equalsEx({ value: 'https://fielden.com.ua' }, undefined), false);
                assert.strictEqual(reflector.equalsEx({ value: 'https://fielden.com.ua' }, null), false);
                assert.strictEqual(reflector.equalsEx({ value: 'https://fielden.com.ua' }, {}), false);
                assert.strictEqual(reflector.equalsEx({ value: 'https://fielden.com.ua' }, { value: 'https://fielden.com.ua' }), true);
                assert.strictEqual(reflector.equalsEx({ value: 'https://fielden.com.ua' }, { value: 'https://fielden.com.au' }), false);
                assert.strictEqual(reflector.equalsEx({ value: 'https://fielden.com.ua', redundantProp: '3' }, { value: 'https://fielden.com.ua' }), true);
                assert.strictEqual(reflector.equalsEx({ value: 'https://fielden.com.ua' }, { value: 'https://fielden.com.ua', redundantProp: '3' }), true);
                
                assert.strictEqual(reflector.equalsEx(undefined, { value: 'https://fielden.com.ua' }), false);
                assert.strictEqual(reflector.equalsEx(null, { value: 'https://fielden.com.ua' }), false);
                assert.strictEqual(reflector.equalsEx({}, { value: 'https://fielden.com.ua' }), false);
                
                done();
            });
            
            test('equalsEx method works for falsey values', function (done) {
                assert.strictEqual(reflector.equalsEx(null, null), true, "Equal values should return 'true' from equalsEx method.");
                assert.strictEqual(reflector.equalsEx(undefined, undefined), true, "Equal values should return 'true' from equalsEx method.");
                assert.strictEqual(reflector.equalsEx(null, undefined), false, "Not equal values should return 'false' from equalsEx method.");
                
                done();
            });
            
            test('equalsEx method works for entity values', function (done) {
                var entity1 = reflector.newEntity(typeName1);
                var entity2 = reflector.newEntity(typeName2);
                var entity3 = reflector.newEntity(typeName1);
                
                assert.strictEqual(reflector.equalsEx(entity1, null), false, "The non-empty entity should be not equal to 'null'.");
                assert.strictEqual(reflector.equalsEx(undefined, entity1), false, "'undefined' value should be not equal to non-empty entity.");
                
                assert.strictEqual(reflector.equalsEx(entity1, entity1), true, "The same entity references should be equal.");
                
                assert.strictEqual(reflector.equalsEx(entity1, entity2), false, "Entities with different types should be not-equal.");
                
                done();
            });
            
            /**
             * Creates and registers new generated type with base type defined by 'baseTypeName'. It works through deep copying process of base type's EntityType instance and enhancing its full class name and identifier.
             */
            const createGenTypeFrom = function (baseTypeName, uuid, identifierSuffix) {
                const baseType = reflector.getType(baseTypeName); // take EntityType instance
                const genTypeRaw = JSON.parse(JSON.stringify(baseType)); // deep copy it, loosing EntityType and EntityTypeProp prototypes inside copied structure
                const genTypeName = baseTypeName + '$$TgEntity_' + uuid; // create new full class name
                genTypeRaw.key = genTypeName; // and assign it into raw entity type object
                genTypeRaw._identifier = genTypeName + identifierSuffix; // also assign _identifier for completness
                const genType = reflector.registerEntityType(genTypeRaw); // then register new type using raw object and mutating it into fully fledged EntityType with EntityTypeProps inside
                return genType;
            };
            
            test('equalsEx method works for entity values with generated types', function (done) {
                const baseType = reflector.getType(typeName1);
                const identifierSuffix = ':ua.com.fielden.platform.ui.menu.sample.MiDetailsCentre:';
                
                const entity1 = reflector.newEntity(baseType.fullClassName());
                entity1.key = 'DEMO00';
                
                const genType1 = createGenTypeFrom(baseType.fullClassName(), '75a5512fa9114da6bff0389d4d70f77a', identifierSuffix);
                
                const entity2 = reflector.newEntity(genType1.fullClassName());
                entity2.key = 'DEMO00';
                const entity2Copy = reflector.newEntity(genType1.fullClassName());
                entity2Copy.key = 'DEMO00';
                
                const genType1Copy = createGenTypeFrom(baseType.fullClassName(), '75a5512fa9114da6bff0389d4d70f77a', identifierSuffix);
                
                const entity3 = reflector.newEntity(genType1Copy.fullClassName());
                entity3.key = 'DEMO00';
                
                const genType2 = createGenTypeFrom(baseType.fullClassName(), 'd2ab2cbfa62c478a82405d4241e1cfa8', identifierSuffix);
                
                const entity4 = reflector.newEntity(genType2.fullClassName());
                entity4.key = 'DEMO00';
                
                assert.strictEqual(reflector.equalsEx(entity2, entity2Copy), true, 'Entities with exactly the same type reference should be equal.');
                assert.strictEqual(reflector.equalsEx(entity2, entity3), true, 'Entities with same generated type, but with different references to that type, should be equal.');
                assert.strictEqual(reflector.equalsEx(entity2, entity4), true, 'Entities with different generated types, that are generated from the same base type, should be equal.');
                assert.strictEqual(reflector.equalsEx(entity2, entity1), true, 'entity1 with generated type should be equal to entity2 with the type, that represents a base type for entity1\'s type.');
                
                done();
            });
            
            test('isEntity method works for falsey values', function (done) {
                assert.strictEqual(reflector.isEntity(null), false, "'null' should not be 'is entity'.");
                assert.strictEqual(reflector.isEntity(undefined), false, "'undefined' should not be 'is entity'.");
                
                done();
            });
            
            test('equalsEx method works for entity values with regular keys', function (done) {
                var entity1 = reflector.newEntity(typeName1);
                entity1.key = 'DEMO01';
                var entity2 = reflector.newEntity(typeName1);
                entity2.key = 'DEMO02';
                var entity1copy = reflector.newEntity(typeName1);
                entity1copy.key = 'DEMO01';
                var entityWithoutKey = reflector.newEntity(typeName1);
                
                assert.strictEqual(reflector.equalsEx(entity1, entity1copy), true, "Entities with same keys should be equal.");
                assert.strictEqual(reflector.equalsEx(entity1, entity2), false, "Entities with different keys should be not equal.");
                
                try {
                    reflector.equalsEx(entity1, entityWithoutKey);
                    assert.fail('Second entity should cause failure during comparison, the \'key\' property is not defined.');
                } catch (msg) {
                    console.log(msg);
                }
                
                try {
                    reflector.equalsEx(entityWithoutKey, entity1);
                    assert.fail('First entity should cause failure during comparison, the \'key\' property is not defined.');
                } catch (msg) {
                    console.log(msg);
                }
                
                done();
            });
            
            test('equalsEx method works for entity values with composite keys', function (done) {
                var e1 = reflector.newEntity(typeName1); e1.key = 'DEMO01';
                var e1copy = reflector.newEntity(typeName1); e1copy.key = 'DEMO01';
                
                var entity1 = reflector.newEntity(typeName2);
                entity1.key1 = e1;
                entity1.key2 = 7;
                var entity2 = reflector.newEntity(typeName2);
                entity2.key1 = e1;
                entity2.key2 = 9;
                var entity1copy = reflector.newEntity(typeName2);
                entity1copy.key1 = e1copy;
                entity1copy.key2 = 7;
                var entityWithoutKey = reflector.newEntity(typeName2);
                entityWithoutKey.key2 = 7;
                
                assert.strictEqual(reflector.equalsEx(entity1, entity1copy), true, "Entities with same composite keys should be equal.");
                assert.strictEqual(reflector.equalsEx(entity1, entity2), false, "Entities with different composite keys should be not equal.");
                
                try {
                    reflector.equalsEx(entity1, entityWithoutKey);
                    assert.fail('Second entity should cause failure during comparison, the \'key1\' property is not defined.');
                } catch (msg) {
                    console.log(msg);
                }
                
                try {
                    reflector.equalsEx(entityWithoutKey, entity1);
                    assert.fail('First entity should cause failure during comparison, the \'key1\' property is not defined.');
                } catch (msg) {
                    console.log(msg);
                }
                
                done();
            });
            
            test('equalsEx method works for arrays', function (done) {
                var entity1 = reflector.newEntity(typeName1);
                entity1.key = 'DEMO01';
                var entity2 = reflector.newEntity(typeName1);
                entity2.key = 'DEMO02';
                var entity1copy = reflector.newEntity(typeName1);
                entity1copy.key = 'DEMO01';
                var entityWithoutKey = reflector.newEntity(typeName1);
                
                assert.strictEqual(reflector.equalsEx([], null), false, "Array should not be equal to null.");
                assert.strictEqual(reflector.equalsEx(null, []), false, "Null should not be equal to array.");
                assert.strictEqual(reflector.equalsEx([], undefined), false, "Array should not be equal to null.");
                assert.strictEqual(reflector.equalsEx(undefined, []), false, "Null should not be equal to array.");
                var arr1 = [];
                var arr1copy = [];
                assert.strictEqual(reflector.equalsEx(arr1, arr1), true, "Array should be equal to itself.");
                assert.strictEqual(reflector.equalsEx(arr1, arr1copy), true, "Two empty arrays should be equal.");
                var arr2 = [entity1];
                assert.strictEqual(reflector.equalsEx(arr1, arr2), false, "Non-empty array should not be equal to empty.");
                assert.strictEqual(reflector.equalsEx(arr2, arr1), false, "Non-empty array should not be equal to empty.");
                var arr2copy = [entity1];
                assert.strictEqual(reflector.equalsEx(arr2, arr2copy), true, "Two arrays with the same item should be equal.");
                assert.strictEqual(reflector.equalsEx(arr2copy, arr2), true, "Two arrays with the same item should be equal.");
                var arr2copy2 = [entity1copy];
                assert.strictEqual(reflector.equalsEx(arr2, arr2copy2), true, "Two arrays with the equal item should be equal.");
                assert.strictEqual(reflector.equalsEx(arr2copy2, arr2), true, "Two arrays with the equal item should be equal.");
                var arr3 = [entity2];
                assert.strictEqual(reflector.equalsEx(arr1, arr3), false, "Two arrays with non-equal item should not be equal.");

                done();
            });
            
            test('shouldDisplayDescription method works', function (done) {
                var entity1 = reflector.newEntity(typeName1);
                var entity2 = reflector.newEntity(typeName2);
                
                assert.strictEqual(entity1.type().shouldDisplayDescription(), true, "shouldDisplayDescription for entity type TgPersistentEntityWithProperties should be true.");
                assert.strictEqual(entity2.type().shouldDisplayDescription(), false, "shouldDisplayDescription for entity type TgPersistentCompositeEntity should be false.");
                
                done();
            });
            
            test('empty union entity gives empty values for id, key and desc properties', function (done) {
                const union = reflector.newEntity('ua.com.fielden.platform.sample.domain.UnionEntity');
                union.key = 'bad key'; // should not really exist, but is provided for stronger checks
                union.desc = 'bad desc'; // should not really exist, but is provided for stronger checks
                union.id = 1; // should not really exist, but is provided for stronger checks
                
                union.propertyOne = null;
                union.propertyTwo = null;
                
                assert.strictEqual(union.get('key'), null);
                assert.strictEqual(union.get('desc'), null);
                assert.strictEqual(union.get('id'), null);
                
                done();
            });
            
            test('non-empty union entity gives values for id, key and desc properties from its active entity', function (done) {
                const union = reflector.newEntity('ua.com.fielden.platform.sample.domain.UnionEntity');
                union.key = 'bad key'; // should not really exist, but is provided for stronger checks
                union.desc = 'bad desc'; // should not really exist, but is provided for stronger checks
                union.id = 1; // should not really exist, but is provided for stronger checks
                
                const propertyOneVal = reflector.newEntity('ua.com.fielden.platform.sample.domain.EntityOne');
                propertyOneVal.key = 'EO1';
                propertyOneVal.desc = 'EO1 desc';
                propertyOneVal.id = 101;
                union.propertyOne = propertyOneVal;
                
                union.propertyTwo = null;
                
                assert.strictEqual(union.get('key'), 'EO1');
                assert.strictEqual(union.get('desc'), 'EO1 desc');
                assert.strictEqual(union.get('id'), 101);
                
                done();
            });
            
            test('foramtting: formatting 123.3 decimal with scale and trailing zeros should return 123.3000', function (done) {
                assert.equal(reflector.tg_formatDecimal(123.3, 'en-AU', 4, true), "123.3000");
                done();
            });
            
            test('foramtting: formatting 123.3121 decimal with scale and trailing zeros should return 123.3121', function (done) {
                assert.equal(reflector.tg_formatDecimal(123.3121, 'en-AU', 4, true), "123.3121");
                done();
            });
            
            test('foramtting: formatting 123.3 decimal with scale and without trailing zeros should return 123.3', function (done) {
                assert.equal(reflector.tg_formatDecimal(123.3, 'en-AU', 4, false), "123.3");
                done();
            });
            
            test('foramtting: formatting 123.3121 decimal with scale and without trailing zeros should return 123.3121', function (done) {
                assert.equal(reflector.tg_formatDecimal(123.3121, 'en-AU', 4, false), "123.3121");
                done();
            });
            
            test('foramtting: formatting 123.3 money with scale and trailing zeros should return $123.3000', function (done) {
                assert.equal(reflector.tg_formatMoney({amount: 123.3}, 'en-AU', 4, true), "$123.3000");
                done();
            });
            
            test('foramtting: formatting 123.3121 money with scale and trailing zeros should return $123.3121', function (done) {
                assert.equal(reflector.tg_formatMoney({amount: 123.3121}, 'en-AU', 4, true), "$123.3121");
                done();
            });
            
            test('foramtting: formatting 123.3 money with scale and without trailing zeros should return $123.3', function (done) {
                assert.equal(reflector.tg_formatMoney({amount: 123.3}, 'en-AU', 4, false), "$123.3");
                done();
            });
            
             test('foramtting: formatting 123.3121 decimal with scale and without trailing zeros should return $123.3121', function (done) {
                assert.equal(reflector.tg_formatMoney({amount: 123.3121}, 'en-AU', 4, false), "$123.3121");
                done();
            });
            
            test('foramtting: formatting 123.3 decimal with default scale and trailing zeros should return 123.30', function (done) {
                assert.equal(reflector.tg_formatDecimal(123.3, 'en-AU', undefined, true), "123.30");
                done();
            });
            
            test('foramtting: formatting 123.3121 decimal with default scale and trailing zeros should return 123.31', function (done) {
                assert.equal(reflector.tg_formatDecimal(123.3121, 'en-AU', undefined, true), "123.31");
                done();
            });
            
            test('foramtting: formatting 123.3 decimal with default scale and without trailing zeros should return 123.30', function (done) {
                assert.equal(reflector.tg_formatDecimal(123.3, 'en-AU'), "123.30");
                done();
            });
            
            test('foramtting: formatting 123.3121 decimal with default scale and without trailing zeros should return 123.31', function (done) {
                assert.equal(reflector.tg_formatDecimal(123.3121, 'en-AU'), "123.31");
                done();
            });
            
            test('foramtting: formatting 123.3 money with default scale and trailing zeros should return $123.30', function (done) {
                assert.equal(reflector.tg_formatMoney({amount: 123.3}, 'en-AU', undefined, true), "$123.30");
                done();
            });
            
            test('foramtting: formatting 123.3121 money with default scale and trailing zeros should return $123.31', function (done) {
                assert.equal(reflector.tg_formatMoney({amount: 123.3121}, 'en-AU', undefined, true), "$123.31");
                done();
            });
            
            test('foramtting: formatting 123.3 money with default scale and without trailing zeros should return $123.30', function (done) {
                assert.equal(reflector.tg_formatMoney({amount: 123.3}, 'en-AU'), "$123.30");
                done();
            });
            
            test('foramtting: formatting 123.3121 money with default scale and without trailing zeros should return $123.31', function (done) {
                assert.equal(reflector.tg_formatMoney({amount: 123.3121}, 'en-AU'), "$123.31");
                done();
            });
            
            test('prop retrieving: retrieveing of second level property should work fine', function (done) {
                const entity = reflector.newEntity(typeName1); 
                entity.key = 'DEMO01';
                const compositeEntity = reflector.newEntity(typeName2);
                compositeEntity.key1 = entity;
                compositeEntity.key2 = 7;
                const metaProp = reflector.getEntityTypeProp(compositeEntity, "key1.bigDecimalProp");
                assert.equal(metaProp.precision(), 18);
                assert.equal(metaProp.scale(), 5);
                assert.equal(metaProp.trailingZeros(), true);
                done();
            });
            
            test('prop retrieving: retrieveing of first level property should work fine', function (done) {
                const entity = reflector.newEntity(typeName1); 
                entity.key = 'DEMO01';
                const metaProp = reflector.getEntityTypeProp(entity, "bigDecimalProp");
                assert.equal(metaProp.precision(), 18);
                assert.equal(metaProp.scale(), 5);
                assert.equal(metaProp.trailingZeros(), true);
                done();
            });
            
            test('prop retrieving: retrieveing of empty property should return undefined', function (done) {
                const entity = reflector.newEntity(typeName1); 
                entity.key = 'DEMO01';
                const metaProp = reflector.getEntityTypeProp(entity, "");
                assert.equal(typeof metaProp, 'undefined');
                done();
            });
            
            test('prop retrieving: retrieveing of non exisiting property should return undefined', function (done) {
                const entity = reflector.newEntity(typeName1); 
                entity.key = 'DEMO01';
                const metaProp = reflector.getEntityTypeProp(entity, "nonExisting");
                assert.equal(typeof metaProp, 'undefined');
                done();
            });
        });
    </script>
</body>

</html>