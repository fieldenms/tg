<!doctype html>
<html>

<head>
	<meta charset="UTF-8">
	<title>tg-reflector basic tests</title>
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">
	
	<script src="/resources/polymer/@webcomponents/webcomponentsjs/webcomponents-bundle.js"></script>
    <script src='/resources/polymer/web-animations-js/web-animations-next-lite.min.js'></script>
    <script src="/resources/filesaver/FileSaver.min.js"></script>
    <script src="/resources/polymer/wct-browser-legacy/browser.js"></script>
</head>

<body>
	<tg-reflector id="reflector"></tg-reflector>

    <script type="module">

        import '/app/tg-reflector.js';
        import {CURRENCY_SYMBOL_SPACE} from '/app/tg-reflector.js';
        import '/app/tg-app-config.js'; // this is to trigger setting of LTS, LT and L formats in moment library instance to convert dates properly
        import { _millisDateRepresentation } from '/resources/reflection/tg-date-utils.js';

        suite('reflector\'s', function() {
            let reflector;
            const typeName1 = 'ua.com.fielden.platform.sample.domain.TgPersistentEntityWithProperties';
            const typeName2 = 'ua.com.fielden.platform.sample.domain.TgPersistentCompositeEntity';
            const typeName3 = 'ua.com.fielden.platform.sample.domain.TgBogieLocation';
            const typeName4 = 'ua.com.fielden.platform.sample.domain.TgWorkshop';
            const typeName5 = 'ua.com.fielden.platform.sample.domain.TgWagonSlot';
            const typeName6 = 'ua.com.fielden.platform.sample.domain.TgWagon';
            
            setup(function() {
                reflector = document.querySelector('#reflector');
            });
            
            test('Entity.toString: key converts (empty)', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityStringKey');
                entity.key = null;
                assert.strictEqual(entity.toString(), '[key is not assigned]');
                done();
            });
            
            test('Entity.toString: String key converts', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityStringKey');
                entity.key = 'KEY1';
                assert.strictEqual(entity.toString(), 'KEY1');
                done();
            });
            
            test('Entity.toString: String key converts (empty string)', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityStringKey');
                entity.key = '';
                assert.strictEqual(entity.toString(), '[key is not assigned]');
                done();
            });
            
            test('Entity.toString: boolean key converts (true)', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityBooleanKey');
                entity.key = true;
                assert.strictEqual(entity.toString(), 'true');
                done();
            });
            
            test('Entity.toString: boolean key converts (empty)', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityBooleanKey');
                entity.key = null;
                assert.strictEqual(entity.toString(), 'false');
                done();
            });
            
            test('Entity.toString: boolean key converts (false)', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityBooleanKey');
                entity.key = false;
                assert.strictEqual(entity.toString(), 'false');
                done();
            });
            
            test('Entity.toString: Date key converts', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityDateKey');
                entity.key = 0;
                assert.strictEqual(entity.toString(), _millisDateRepresentation(entity.key, null, null));
                done();
            });
            
            test('Entity.toString: Integer key converts', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityIntegerKey');
                entity.key = 1700;
                assert.strictEqual(entity.toString(), '1700');
                done();
            });
            
            test('Entity.toString: Long key converts', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityLongKey');
                entity.key = 17000000000;
                assert.strictEqual(entity.toString(), '17000000000');
                done();
            });
            
            test('Entity.toString: BigDecimal key converts', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityBigDecimalKey');
                entity.key = 1700.1234;
                assert.strictEqual(entity.toString(), '1700.1234');
                done();
            });
            
            test('Entity.toString: Entity key converts', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityEntityKey');
                entity.key = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityStringKey');
                entity.key.key = 'KEY1';
                assert.strictEqual(entity.toString(), 'KEY1');
                done();
            });
            // (Money keys are not supported as part of Hibernate configuration; Colour and Hyperlink are not Comparable and thus not suitable for key definition too.)
            
            test('tg_convert simple entity: key converts (empty)', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityStringKey');
                entity.key = null;
                assert.strictEqual(reflector.tg_convert(entity), '[key is not assigned]');
                done();
            });
            
            test('tg_convert simple entity: String key converts', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityStringKey');
                entity.key = 'KEY1';
                assert.strictEqual(reflector.tg_convert(entity), 'KEY1');
                done();
            });
            
            test('tg_convert simple entity: String key converts (empty string)', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityStringKey');
                entity.key = '';
                assert.strictEqual(reflector.tg_convert(entity), '[key is not assigned]');
                done();
            });
            
            test('tg_convert simple entity: boolean key converts (true)', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityBooleanKey');
                entity.key = true;
                assert.strictEqual(reflector.tg_convert(entity), 'true');
                done();
            });
            
            test('tg_convert simple entity: boolean key converts (empty)', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityBooleanKey');
                entity.key = null;
                assert.strictEqual(reflector.tg_convert(entity), 'false');
                done();
            });
            
            test('tg_convert simple entity: boolean key converts (false)', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityBooleanKey');
                entity.key = false;
                assert.strictEqual(reflector.tg_convert(entity), 'false');
                done();
            });
            
            test('tg_convert simple entity: Date key converts', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityDateKey');
                entity.key = 0;
                assert.strictEqual(reflector.tg_convert(entity), _millisDateRepresentation(entity.key, null, null));
                done();
            });
            
            test('tg_convert simple entity: Integer key converts', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityIntegerKey');
                entity.key = 1700;
                assert.strictEqual(reflector.tg_convert(entity), '1700');
                done();
            });
            
            test('tg_convert simple entity: Long key converts', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityLongKey');
                entity.key = 17000000000;
                assert.strictEqual(reflector.tg_convert(entity), '17000000000');
                done();
            });
            
            test('tg_convert simple entity: BigDecimal key converts', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityBigDecimalKey');
                entity.key = 1700.1234;
                assert.strictEqual(reflector.tg_convert(entity), '1700.1234');
                done();
            });
            
            test('tg_convert simple entity: Entity key converts', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityEntityKey');
                entity.key = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityStringKey');
                entity.key.key = 'KEY1';
                assert.strictEqual(reflector.tg_convert(entity), 'KEY1');
                done();
            });
            // (Money keys are not supported as part of Hibernate configuration; Colour and Hyperlink are not Comparable and thus not suitable for key definition too.)
            
            test('tg_convert composite entity: key converts (empty)', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityCompositeKey');
                entity.stringKey = null;
                entity.dateKey = null;
                entity.integerKey = null;
                entity.longKey = null;
                entity.bigDecimalKey = null;
                entity.moneyKey = null;
                entity.colourKey = null;
                entity.hyperlinkKey = null;
                entity.entityKey = null;
                entity.selfKey = null;
                assert.strictEqual(reflector.tg_convert(entity), '[key is not assigned]');
                done();
            });
            
            test('tg_convert composite entity: String key converts', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityCompositeKey');
                entity.stringKey = 'KEY1';
                entity.dateKey = null;
                entity.integerKey = null;
                entity.longKey = null;
                entity.bigDecimalKey = null;
                entity.moneyKey = null;
                entity.colourKey = null;
                entity.hyperlinkKey = null;
                entity.entityKey = null;
                entity.selfKey = null;
                assert.strictEqual(reflector.tg_convert(entity), 'KEY1');
                done();
            });
            
            test('tg_convert composite entity: String key converts (empty string)', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityCompositeKey');
                entity.stringKey = '';
                entity.dateKey = null;
                entity.integerKey = null;
                entity.longKey = null;
                entity.bigDecimalKey = null;
                entity.moneyKey = null;
                entity.colourKey = null;
                entity.hyperlinkKey = null;
                entity.entityKey = null;
                entity.selfKey = null;
                assert.strictEqual(reflector.tg_convert(entity), '[key is not assigned]');
                done();
            });
            
            test('tg_convert composite entity: boolean key converts (true)', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityCompositeBooleanKey');
                entity.booleanKey = true;
                assert.strictEqual(reflector.tg_convert(entity), 'true');
                done();
            });
            
            test('tg_convert composite entity: boolean key converts (empty)', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityCompositeBooleanKey');
                entity.booleanKey = null;
                assert.strictEqual(reflector.tg_convert(entity), 'false');
                done();
            });
            
            test('tg_convert composite entity: boolean key converts (false)', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityCompositeBooleanKey');
                entity.booleanKey = false;
                assert.strictEqual(reflector.tg_convert(entity), 'false');
                done();
            });
            
            test('tg_convert composite entity: Date key converts', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityCompositeKey');
                entity.stringKey = null;
                entity.dateKey = 0;
                entity.integerKey = null;
                entity.longKey = null;
                entity.bigDecimalKey = null;
                entity.moneyKey = null;
                entity.colourKey = null;
                entity.hyperlinkKey = null;
                entity.entityKey = null;
                entity.selfKey = null;
                assert.strictEqual(reflector.tg_convert(entity), _millisDateRepresentation(entity.dateKey, null, null));
                done();
            });
            
            test('tg_convert composite entity: Integer key converts', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityCompositeKey');
                entity.stringKey = null;
                entity.dateKey = null;
                entity.integerKey = 1700;
                entity.longKey = null;
                entity.bigDecimalKey = null;
                entity.moneyKey = null;
                entity.colourKey = null;
                entity.hyperlinkKey = null;
                entity.entityKey = null;
                entity.selfKey = null;
                assert.strictEqual(reflector.tg_convert(entity), '1700');
                done();
            });
            
            test('tg_convert composite entity: Long key converts', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityCompositeKey');
                entity.stringKey = null;
                entity.dateKey = null;
                entity.integerKey = null;
                entity.longKey = 17000000000;
                entity.bigDecimalKey = null;
                entity.moneyKey = null;
                entity.colourKey = null;
                entity.hyperlinkKey = null;
                entity.entityKey = null;
                entity.selfKey = null;
                assert.strictEqual(reflector.tg_convert(entity), '17000000000');
                done();
            });
            
            test('tg_convert composite entity: BigDecimal key converts', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityCompositeKey');
                entity.stringKey = null;
                entity.dateKey = null;
                entity.integerKey = null;
                entity.longKey = null;
                entity.bigDecimalKey = 1700.1234;
                entity.moneyKey = null;
                entity.colourKey = null;
                entity.hyperlinkKey = null;
                entity.entityKey = null;
                entity.selfKey = null;
                assert.strictEqual(reflector.tg_convert(entity), '1700.1234');
                done();
            });
            
            test('tg_convert composite entity: Entity key converts', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityCompositeKey');
                entity.stringKey = null;
                entity.dateKey = null;
                entity.integerKey = null;
                entity.longKey = null;
                entity.bigDecimalKey = null;
                entity.moneyKey = null;
                entity.colourKey = null;
                entity.hyperlinkKey = null;
                entity.entityKey = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityStringKey');
                entity.entityKey.key = 'KEY1';
                entity.selfKey = null;
                assert.strictEqual(reflector.tg_convert(entity), 'KEY1');
                done();
            });
            
            test('tg_convert composite entity: Money key converts', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityCompositeKey');
                entity.stringKey = null;
                entity.dateKey = null;
                entity.integerKey = null;
                entity.longKey = null;
                entity.bigDecimalKey = null;
                entity.moneyKey = { amount: 1700, currency: 'AUD', taxPercent: null };
                entity.colourKey = null;
                entity.hyperlinkKey = null;
                entity.entityKey = null;
                entity.selfKey = null;
                assert.strictEqual(reflector.tg_convert(entity), '1700');
                done();
            });
            
            test('tg_convert composite entity: Colour key converts', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityCompositeKey');
                entity.stringKey = null;
                entity.dateKey = null;
                entity.integerKey = null;
                entity.longKey = null;
                entity.bigDecimalKey = null;
                entity.moneyKey = null;
                entity.colourKey = { hashlessUppercasedColourValue: 'FFCC80' };
                entity.hyperlinkKey = null;
                entity.entityKey = null;
                entity.selfKey = null;
                assert.strictEqual(reflector.tg_convert(entity), 'FFCC80');
                done();
            });
            
            test('tg_convert composite entity: Hyperlink key converts', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityCompositeKey');
                entity.stringKey = null;
                entity.dateKey = null;
                entity.integerKey = null;
                entity.longKey = null;
                entity.bigDecimalKey = null;
                entity.moneyKey = null;
                entity.colourKey = null;
                entity.hyperlinkKey = { value: 'https://www.example.com' };
                entity.entityKey = null;
                entity.selfKey = null;
                assert.strictEqual(reflector.tg_convert(entity), 'https://www.example.com');
                done();
            });
            
            test('tg_convert composite entity: custom separator is used and order of keys is correct', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityCompositeKey');
                entity.stringKey = 'KEY1';
                entity.dateKey = 0;
                entity.integerKey = 1500;
                entity.longKey = 16000000000;
                entity.bigDecimalKey = 1700.1234;
                entity.moneyKey = { amount: 1700, currency: 'AUD', taxPercent: null };
                entity.colourKey = { hashlessUppercasedColourValue: 'FFCC80' };
                entity.hyperlinkKey = { value: 'https://www.example.com' };
                entity.entityKey = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityStringKey');
                entity.entityKey.key = 'KEY2';
                entity.selfKey = null;
                assert.strictEqual(reflector.tg_convert(entity), 'KEY1:' + _millisDateRepresentation(entity.dateKey, null, null) + ':1500:16000000000:1700.1234:1700:FFCC80:https://www.example.com:KEY2');
                done();
            });
            
            test('tg_convert composite entity: empty values are skipped regardless of their types', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityCompositeKey');
                entity.stringKey = 'KEY1';
                entity.dateKey = 0;
                entity.integerKey = null;
                entity.longKey = 16000000000;
                entity.bigDecimalKey = null;
                entity.moneyKey = null;
                entity.colourKey = { hashlessUppercasedColourValue: 'FFCC80' };
                entity.hyperlinkKey = null;
                entity.entityKey = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityStringKey');
                entity.entityKey.key = 'KEY2';
                entity.selfKey = null;
                assert.strictEqual(reflector.tg_convert(entity), 'KEY1:' + _millisDateRepresentation(entity.dateKey, null, null) + ':16000000000:FFCC80:KEY2');
                done();
            });
            
            const typeName7 = 'ua.com.fielden.platform.sample.domain.TgEntityCompositeKey';
            const typeName8 = 'ua.com.fielden.platform.sample.domain.TgEntityCompositeBooleanKey';
            const typeName9 = 'ua.com.fielden.platform.sample.domain.TgEntityStringKey';
            const typeName10 = 'ua.com.fielden.platform.sample.domain.TgEntityTwoEntityKeys';
            
            test('EntityTypeProp.type: boolean prop type is defined', function (done) {
                assert.strictEqual(reflector.getType(typeName8).prop('booleanKey').type(), 'boolean');
                done();
            });
            
            test('EntityTypeProp.type: String prop type is defined', function (done) {
                assert.strictEqual(reflector.getType(typeName7).prop('stringKey').type(), 'String');
                done();
            });
            
            test('EntityTypeProp.type: Date prop type is defined', function (done) {
                assert.strictEqual(reflector.getType(typeName7).prop('dateKey').type(), 'Date');
                done();
            });
            
            test('EntityTypeProp.type: Integer prop type is defined', function (done) {
                assert.strictEqual(reflector.getType(typeName7).prop('integerKey').type(), 'Integer');
                done();
            });
            
            test('EntityTypeProp.type: Long prop type is defined', function (done) {
                assert.strictEqual(reflector.getType(typeName7).prop('longKey').type(), 'Long');
                done();
            });
            
            test('EntityTypeProp.type: BigDecimal prop type is defined', function (done) {
                assert.strictEqual(reflector.getType(typeName7).prop('bigDecimalKey').type(), 'BigDecimal');
                done();
            });
            
            test('EntityTypeProp.type: Money prop type is defined', function (done) {
                assert.strictEqual(reflector.getType(typeName7).prop('moneyKey').type(), 'Money');
                done();
            });
            
            test('EntityTypeProp.type: collection prop type is not defined', function (done) {
                assert.strictEqual(reflector.getType(typeName7).prop('listOfStringsProp').type(), null);
                assert.strictEqual(reflector.getType(typeName7).prop('setOfEntitiesProp').type(), null);
                done();
            });
            
            test('EntityTypeProp.type: Colour prop type is defined', function (done) {
                assert.strictEqual(reflector.getType(typeName7).prop('colourKey').type(), 'Colour');
                done();
            });
            
            test('EntityTypeProp.type: Hyperlink prop type is defined', function (done) {
                assert.strictEqual(reflector.getType(typeName7).prop('hyperlinkKey').type(), 'Hyperlink');
                done();
            });
            
            test('EntityTypeProp.type: entity prop type is defined', function (done) {
                assert.strictEqual(reflector.getType(typeName7).prop('entityKey').type(), reflector.getType(typeName9));
                done();
            });
            
            test('EntityTypeProp.shortCollectionKey: collection of raw values is not short-collectional and does not have shortCollectionKey', function (done) {
                assert.strictEqual(reflector.getType(typeName7).prop('listOfStringsProp').shortCollectionKey(), null);
                done();
            });
            
            test('EntityTypeProp.shortCollectionKey: collection of entities is not is not always short-collectional and in that case does not have shortCollectionKey', function (done) {
                assert.strictEqual(reflector.getType(typeName7).prop('setOfEntitiesProp').shortCollectionKey(), null);
                done();
            });
            
            test('EntityTypeProp.shortCollectionKey: short-collection does have shortCollectionKey', function (done) {
                assert.strictEqual(reflector.getType(typeName7).prop('shortCollectionalProp').shortCollectionKey(), 'entityKey');
                done();
            });
            
            test('EntityType.prop: two-level dot-notated property is defined (String)', function (done) {
                assert.strictEqual(reflector.getType(typeName10).prop('entityKey.key'), reflector.getType(typeName9).prop('key'));
                done();
            });
            
            test('EntityType.prop: two-level dot-notated property is defined (Date)', function (done) {
                assert.strictEqual(reflector.getType(typeName10).prop('parentKey.dateKey'), reflector.getType(typeName7).prop('dateKey'));
                done();
            });
            
            test('EntityType.prop: three-level dot-notated property is defined', function (done) {
                assert.strictEqual(reflector.getType(typeName10).prop('parentKey.entityKey.key'), reflector.getType(typeName9).prop('key'));
                done();
            });
            
            test('EntityType.prop: union property is defined', function (done) {
                assert.exists(reflector.getType('ua.com.fielden.platform.sample.domain.TgUnionHolder').prop('union'));
                done();
            });
            
            test('EntityType.prop: union\'s common property is defined', function (done) {
                assert.exists(reflector.getType('ua.com.fielden.platform.sample.domain.TgUnionHolder').prop('union.common'));
                done();
            });
            
            test('EntityType.prop: union\'s common property defines meta-information as it is in first declared union type', function (done) {
                assert.strictEqual(reflector.getType('ua.com.fielden.platform.sample.domain.TgUnionHolder').prop('union.common').title(), 'Common Property (from TgUnionType1)');
                done();
            });
            
            test('EntityType.prop: union\'s common subproperty is defined', function (done) {
                assert.exists(reflector.getType('ua.com.fielden.platform.sample.domain.TgUnionHolder').prop('union.common.desc'));
                done();
            });

            test('EntityType.prop: title / desc of key prop of composite entity type without @KeyTitle are defined, but empty', function (done) {
                assert.strictEqual(reflector.getType(typeName7).prop('key').title(), '');
                assert.strictEqual(reflector.getType(typeName7).prop('key').desc(), '');
                done();
            });

            test('EntityType.prop: title / desc of key prop of composite entity type with @KeyTitle are as in @KeyTitle definition', function (done) {
                assert.strictEqual(reflector.getType(typeName8).prop('key').title(), 'Entity With Composite Boolean Key');
                assert.strictEqual(reflector.getType(typeName8).prop('key').desc(), 'Represents an entity with single composite key of type Boolean.');
                done();
            });
            
            test('tg_determinePropertyType: boolean prop type is defined', function (done) {
                assert.strictEqual(reflector.tg_determinePropertyType(reflector.getType(typeName8), 'booleanKey'), 'boolean');
                done();
            });
            
            test('tg_determinePropertyType: String prop type is defined', function (done) {
                assert.strictEqual(reflector.tg_determinePropertyType(reflector.getType(typeName7), 'stringKey'), 'String');
                done();
            });
            
            test('tg_determinePropertyType: Date prop type is defined', function (done) {
                assert.strictEqual(reflector.tg_determinePropertyType(reflector.getType(typeName7), 'dateKey'), 'Date');
                done();
            });
            
            test('tg_determinePropertyType: Integer prop type is defined', function (done) {
                assert.strictEqual(reflector.tg_determinePropertyType(reflector.getType(typeName7), 'integerKey'), 'Integer');
                done();
            });
            
            test('tg_determinePropertyType: Long prop type is defined', function (done) {
                assert.strictEqual(reflector.tg_determinePropertyType(reflector.getType(typeName7), 'longKey'), 'Long');
                done();
            });
            
            test('tg_determinePropertyType: BigDecimal prop type is defined', function (done) {
                assert.strictEqual(reflector.tg_determinePropertyType(reflector.getType(typeName7), 'bigDecimalKey'), 'BigDecimal');
                done();
            });
            
            test('tg_determinePropertyType: Money prop type is defined', function (done) {
                assert.strictEqual(reflector.tg_determinePropertyType(reflector.getType(typeName7), 'moneyKey'), 'Money');
                done();
            });
            
            test('tg_determinePropertyType: collection prop type is not defined', function (done) {
                assert.strictEqual(reflector.tg_determinePropertyType(reflector.getType(typeName7), 'listOfStringsProp'), null);
                assert.strictEqual(reflector.tg_determinePropertyType(reflector.getType(typeName7), 'setOfEntitiesProp'), null);
                done();
            });
            
            test('tg_determinePropertyType: Colour prop type is defined', function (done) {
                assert.strictEqual(reflector.tg_determinePropertyType(reflector.getType(typeName7), 'colourKey'), 'Colour');
                done();
            });
            
            test('tg_determinePropertyType: Hyperlink prop type is defined', function (done) {
                assert.strictEqual(reflector.tg_determinePropertyType(reflector.getType(typeName7), 'hyperlinkKey'), 'Hyperlink');
                done();
            });
            
            test('tg_determinePropertyType: entity prop type is defined', function (done) {
                assert.strictEqual(reflector.tg_determinePropertyType(reflector.getType(typeName7), 'entityKey'), reflector.getType(typeName9));
                done();
            });
            
            test('tg_determinePropertyType: entity-itself prop type is defined', function (done) {
                assert.strictEqual(reflector.tg_determinePropertyType(reflector.getType(typeName7), ''), reflector.getType(typeName7));
                done();
            });
            
            test('tg_determinePropertyType: key prop type of composite entity type is defined', function (done) {
                assert.strictEqual(reflector.tg_determinePropertyType(reflector.getType(typeName7), 'key'), 'DynamicEntityKey');
                done();
            });
            
            test('tg_determinePropertyType: two-level dot-notated prop type is defined (String)', function (done) {
                assert.strictEqual(reflector.tg_determinePropertyType(reflector.getType(typeName10), 'entityKey.key'), 'String');
                done();
            });
            
            test('tg_determinePropertyType: two-level dot-notated prop type is defined (Date)', function (done) {
                assert.strictEqual(reflector.tg_determinePropertyType(reflector.getType(typeName10), 'parentKey.dateKey'), 'Date');
                done();
            });
            
            test('tg_determinePropertyType: two-level dot-notated prop type is defined (DynamicEntityKey)', function (done) {
                assert.strictEqual(reflector.tg_determinePropertyType(reflector.getType(typeName10), 'parentKey.key'), 'DynamicEntityKey');
                done();
            });
            
            test('tg_determinePropertyType: three-level dot-notated prop type is defined', function (done) {
                assert.strictEqual(reflector.tg_determinePropertyType(reflector.getType(typeName10), 'parentKey.entityKey.key'), 'String');
                done();
            });
            
            test('tg_determinePropertyType: union property type is defined', function (done) {
                assert.strictEqual(reflector.tg_determinePropertyType(reflector.getType('ua.com.fielden.platform.sample.domain.TgUnionHolder'), 'union'), reflector.getType('ua.com.fielden.platform.sample.domain.TgUnion'));
                done();
            });
            
            test('tg_determinePropertyType: union\'s common property type is defined', function (done) {
                assert.strictEqual(reflector.tg_determinePropertyType(reflector.getType('ua.com.fielden.platform.sample.domain.TgUnionHolder'), 'union.common'), reflector.getType('ua.com.fielden.platform.sample.domain.TgUnionCommonType'));
                done();
            });
            
            test('tg_determinePropertyType: union\'s common key property type is defined', function (done) {
                assert.strictEqual(reflector.tg_determinePropertyType(reflector.getType('ua.com.fielden.platform.sample.domain.TgUnionHolder'), 'union.key'), 'String');
                done();
            });
            
            test('tg_determinePropertyType: union\'s common subproperty is defined', function (done) {
                assert.strictEqual(reflector.tg_determinePropertyType(reflector.getType('ua.com.fielden.platform.sample.domain.TgUnionHolder'), 'union.common.desc'), 'String');
                done();
            });
            
            test('tg_toString: dot-notated composite entity-typed prop', function (done) {
                const parentEntity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityEntityKey');
                parentEntity.compositeProp = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityTwoEntityKeys');
                parentEntity.compositeProp.parentKey = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityCompositeKey');
                parentEntity.compositeProp.parentKey.stringKey = 'KEY1';
                parentEntity.compositeProp.parentKey.dateKey = null;
                parentEntity.compositeProp.parentKey.integerKey = null;
                parentEntity.compositeProp.parentKey.longKey = null;
                parentEntity.compositeProp.parentKey.bigDecimalKey = null;
                parentEntity.compositeProp.parentKey.moneyKey = null;
                parentEntity.compositeProp.parentKey.colourKey = null;
                parentEntity.compositeProp.parentKey.hyperlinkKey = null;
                parentEntity.compositeProp.parentKey.entityKey = null;
                parentEntity.compositeProp.parentKey.selfKey = null;
                assert.strictEqual(reflector.tg_toString(parentEntity.get('compositeProp.parentKey'), parentEntity.type(), 'compositeProp.parentKey'), 'KEY1');
                done();
            });
            
            test('tg_toString: dot-notated composite entity-typed prop and accessing its key', function (done) {
                const parentEntity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityEntityKey');
                parentEntity.compositeProp = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityTwoEntityKeys');
                parentEntity.compositeProp.parentKey = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityCompositeKey');
                parentEntity.compositeProp.parentKey.stringKey = 'KEY1';
                parentEntity.compositeProp.parentKey.dateKey = null;
                parentEntity.compositeProp.parentKey.integerKey = null;
                parentEntity.compositeProp.parentKey.longKey = null;
                parentEntity.compositeProp.parentKey.bigDecimalKey = null;
                parentEntity.compositeProp.parentKey.moneyKey = null;
                parentEntity.compositeProp.parentKey.colourKey = null;
                parentEntity.compositeProp.parentKey.hyperlinkKey = null;
                parentEntity.compositeProp.parentKey.entityKey = null;
                parentEntity.compositeProp.parentKey.selfKey = null;
                assert.strictEqual(reflector.tg_toString(parentEntity.get('compositeProp.parentKey.key'), parentEntity.type(), 'compositeProp.parentKey.key'), 'KEY1');
                done();
            });
            
            test('tg_toString standard: empty (null) converts', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityCompositeKey');
                entity.stringKey = null;
                assert.strictEqual(reflector.tg_toString(entity.get('stringKey'), entity.type(), 'stringKey'), '');
                entity.dateKey = null;
                assert.strictEqual(reflector.tg_toString(entity.get('dateKey'), entity.type(), 'dateKey'), '');
                entity.integerKey = null;
                assert.strictEqual(reflector.tg_toString(entity.get('integerKey'), entity.type(), 'integerKey'), '');
                entity.longKey = null;
                assert.strictEqual(reflector.tg_toString(entity.get('longKey'), entity.type(), 'longKey'), '');
                entity.bigDecimalKey = null;
                assert.strictEqual(reflector.tg_toString(entity.get('bigDecimalKey'), entity.type(), 'bigDecimalKey'), '');
                entity.moneyKey = null;
                assert.strictEqual(reflector.tg_toString(entity.get('moneyKey'), entity.type(), 'moneyKey'), '');
                entity.colourKey = null;
                assert.strictEqual(reflector.tg_toString(entity.get('colourKey'), entity.type(), 'colourKey'), '');
                entity.hyperlinkKey = null;
                assert.strictEqual(reflector.tg_toString(entity.get('hyperlinkKey'), entity.type(), 'hyperlinkKey'), '');
                entity.entityKey = null;
                assert.strictEqual(reflector.tg_toString(entity.get('entityKey'), entity.type(), 'entityKey'), '');
                entity.listOfStringsProp = null;
                assert.strictEqual(reflector.tg_toString(entity.get('listOfStringsProp'), entity.type(), 'listOfStringsProp'), '');
                entity.setOfEntitiesProp = null;
                assert.strictEqual(reflector.tg_toString(entity.get('setOfEntitiesProp'), entity.type(), 'setOfEntitiesProp'), '');
                entity.shortCollectionalProp = null;
                assert.strictEqual(reflector.tg_toString(entity.get('shortCollectionalProp'), entity.type(), 'shortCollectionalProp'), '');
                done();
            });
            
            test('tg_toString standard: String converts', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityCompositeKey');
                entity.stringKey = 'KEY1';
                assert.strictEqual(reflector.tg_toString(entity.get('stringKey'), entity.type(), 'stringKey'), 'KEY1');
                done();
            });
            
            test('tg_toString standard: String converts (empty string)', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityCompositeKey');
                entity.stringKey = '';
                assert.strictEqual(reflector.tg_toString(entity.get('stringKey'), entity.type(), 'stringKey'), '');
                done();
            });
            
            test('tg_toString standard: boolean converts (true)', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityCompositeBooleanKey');
                entity.booleanKey = true;
                assert.strictEqual(reflector.tg_toString(entity.get('booleanKey'), entity.type(), 'booleanKey'), 'true');
                done();
            });
            
            test('tg_toString standard: boolean converts (empty)', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityCompositeBooleanKey');
                entity.booleanKey = null;
                assert.strictEqual(reflector.tg_toString(entity.get('booleanKey'), entity.type(), 'booleanKey'), 'false');
                done();
            });
            
            test('tg_toString standard: boolean converts (false)', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityCompositeBooleanKey');
                entity.booleanKey = false;
                assert.strictEqual(reflector.tg_toString(entity.get('booleanKey'), entity.type(), 'booleanKey'), 'false');
                done();
            });
            
            test('tg_toString standard: Date converts', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityCompositeKey');
                entity.dateKey = 0;
                assert.strictEqual(reflector.tg_toString(entity.get('dateKey'), entity.type(), 'dateKey'), _millisDateRepresentation(entity.dateKey, null, null));
                done();
            });
            
            test('tg_toString standard: Integer converts', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityCompositeKey');
                entity.integerKey = 1700;
                assert.strictEqual(reflector.tg_toString(entity.get('integerKey'), entity.type(), 'integerKey'), '1700');
                done();
            });
            
            test('tg_toString standard: Long converts', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityCompositeKey');
                entity.longKey = 17000000000;
                assert.strictEqual(reflector.tg_toString(entity.get('longKey'), entity.type(), 'longKey'), '17000000000');
                done();
            });
            
            test('tg_toString standard: BigDecimal converts', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityCompositeKey');
                entity.bigDecimalKey = 1700.1234;
                assert.strictEqual(reflector.tg_toString(entity.get('bigDecimalKey'), entity.type(), 'bigDecimalKey'), '1700.1234');
                done();
            });
            
            test('tg_toString standard: Entity converts', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityCompositeKey');
                entity.entityKey = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityStringKey');
                entity.entityKey.key = 'KEY1';
                assert.strictEqual(reflector.tg_toString(entity.get('entityKey'), entity.type(), 'entityKey'), 'KEY1');
                done();
            });
            
            test('tg_toString standard: Money converts', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityCompositeKey');
                entity.moneyKey = { amount: 1700, currency: 'AUD', taxPercent: null };
                assert.strictEqual(reflector.tg_toString(entity.get('moneyKey'), entity.type(), 'moneyKey'), '1700');
                done();
            });
            
            test('tg_toString standard: empty collection converts', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityCompositeKey');
                entity.listOfStringsProp = [];
                assert.strictEqual(reflector.tg_toString(entity.get('listOfStringsProp'), entity.type(), 'listOfStringsProp'), '');
                entity.setOfEntitiesProp = [];
                assert.strictEqual(reflector.tg_toString(entity.get('setOfEntitiesProp'), entity.type(), 'setOfEntitiesProp'), '');
                entity.shortCollectionalProp = [];
                assert.strictEqual(reflector.tg_toString(entity.get('shortCollectionalProp'), entity.type(), 'shortCollectionalProp'), '');
                done();
            });
            
            test('tg_toString standard: list of strings converts', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityCompositeKey');
                entity.listOfStringsProp = ['str1', '', 'str2', null, 'str3', null];
                assert.strictEqual(reflector.tg_toString(entity.get('listOfStringsProp'), entity.type(), 'listOfStringsProp'), 'str1, str2, str3');
                done();
            });
            
            test('tg_toString standard: long collection converts', function (done) {
                const master = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityCompositeKey');
                master.stringKey = 'MASTER';
                master.dateKey = null;
                master.integerKey = null;
                master.longKey = null;
                master.bigDecimalKey = null;
                master.moneyKey = null;
                master.colourKey = null;
                master.hyperlinkKey = null;
                master.entityKey = null;
                master.selfKey = null;
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityCompositeKey');
                entity.stringKey = 'STR1';
                entity.dateKey = null;
                entity.integerKey = null;
                entity.longKey = null;
                entity.bigDecimalKey = null;
                entity.moneyKey = null;
                entity.colourKey = null;
                entity.hyperlinkKey = null;
                entity.entityKey = null;
                entity.selfKey = master;
                master.setOfEntitiesProp = [entity, null, entity, null, entity, null];
                assert.strictEqual(reflector.tg_toString(master.get('setOfEntitiesProp'), master.type(), 'setOfEntitiesProp'), 'STR1:MASTER, STR1:MASTER, STR1:MASTER');
                done();
            });
            
            test('tg_toString standard: short collection converts', function (done) {
                const master = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityCompositeKey');
                master.stringKey = 'MASTER';
                master.dateKey = null;
                master.integerKey = null;
                master.longKey = null;
                master.bigDecimalKey = null;
                master.moneyKey = null;
                master.colourKey = null;
                master.hyperlinkKey = null;
                master.entityKey = null;
                master.selfKey = null;
                const entity1 = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityTwoEntityKeys');
                entity1.parentKey = master;
                entity1.entityKey = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityStringKey');
                entity1.entityKey.key = 'STR1';
                const entity2 = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityTwoEntityKeys');
                entity2.parentKey = master;
                entity2.entityKey = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityStringKey');
                entity2.entityKey.key = 'STR2';
                const entity3 = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityTwoEntityKeys');
                entity3.parentKey = master;
                entity3.entityKey = null;
                master.shortCollectionalProp = [entity1, null, entity2, null, entity3, null];
                assert.strictEqual(reflector.tg_toString(master.get('shortCollectionalProp'), master.type(), 'shortCollectionalProp'), 'STR1, STR2');
                done();
            });
            
            test('tg_toString standard: Colour converts', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityCompositeKey');
                entity.colourKey = { hashlessUppercasedColourValue: 'FFCC80' };
                assert.strictEqual(reflector.tg_toString(entity.get('colourKey'), entity.type(), 'colourKey'), 'FFCC80');
                done();
            });
            
            test('tg_toString standard: Hyperlink converts', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityCompositeKey');
                entity.hyperlinkKey = { value: 'https://www.example.com' };
                assert.strictEqual(reflector.tg_toString(entity.get('hyperlinkKey'), entity.type(), 'hyperlinkKey'), 'https://www.example.com');
                done();
            });
            
            test('tg_toString standard: union converts', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgUnionHolder');

                const union = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgUnion');
                const union1Val = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgUnionType1');
                union1Val.key = 'U1';
                union.union1 = union1Val;
                union.union2 = null;

                entity.union = union;
                assert.strictEqual(reflector.tg_toString(entity.get('union'), entity.type(), 'union'), 'U1');
                
                done();
            });
            
            test('tg_toString standard: union\'s common property converts', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgUnionHolder');
                
                const union = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgUnion');
                const union1Val = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgUnionType1');
                union1Val.key = 'U1';
                const union1CommonVal = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgUnionCommonType');
                union1CommonVal.key = 'common val';
                union1Val.common = union1CommonVal;
                union.union1 = union1Val;
                union.union2 = null;
                
                entity.union = union;
                assert.strictEqual(reflector.tg_toString(entity.get('union.common'), entity.type(), 'union.common'), 'common val');
                
                done();
            });
            
            test('tg_toString standard: union\'s common key property converts', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgUnionHolder');
                
                const union = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgUnion');
                const union1Val = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgUnionType1');
                union1Val.key = 'U1';
                union.union1 = union1Val;
                union.union2 = null;
                
                entity.union = union;
                assert.strictEqual(reflector.tg_toString(entity.get('union.key'), entity.type(), 'union.key'), 'U1');
                
                done();
            });
            
            test('tg_toString standard: union\'s common subproperty converts', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgUnionHolder');
                
                const union = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgUnion');
                const union1Val = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgUnionType1');
                union1Val.key = 'U1';
                const union1CommonVal = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgUnionCommonType');
                union1CommonVal.key = 'common val';
                union1CommonVal.desc = 'common val description';
                union1Val.common = union1CommonVal;
                union.union1 = union1Val;
                union.union2 = null;
                
                entity.union = union;
                assert.strictEqual(reflector.tg_toString(entity.get('union.common.desc'), entity.type(), 'union.common.desc'), 'common val description');
                
                done();
            });
            
            test('tg_toString for display: empty (null) converts', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityCompositeKey');
                entity.stringKey = null;
                assert.strictEqual(reflector.tg_toString(entity.get('stringKey'), entity.type(), 'stringKey', { display: true }), '');
                entity.dateKey = null;
                assert.strictEqual(reflector.tg_toString(entity.get('dateKey'), entity.type(), 'dateKey', { display: true }), '');
                entity.integerKey = null;
                assert.strictEqual(reflector.tg_toString(entity.get('integerKey'), entity.type(), 'integerKey', { display: true }), '');
                entity.longKey = null;
                assert.strictEqual(reflector.tg_toString(entity.get('longKey'), entity.type(), 'longKey', { display: true }), '');
                entity.bigDecimalKey = null;
                assert.strictEqual(reflector.tg_toString(entity.get('bigDecimalKey'), entity.type(), 'bigDecimalKey', { display: true }), '');
                entity.moneyKey = null;
                assert.strictEqual(reflector.tg_toString(entity.get('moneyKey'), entity.type(), 'moneyKey', { display: true }), '');
                entity.colourKey = null;
                assert.strictEqual(reflector.tg_toString(entity.get('colourKey'), entity.type(), 'colourKey', { display: true }), '');
                entity.hyperlinkKey = null;
                assert.strictEqual(reflector.tg_toString(entity.get('hyperlinkKey'), entity.type(), 'hyperlinkKey', { display: true }), '');
                entity.entityKey = null;
                assert.strictEqual(reflector.tg_toString(entity.get('entityKey'), entity.type(), 'entityKey', { display: true }), '');
                entity.listOfStringsProp = null;
                assert.strictEqual(reflector.tg_toString(entity.get('listOfStringsProp'), entity.type(), 'listOfStringsProp', { display: true }), '');
                entity.setOfEntitiesProp = null;
                assert.strictEqual(reflector.tg_toString(entity.get('setOfEntitiesProp'), entity.type(), 'setOfEntitiesProp', { display: true }), '');
                entity.shortCollectionalProp = null;
                assert.strictEqual(reflector.tg_toString(entity.get('shortCollectionalProp'), entity.type(), 'shortCollectionalProp', { display: true }), '');
                done();
            });
            
            test('tg_toString for display: String converts', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityCompositeKey');
                entity.stringKey = 'KEY1';
                assert.strictEqual(reflector.tg_toString(entity.get('stringKey'), entity.type(), 'stringKey', { display: true }), 'KEY1');
                done();
            });
            
            test('tg_toString for display: String converts (empty string)', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityCompositeKey');
                entity.stringKey = '';
                assert.strictEqual(reflector.tg_toString(entity.get('stringKey'), entity.type(), 'stringKey', { display: true }), '');
                done();
            });
            
            test('tg_toString for display: boolean converts (true)', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityCompositeBooleanKey');
                entity.booleanKey = true;
                assert.strictEqual(reflector.tg_toString(entity.get('booleanKey'), entity.type(), 'booleanKey', { display: true }), 'true');
                done();
            });
            
            test('tg_toString for display: boolean converts (empty)', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityCompositeBooleanKey');
                entity.booleanKey = null;
                assert.strictEqual(reflector.tg_toString(entity.get('booleanKey'), entity.type(), 'booleanKey', { display: true }), 'false');
                done();
            });
            
            test('tg_toString for display: boolean converts (false)', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityCompositeBooleanKey');
                entity.booleanKey = false;
                assert.strictEqual(reflector.tg_toString(entity.get('booleanKey'), entity.type(), 'booleanKey', { display: true }), 'false');
                done();
            });
            
            test('tg_toString for display: Date converts', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityCompositeKey');
                entity.dateKey = 0;
                assert.strictEqual(reflector.tg_toString(entity.get('dateKey'), entity.type(), 'dateKey', { display: true }), _millisDateRepresentation(entity.dateKey, null, null));
                done();
            });
            
            const locale = 'en-AU';
            
            test('tg_toString for display: Integer converts', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityCompositeKey');
                entity.integerKey = 1700;
                assert.strictEqual(reflector.tg_toString(entity.get('integerKey'), entity.type(), 'integerKey', { display: true, locale: locale }), reflector.tg_formatInteger(entity.get('integerKey'), locale));
                done();
            });
            
            test('tg_toString for display: Long converts', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityCompositeKey');
                entity.longKey = 17000000000;
                assert.strictEqual(reflector.tg_toString(entity.get('longKey'), entity.type(), 'longKey', { display: true, locale: locale }), reflector.tg_formatInteger(entity.get('longKey'), locale));
                done();
            });
            
            test('tg_toString for display: BigDecimal converts', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityCompositeKey');
                entity.bigDecimalKey = 1700.1234;
                assert.strictEqual(reflector.tg_toString(entity.get('bigDecimalKey'), entity.type(), 'bigDecimalKey', { display: true, locale: locale }), reflector.tg_formatDecimal(entity.get('bigDecimalKey'), locale, entity.type().prop('bigDecimalKey').scale(), entity.type().prop('bigDecimalKey').trailingZeros()));
                done();
            });
            
            test('tg_toString for display: Entity converts', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityCompositeKey');
                entity.entityKey = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityStringKey');
                entity.entityKey.key = 'KEY1';
                assert.strictEqual(reflector.tg_toString(entity.get('entityKey'), entity.type(), 'entityKey', { display: true }), 'KEY1');
                done();
            });
            
            test('tg_toString for display: Money converts', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityCompositeKey');
                entity.moneyKey = { amount: 1700, currency: 'AUD', taxPercent: null };
                assert.strictEqual(reflector.tg_toString(entity.get('moneyKey'), entity.type(), 'moneyKey', { display: true, locale: locale }), reflector.tg_formatMoney(entity.get('moneyKey'), locale, entity.type().prop('moneyKey').scale(), entity.type().prop('moneyKey').trailingZeros()));
                done();
            });
            
            test('tg_toString for display: empty collection converts', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityCompositeKey');
                entity.listOfStringsProp = [];
                assert.strictEqual(reflector.tg_toString(entity.get('listOfStringsProp'), entity.type(), 'listOfStringsProp', { display: true }), '');
                entity.setOfEntitiesProp = [];
                assert.strictEqual(reflector.tg_toString(entity.get('setOfEntitiesProp'), entity.type(), 'setOfEntitiesProp', { display: true }), '');
                entity.shortCollectionalProp = [];
                assert.strictEqual(reflector.tg_toString(entity.get('shortCollectionalProp'), entity.type(), 'shortCollectionalProp', { display: true }), '');
                done();
            });
            
            test('tg_toString for display: list of strings converts', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityCompositeKey');
                entity.listOfStringsProp = ['str1', '', 'str2', null, 'str3', null];
                assert.strictEqual(reflector.tg_toString(entity.get('listOfStringsProp'), entity.type(), 'listOfStringsProp', { display: true }), 'str1, str2, str3');
                done();
            });
            
            test('tg_toString for display: long collection converts', function (done) {
                const master = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityCompositeKey');
                master.stringKey = 'MASTER';
                master.dateKey = null;
                master.integerKey = null;
                master.longKey = null;
                master.bigDecimalKey = null;
                master.moneyKey = null;
                master.colourKey = null;
                master.hyperlinkKey = null;
                master.entityKey = null;
                master.selfKey = null;
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityCompositeKey');
                entity.stringKey = 'STR1';
                entity.dateKey = null;
                entity.integerKey = null;
                entity.longKey = null;
                entity.bigDecimalKey = null;
                entity.moneyKey = null;
                entity.colourKey = null;
                entity.hyperlinkKey = null;
                entity.entityKey = null;
                entity.selfKey = master;
                master.setOfEntitiesProp = [entity, null, entity, null, entity, null];
                assert.strictEqual(reflector.tg_toString(master.get('setOfEntitiesProp'), master.type(), 'setOfEntitiesProp', { display: true }), 'STR1:MASTER, STR1:MASTER, STR1:MASTER');
                done();
            });
            
            test('tg_toString for display: short collection converts', function (done) {
                const master = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityCompositeKey');
                master.stringKey = 'MASTER';
                master.dateKey = null;
                master.integerKey = null;
                master.longKey = null;
                master.bigDecimalKey = null;
                master.moneyKey = null;
                master.colourKey = null;
                master.hyperlinkKey = null;
                master.entityKey = null;
                master.selfKey = null;
                const entity1 = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityTwoEntityKeys');
                entity1.parentKey = master;
                entity1.entityKey = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityStringKey');
                entity1.entityKey.key = 'STR1';
                const entity2 = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityTwoEntityKeys');
                entity2.parentKey = master;
                entity2.entityKey = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityStringKey');
                entity2.entityKey.key = 'STR2';
                const entity3 = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityTwoEntityKeys');
                entity3.parentKey = master;
                entity3.entityKey = null;
                master.shortCollectionalProp = [entity1, null, entity2, null, entity3, null];
                assert.strictEqual(reflector.tg_toString(master.get('shortCollectionalProp'), master.type(), 'shortCollectionalProp', { display: true }), 'STR1, STR2');
                done();
            });
            
            test('tg_toString for display: Colour converts', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityCompositeKey');
                entity.colourKey = { hashlessUppercasedColourValue: 'FFCC80' };
                assert.strictEqual(reflector.tg_toString(entity.get('colourKey'), entity.type(), 'colourKey', { display: true }), '#FFCC80');
                done();
            });
            
            test('tg_toString for display: Hyperlink converts', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityCompositeKey');
                entity.hyperlinkKey = { value: 'https://www.example.com' };
                assert.strictEqual(reflector.tg_toString(entity.get('hyperlinkKey'), entity.type(), 'hyperlinkKey', { display: true }), 'https://www.example.com');
                done();
            });
            
            test('tg_toString for collection as tooltip: long collection converts (empty)', function (done) {
                const master = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityCompositeKey');
                master.stringKey = 'MASTER';
                master.dateKey = null;
                master.integerKey = null;
                master.longKey = null;
                master.bigDecimalKey = null;
                master.moneyKey = null;
                master.colourKey = null;
                master.hyperlinkKey = null;
                master.entityKey = null;
                master.selfKey = null;
                master.setOfEntitiesProp = [null, null, null];
                assert.strictEqual(reflector.tg_toString(master.get('setOfEntitiesProp'), master.type(), 'setOfEntitiesProp', { collection: true, asTooltip: true }), '');
                done();
            });
            
            test('tg_toString for collection as tooltip: long collection converts', function (done) {
                const master = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityCompositeKey');
                master.stringKey = 'MASTER';
                master.dateKey = null;
                master.integerKey = null;
                master.longKey = null;
                master.bigDecimalKey = null;
                master.moneyKey = null;
                master.colourKey = null;
                master.hyperlinkKey = null;
                master.entityKey = null;
                master.selfKey = null;
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityCompositeKey');
                entity.stringKey = 'STR1';
                entity.desc = 'desc1';
                entity.dateKey = null;
                entity.integerKey = null;
                entity.longKey = null;
                entity.bigDecimalKey = null;
                entity.moneyKey = null;
                entity.colourKey = null;
                entity.hyperlinkKey = null;
                entity.entityKey = null;
                entity.selfKey = master;
                const entity2 = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityCompositeKey');
                entity2.stringKey = 'STR2';
                entity2.desc = null;
                entity2.dateKey = null;
                entity2.integerKey = null;
                entity2.longKey = null;
                entity2.bigDecimalKey = null;
                entity2.moneyKey = null;
                entity2.colourKey = null;
                entity2.hyperlinkKey = null;
                entity2.entityKey = null;
                entity2.selfKey = master;
                master.setOfEntitiesProp = [entity, null, entity, null, entity2, null];
                assert.strictEqual(reflector.tg_toString(master.get('setOfEntitiesProp'), master.type(), 'setOfEntitiesProp', { collection: true, asTooltip: true }), '<b>STR1:MASTER, STR1:MASTER, STR2:MASTER</b><br>desc1, desc1');
                done();
            });
            
            test('tg_toString for collection as tooltip: short collection converts', function (done) {
                const master = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityCompositeKey');
                master.stringKey = 'MASTER';
                master.dateKey = null;
                master.integerKey = null;
                master.longKey = null;
                master.bigDecimalKey = null;
                master.moneyKey = null;
                master.colourKey = null;
                master.hyperlinkKey = null;
                master.entityKey = null;
                master.selfKey = null;
                const entity1 = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityTwoEntityKeys');
                entity1.parentKey = master;
                entity1.entityKey = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityStringKey');
                entity1.entityKey.key = 'STR1';
                entity1.entityKey.desc = 'desc1';
                const entity2 = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityTwoEntityKeys');
                entity2.parentKey = master;
                entity2.entityKey = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityStringKey');
                entity2.entityKey.key = 'STR2';
                entity2.entityKey.desc = null;
                const entity3 = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityTwoEntityKeys');
                entity3.parentKey = master;
                entity3.entityKey = null;
                master.shortCollectionalProp = [entity1, null, entity2, null, entity3, null];
                assert.strictEqual(reflector.tg_toString(master.get('shortCollectionalProp'), master.type(), 'shortCollectionalProp', { collection: true, asTooltip: true }), '<b>STR1, STR2</b><br>desc1');
                done();
            });
            
            test('tg_toString for collection as tooltip: short collection converts (empty)', function (done) {
                const master = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityCompositeKey');
                master.stringKey = 'MASTER';
                master.dateKey = null;
                master.integerKey = null;
                master.longKey = null;
                master.bigDecimalKey = null;
                master.moneyKey = null;
                master.colourKey = null;
                master.hyperlinkKey = null;
                master.entityKey = null;
                master.selfKey = null;
                const entity3 = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityTwoEntityKeys');
                entity3.parentKey = master;
                entity3.entityKey = null;
                master.shortCollectionalProp = [null, entity3, null];
                assert.strictEqual(reflector.tg_toString(master.get('shortCollectionalProp'), master.type(), 'shortCollectionalProp', { collection: true, asTooltip: true }), '');
                done();
            });
            
            test('tg_toString for collection: list of strings converts', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityCompositeKey');
                entity.listOfStringsProp = ['1', '', '2', null, '3', null];
                assert.strictEqual(reflector.tg_toString(entity.get('listOfStringsProp'), entity.type(), 'listOfStringsProp', { collection: true }), '1, 2, 3');
                done();
            });
            
            test('tg_toString for collection: list of strings converts with custom separator', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityCompositeKey');
                entity.listOfStringsProp = ['1', '', '2', null, '3', null];
                assert.strictEqual(reflector.tg_toString(entity.get('listOfStringsProp'), entity.type(), 'listOfStringsProp', { collection: true, separator: ':' }), '1:2:3');
                done();
            });
            
            test('tg_toString for collection: list of strings converts with mapping function', function (done) {
                const entity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgEntityCompositeKey');
                entity.listOfStringsProp = ['1', '', '2', null, '3', null];
                assert.strictEqual(reflector.tg_toString(entity.get('listOfStringsProp'), entity.type(), 'listOfStringsProp', { collection: true, mappingFunction: str => str ? '' + (+str * 2) : '' }), '2, 4, 6');
                done();
            });
            
            // Testing the access to 'key' property of different kinds of entities.
            // This property is of high importance and should be much in sync with server-side implementation.
            // At this stage only equality and toString implementation is used when accessing properties.
            // However client-side code is not restricted to that.
            
            /////////////////////// entity.get('key') tests ///////////////////////
            test('test empty object convertion should be fine', function (done) {
                assert.deepEqual(reflector.tg_convert({}), {});
                done();
            });
            
            test('test object with arbitrary properties convertion should not be acceptable', function (done) {
                try {
                    reflector.tg_convert({testProp: "testProp"});
                } catch (ex) {
                    done();
                }
            });
            
            test('simple entity: key access is forbidden if not fetched', function (done) {
                const e1 = reflector.newEntity(typeName1);
                try {
                    e1.get('key');
                    assert.fail('Strict proxy exception is required.');
                } catch (ex) {
                    done();
                }
            });
            
            test('simple entity: key access returns concrete value if fetched', function (done) {
                const e1 = reflector.newEntity(typeName1);
                e1.key = 'DEMO01';
                assert.strictEqual(e1.get('key'), 'DEMO01');
                done();
            });
            
            test('simple entity: equality comparison is forbidden if key is not fetched', function (done) {
                const entity1 = reflector.newEntity(typeName1);
                entity1.key = 'DEMO01';
                const entity2 = reflector.newEntity(typeName1); // key is not fetched
                try {
                    reflector.equalsEx(entity1, entity2);
                    assert.fail('Strict proxy exception is required.');
                } catch (ex) {
                    done();
                }
            });
            
            test('simple entity: equality comparison succeeds if key is fetched', function (done) {
                const entity1 = reflector.newEntity(typeName1);
                entity1.key = 'DEMO01';
                const entity2 = reflector.newEntity(typeName1);
                entity2.key = 'DEMO01';
                
                assert.strictEqual(reflector.equalsEx(entity1, entity2), true);
                done();
            });
            
            test('simple entity: conversion is forbidden if key is not fetched', function (done) {
                const entity1 = reflector.newEntity(typeName1);
                try {
                    reflector.tg_convert(entity1);
                    assert.fail('Strict proxy exception is required.');
                } catch (ex) {
                    done();
                }
            });
            
            test('simple entity: conversion succeeds if key is fetched', function (done) {
                const entity1 = reflector.newEntity(typeName1);
                entity1.key = 'DEMO01';
                
                assert.strictEqual(reflector.tg_convert(entity1), 'DEMO01');
                done();
            });
            
            test('composite entity: key access returns DynamicEntityKey instance for fully-fetched composite keys', function (done) {
                const e1 = reflector.newEntity(typeName1);
                e1.key = 'DEMO01';
                const entity1 = reflector.newEntity(typeName2);
                entity1.key1 = e1;
                entity1.key2 = 7;
                assert.strictEqual(entity1.get('key') instanceof reflector.getDynamicEntityKeyPrototype(), true);
                done();
            });
            
            test('composite entity: key access also returns DynamicEntityKey instance for partly-fetched composite keys', function (done) {
                const entity1 = reflector.newEntity(typeName2);
                entity1.key2 = 7; // key1 is not fetched
                assert.strictEqual(entity1.get('key') instanceof reflector.getDynamicEntityKeyPrototype(), true);
                done();
            });
            
            test('composite entity: equality comparison is forbidden for partly-fetched composite keys', function (done) {
                const entity1 = reflector.newEntity(typeName2);
                entity1.key2 = 7; // key1 is not fetched
                
                const e1 = reflector.newEntity(typeName1);
                e1.key = 'DEMO01';
                const entity2 = reflector.newEntity(typeName2);
                entity2.key1 = e1;
                entity2.key2 = 7;
                
                try {
                    reflector.equalsEx(entity1, entity2);
                    assert.fail('Strict proxy exception is required.');
                } catch (ex) {
                    done();
                }
            });
            
            test('composite entity: equality comparison succeeds for fully-fetched composite keys', function (done) {
                const e1 = reflector.newEntity(typeName1);
                e1.key = 'DEMO01';
                const entity1 = reflector.newEntity(typeName2);
                entity1.key1 = e1;
                entity1.key2 = 7;
                
                const entity2 = reflector.newEntity(typeName2);
                entity2.key1 = e1;
                entity2.key2 = 7;
                
                assert.strictEqual(reflector.equalsEx(entity1, entity2), true);
                done();
            });
            
            test('composite entity: conversion is forbidden for partly-fetched composite keys', function (done) {
                const entity1 = reflector.newEntity(typeName2);
                entity1.key2 = 7; // key1 is not fetched
                try {
                    reflector.tg_convert(entity1);
                    assert.fail('Strict proxy exception is required.');
                } catch (ex) {
                    done();
                }
            });
            
            test('composite entity: conversion succeeds for fully-fetched composite keys', function (done) {
                const e1 = reflector.newEntity(typeName1);
                e1.key = 'DEMO01';
                const entity1 = reflector.newEntity(typeName2);
                entity1.key1 = e1;
                entity1.key2 = 7;
                
                assert.strictEqual(reflector.tg_convert(entity1), 'DEMO01 7');
                done();
            });
            
            test('union entity: key access for empty union entity returns empty value', function (done) {
                const uEntity = reflector.newEntity(typeName3); // TgBogieLocation union entity (no active entity)
                uEntity.wagonSlot = null;
                uEntity.workshop = null;
                
                assert.strictEqual(uEntity.get('key'), null);
                done();
            });
            
            test('union entity: equality comparison succeeds for empty union entity', function (done) {
                const uEntity1 = reflector.newEntity(typeName3); // TgBogieLocation union entity (no active entity)
                uEntity1.wagonSlot = null;
                uEntity1.workshop = null;
                const uEntity2 = reflector.newEntity(typeName3); // TgBogieLocation union entity (no active entity)
                uEntity2.wagonSlot = null;
                uEntity2.workshop = null;
                assert.strictEqual(reflector.equalsEx(uEntity1, uEntity2), true);
                done();
            });
            
            test('union entity: conversion succeeds for empty union entity', function (done) {
                const uEntity1 = reflector.newEntity(typeName3); // TgBogieLocation union entity (no active entity)
                uEntity1.wagonSlot = null;
                uEntity1.workshop = null;
                assert.strictEqual(reflector.tg_convert(uEntity1), reflector.KEY_NOT_ASSIGNED);
                done();
            });
            
            test('union entity: key access for union entity with simple entity being active returns key of this active entity', function (done) {
                const uEntity = reflector.newEntity(typeName3); // TgBogieLocation union entity (simple active entity)
                const workshop1 = reflector.newEntity(typeName4); // TgWorkshop
                workshop1.key = 'W1';
                uEntity.workshop = workshop1;
                uEntity.wagonSlot = null;
                
                assert.strictEqual(uEntity.get('key'), 'W1');
                done();
            });
            
            test('union entity: equality comparison for union entity with simple entity being active succeeds', function (done) {
                const uEntity1 = reflector.newEntity(typeName3); // TgBogieLocation union entity (simple active entity)
                const workshop1 = reflector.newEntity(typeName4); // TgWorkshop
                workshop1.key = 'W1';
                uEntity1.workshop = workshop1;
                uEntity1.wagonSlot = null;
                const uEntity2 = reflector.newEntity(typeName3); // TgBogieLocation union entity (simple active entity)
                const workshop2 = reflector.newEntity(typeName4); // TgWorkshop
                workshop2.key = 'W1';
                uEntity2.workshop = workshop2;
                uEntity2.wagonSlot = null;
                
                assert.strictEqual(reflector.equalsEx(uEntity1, uEntity2), true);
                done();
            });
            
            test('union entity: conversion for union entity with simple entity being active succeeds', function (done) {
                const uEntity1 = reflector.newEntity(typeName3); // TgBogieLocation union entity (simple active entity)
                const workshop1 = reflector.newEntity(typeName4); // TgWorkshop
                workshop1.key = 'W1';
                uEntity1.workshop = workshop1;
                uEntity1.wagonSlot = null;
                
                assert.strictEqual(reflector.tg_convert(uEntity1), 'W1');
                done();
            });
            
            test('union entity: key access for union entity with composite entity being active returns key of this active entity', function (done) {
                const uEntity = reflector.newEntity(typeName3); // TgBogieLocation union entity (composite active entity)
                const wagonSlot1 = reflector.newEntity(typeName5); // TgWagonSlot
                const wagon1 = reflector.newEntity(typeName6); // TgWagon
                wagon1.key = 'WAG1';
                wagonSlot1.wagon = wagon1;
                wagonSlot1.position = 7;
                uEntity.wagonSlot = wagonSlot1;
                
                assert.strictEqual(uEntity.get('key') instanceof reflector.getDynamicEntityKeyPrototype(), true);
                done();
            });
            
            test('union entity: equality comparison for union entity with composite entity being active succeeds', function (done) {
                const uEntity1 = reflector.newEntity(typeName3); // TgBogieLocation union entity (composite active entity)
                const wagonSlot1 = reflector.newEntity(typeName5); // TgWagonSlot
                const wagon1 = reflector.newEntity(typeName6); // TgWagon
                wagon1.key = 'WAG1';
                wagonSlot1.wagon = wagon1;
                wagonSlot1.position = 7;
                uEntity1.wagonSlot = wagonSlot1;
                const uEntity2 = reflector.newEntity(typeName3); // TgBogieLocation union entity (composite active entity)
                const wagonSlot2 = reflector.newEntity(typeName5); // TgWagonSlot
                const wagon2 = reflector.newEntity(typeName6); // TgWagon
                wagon2.key = 'WAG1';
                wagonSlot2.wagon = wagon2;
                wagonSlot2.position = 7;
                uEntity2.wagonSlot = wagonSlot2;
                
                assert.strictEqual(reflector.equalsEx(uEntity1, uEntity2), true);
                done();
            });
            
            test('union entity: conversion for union entity with composite entity being active succeeds', function (done) {
                const uEntity1 = reflector.newEntity(typeName3); // TgBogieLocation union entity (composite active entity)
                const wagonSlot1 = reflector.newEntity(typeName5); // TgWagonSlot
                const wagon1 = reflector.newEntity(typeName6); // TgWagon
                wagon1.key = 'WAG1';
                wagonSlot1.wagon = wagon1;
                wagonSlot1.position = 7;
                uEntity1.wagonSlot = wagonSlot1;
                
                assert.strictEqual(reflector.tg_convert(uEntity1), 'WAG1 7');
                done();
            });
            
            test('union entity: key access for union entity with simple entity being active is forbidden for partly-fetched active entity', function (done) {
                const uEntity = reflector.newEntity(typeName3); // TgBogieLocation union entity (simple active entity)
                const workshop1 = reflector.newEntity(typeName4); // TgWorkshop
                uEntity.workshop = workshop1;
                
                try {
                    uEntity.get('key');
                    assert.fail('Strict proxy exception is required.');
                } catch (ex) {
                    done();
                }
            });
            
            test('union entity: equality comparison for union entity with simple entity being active is forbidden for partly-fetched active entity', function (done) {
                const uEntity1 = reflector.newEntity(typeName3); // TgBogieLocation union entity (simple active entity)
                const workshop1 = reflector.newEntity(typeName4); // TgWorkshop
                uEntity1.workshop = workshop1;
                const uEntity2 = reflector.newEntity(typeName3); // TgBogieLocation union entity (simple active entity)
                const workshop2 = reflector.newEntity(typeName4); // TgWorkshop
                workshop2.key = 'W1';
                uEntity2.workshop = workshop1;
                
                try {
                    reflector.equalsEx(uEntity1, uEntity2);
                    assert.fail('Strict proxy exception is required.');
                } catch (ex) {
                    done();
                }
            });
            
            test('union entity: conversion for union entity with simple entity being active is forbidden for partly-fetched active entity', function (done) {
                const uEntity1 = reflector.newEntity(typeName3); // TgBogieLocation union entity (simple active entity)
                const workshop1 = reflector.newEntity(typeName4); // TgWorkshop
                uEntity1.workshop = workshop1;
                
                try {
                    reflector.tg_convert(uEntity1);
                    assert.fail('Strict proxy exception is required.');
                } catch (ex) {
                    done();
                }
            });
            
            test('union entity: key access for union entity with composite entity being active succeeds for partly-fetched active entity', function (done) {
                const uEntity = reflector.newEntity(typeName3); // TgBogieLocation union entity (composite active entity)
                const wagonSlot1 = reflector.newEntity(typeName5); // TgWagonSlot
                wagonSlot1.position = 7; // wagon is not fetched
                uEntity.wagonSlot = wagonSlot1;
                
                assert.strictEqual(uEntity.get('key') instanceof reflector.getDynamicEntityKeyPrototype(), true);
                done();
            });
            
            test('union entity: equality comparison for union entity with composite entity being active is forbidden for partly-fetched active entity', function (done) {
                const uEntity1 = reflector.newEntity(typeName3); // TgBogieLocation union entity (composite active entity)
                const wagonSlot1 = reflector.newEntity(typeName5); // TgWagonSlot
                wagonSlot1.position = 7; // wagon is not fetched
                uEntity1.wagonSlot = wagonSlot1;
                const uEntity2 = reflector.newEntity(typeName3); // TgBogieLocation union entity (composite active entity)
                const wagonSlot2 = reflector.newEntity(typeName5); // TgWagonSlot
                const wagon2 = reflector.newEntity(typeName6); // TgWagon
                wagon2.key = 'WAG1';
                wagonSlot2.wagon = wagon2;
                wagonSlot2.position = 7;
                uEntity2.wagonSlot = wagonSlot2;
                
                try {
                    reflector.equalsEx(uEntity1, uEntity2);
                    assert.fail('Strict proxy exception is required.');
                } catch (ex) {
                    done();
                }
            });
            
            test('union entity: conversion for union entity with composite entity being active is forbidden for partly-fetched active entity', function (done) {
                const uEntity1 = reflector.newEntity(typeName3); // TgBogieLocation union entity (composite active entity)
                const wagonSlot1 = reflector.newEntity(typeName5); // TgWagonSlot
                wagonSlot1.position = 7; // wagon is not fetched
                uEntity1.wagonSlot = wagonSlot1;
                
                try {
                    reflector.tg_convert(uEntity1);
                    assert.fail('Strict proxy exception is required.');
                } catch (ex) {
                    done();
                }
            });
            
            /////////////////////// entity.get('key') tests [END] /////////////////
            
            test('equalsEx method works for regular values', function (done) {
                assert.strictEqual(reflector.equalsEx('ok', 'ok'), true, "Equal values should return 'true' from equalsEx method.");
                assert.strictEqual(reflector.equalsEx('ok', 'not_ok'), false, "Not equal values should return 'false' from equalsEx method.");
                
                done();
            });
            
            test('equalsEx method works for money values', function (done) {
                assert.strictEqual(reflector.equalsEx({ amount: 45.6 }, undefined), false);
                assert.strictEqual(reflector.equalsEx({ amount: 45.6 }, null), false);
                assert.strictEqual(reflector.equalsEx({ amount: 45.6 }, {}), false);
                assert.strictEqual(reflector.equalsEx({ amount: 45.6 }, { amount: 45.6 }), true);
                assert.strictEqual(reflector.equalsEx({ amount: 45.6 }, { amount: 44.6 }), false);
                assert.strictEqual(reflector.equalsEx({ amount: 45.6, currency: 'AUD' }, { amount: 45.6 }), true);
                assert.strictEqual(reflector.equalsEx({ amount: 45.6 }, { amount: 45.6, currency: 'AUD' }), true);
                assert.strictEqual(reflector.equalsEx({ amount: 45.6 }, { amount: 45.6, taxPercent: null }), true);
                assert.strictEqual(reflector.equalsEx({ amount: 45.6 }, { amount: 45.6, currency: 'AUD', taxPercent: null }), true);
                
                assert.strictEqual(reflector.equalsEx(undefined, { amount: 45.6 }), false);
                assert.strictEqual(reflector.equalsEx(null, { amount: 45.6 }), false);
                assert.strictEqual(reflector.equalsEx({}, { amount: 45.6 }), false);
                assert.strictEqual(reflector.equalsEx({ amount: 45.6 }, { amount: 45.6, currency: 'AUD' }), true);
                assert.strictEqual(reflector.equalsEx({ amount: 45.6, currency: 'AUD' }, { amount: 45.6 }), true);
                assert.strictEqual(reflector.equalsEx({ amount: 45.6, taxPercent: null }, { amount: 45.6 }), true);
                assert.strictEqual(reflector.equalsEx({ amount: 45.6, currency: 'AUD', taxPercent: null }, { amount: 45.6 }), true);
                
                done();
            });
            
            test('equalsEx method works for colour values', function (done) {
                assert.strictEqual(reflector.equalsEx({ hashlessUppercasedColourValue: 'F44336' }, undefined), false);
                assert.strictEqual(reflector.equalsEx({ hashlessUppercasedColourValue: 'F44336' }, null), false);
                assert.strictEqual(reflector.equalsEx({ hashlessUppercasedColourValue: 'F44336' }, {}), false);
                assert.strictEqual(reflector.equalsEx({ hashlessUppercasedColourValue: 'F44336' }, { hashlessUppercasedColourValue: 'F44336' }), true);
                assert.strictEqual(reflector.equalsEx({ hashlessUppercasedColourValue: 'F44336' }, { hashlessUppercasedColourValue: 'F44338' }), false);
                assert.strictEqual(reflector.equalsEx({ hashlessUppercasedColourValue: 'F44336', redundantProp: '3' }, { hashlessUppercasedColourValue: 'F44336' }), true);
                assert.strictEqual(reflector.equalsEx({ hashlessUppercasedColourValue: 'F44336' }, { hashlessUppercasedColourValue: 'F44336', redundantProp: '3' }), true);
                
                assert.strictEqual(reflector.equalsEx(undefined, { hashlessUppercasedColourValue: 'F44336' }), false);
                assert.strictEqual(reflector.equalsEx(null, { hashlessUppercasedColourValue: 'F44336' }), false);
                assert.strictEqual(reflector.equalsEx({}, { hashlessUppercasedColourValue: 'F44336' }), false);
                
                done();
            });
            
            test('equalsEx method works for hyperlink values', function (done) {
                assert.strictEqual(reflector.equalsEx({ value: 'https://fielden.com.ua' }, undefined), false);
                assert.strictEqual(reflector.equalsEx({ value: 'https://fielden.com.ua' }, null), false);
                assert.strictEqual(reflector.equalsEx({ value: 'https://fielden.com.ua' }, {}), false);
                assert.strictEqual(reflector.equalsEx({ value: 'https://fielden.com.ua' }, { value: 'https://fielden.com.ua' }), true);
                assert.strictEqual(reflector.equalsEx({ value: 'https://fielden.com.ua' }, { value: 'https://fielden.com.au' }), false);
                assert.strictEqual(reflector.equalsEx({ value: 'https://fielden.com.ua', redundantProp: '3' }, { value: 'https://fielden.com.ua' }), true);
                assert.strictEqual(reflector.equalsEx({ value: 'https://fielden.com.ua' }, { value: 'https://fielden.com.ua', redundantProp: '3' }), true);
                
                assert.strictEqual(reflector.equalsEx(undefined, { value: 'https://fielden.com.ua' }), false);
                assert.strictEqual(reflector.equalsEx(null, { value: 'https://fielden.com.ua' }), false);
                assert.strictEqual(reflector.equalsEx({}, { value: 'https://fielden.com.ua' }), false);
                
                done();
            });
            
            test('equalsEx method works for falsey values', function (done) {
                assert.strictEqual(reflector.equalsEx(null, null), true, "Equal values should return 'true' from equalsEx method.");
                assert.strictEqual(reflector.equalsEx(undefined, undefined), true, "Equal values should return 'true' from equalsEx method.");
                assert.strictEqual(reflector.equalsEx(null, undefined), false, "Not equal values should return 'false' from equalsEx method.");
                
                done();
            });
            
            test('equalsEx method works for entity values', function (done) {
                var entity1 = reflector.newEntity(typeName1);
                var entity2 = reflector.newEntity(typeName2);
                var entity3 = reflector.newEntity(typeName1);
                
                assert.strictEqual(reflector.equalsEx(entity1, null), false, "The non-empty entity should be not equal to 'null'.");
                assert.strictEqual(reflector.equalsEx(undefined, entity1), false, "'undefined' value should be not equal to non-empty entity.");
                
                assert.strictEqual(reflector.equalsEx(entity1, entity1), true, "The same entity references should be equal.");
                
                assert.strictEqual(reflector.equalsEx(entity1, entity2), false, "Entities with different types should be not-equal.");
                
                done();
            });
            
            /**
             * Creates and registers new generated type with base type defined by 'baseTypeName'. It works through deep copying process of base type's EntityType instance and enhancing its full class name.
             */
            const createGenTypeFrom = function (baseTypeName, uuid) {
                const baseType = reflector.getType(baseTypeName); // take EntityType instance
                const genTypeRaw = JSON.parse(JSON.stringify(baseType)); // deep copy it, loosing EntityType and EntityTypeProp prototypes inside copied structure
                const genTypeName = baseTypeName + '$$TgEntity_' + uuid; // create new full class name
                genTypeRaw.key = genTypeName; // and assign it into raw entity type object
                const genType = reflector.registerEntityType(genTypeRaw); // then register new type using raw object and mutating it into fully fledged EntityType with EntityTypeProps inside
                return genType;
            };
            
            test('equalsEx method works for entity values with generated types', function (done) {
                const baseType = reflector.getType(typeName1);
                
                const entity1 = reflector.newEntity(baseType.fullClassName());
                entity1.key = 'DEMO00';
                
                const genType1 = createGenTypeFrom(baseType.fullClassName(), '1D67ABFEB644B0E3CDC6D145A51CA6FC385EFCE71C5DBFFE77F81D7BADCC1158');
                
                const entity2 = reflector.newEntity(genType1.fullClassName());
                entity2.key = 'DEMO00';
                const entity2Copy = reflector.newEntity(genType1.fullClassName());
                entity2Copy.key = 'DEMO00';
                
                const genType1Copy = createGenTypeFrom(baseType.fullClassName(), '1D67ABFEB644B0E3CDC6D145A51CA6FC385EFCE71C5DBFFE77F81D7BADCC1158');
                
                const entity3 = reflector.newEntity(genType1Copy.fullClassName());
                entity3.key = 'DEMO00';
                
                const genType2 = createGenTypeFrom(baseType.fullClassName(), '744D297BD157657F9CB33C140695371539E0AA30DFC22665E714BC9278A18612');
                
                const entity4 = reflector.newEntity(genType2.fullClassName());
                entity4.key = 'DEMO00';
                
                assert.strictEqual(reflector.equalsEx(entity2, entity2Copy), true, 'Entities with exactly the same type reference should be equal.');
                assert.strictEqual(reflector.equalsEx(entity2, entity3), true, 'Entities with same generated type, but with different references to that type, should be equal.');
                assert.strictEqual(reflector.equalsEx(entity2, entity4), true, 'Entities with different generated types, that are generated from the same base type, should be equal.');
                assert.strictEqual(reflector.equalsEx(entity2, entity1), true, 'entity1 with generated type should be equal to entity2 with the type, that represents a base type for entity1\'s type.');
                
                done();
            });
            
            test('isEntity method works for falsey values', function (done) {
                assert.strictEqual(reflector.isEntity(null), false, "'null' should not be 'is entity'.");
                assert.strictEqual(reflector.isEntity(undefined), false, "'undefined' should not be 'is entity'.");
                
                done();
            });
            
            test('equalsEx method works for entity values with regular keys', function (done) {
                var entity1 = reflector.newEntity(typeName1);
                entity1.key = 'DEMO01';
                var entity2 = reflector.newEntity(typeName1);
                entity2.key = 'DEMO02';
                var entity1copy = reflector.newEntity(typeName1);
                entity1copy.key = 'DEMO01';
                var entityWithoutKey = reflector.newEntity(typeName1);
                
                assert.strictEqual(reflector.equalsEx(entity1, entity1copy), true, "Entities with same keys should be equal.");
                assert.strictEqual(reflector.equalsEx(entity1, entity2), false, "Entities with different keys should be not equal.");
                
                try {
                    reflector.equalsEx(entity1, entityWithoutKey);
                    assert.fail('Second entity should cause failure during comparison, the \'key\' property is not defined.');
                } catch (msg) {
                    console.log(msg);
                }
                
                try {
                    reflector.equalsEx(entityWithoutKey, entity1);
                    assert.fail('First entity should cause failure during comparison, the \'key\' property is not defined.');
                } catch (msg) {
                    console.log(msg);
                }
                
                done();
            });
            
            test('equalsEx method works for entity values with composite keys', function (done) {
                var e1 = reflector.newEntity(typeName1); e1.key = 'DEMO01';
                var e1copy = reflector.newEntity(typeName1); e1copy.key = 'DEMO01';
                
                var entity1 = reflector.newEntity(typeName2);
                entity1.key1 = e1;
                entity1.key2 = 7;
                var entity2 = reflector.newEntity(typeName2);
                entity2.key1 = e1;
                entity2.key2 = 9;
                var entity1copy = reflector.newEntity(typeName2);
                entity1copy.key1 = e1copy;
                entity1copy.key2 = 7;
                var entityWithoutKey = reflector.newEntity(typeName2);
                entityWithoutKey.key2 = 7;
                
                assert.strictEqual(reflector.equalsEx(entity1, entity1copy), true, "Entities with same composite keys should be equal.");
                assert.strictEqual(reflector.equalsEx(entity1, entity2), false, "Entities with different composite keys should be not equal.");
                
                try {
                    reflector.equalsEx(entity1, entityWithoutKey);
                    assert.fail('Second entity should cause failure during comparison, the \'key1\' property is not defined.');
                } catch (msg) {
                    console.log(msg);
                }
                
                try {
                    reflector.equalsEx(entityWithoutKey, entity1);
                    assert.fail('First entity should cause failure during comparison, the \'key1\' property is not defined.');
                } catch (msg) {
                    console.log(msg);
                }
                
                done();
            });
            
            test('equalsEx method works for arrays', function (done) {
                var entity1 = reflector.newEntity(typeName1);
                entity1.key = 'DEMO01';
                var entity2 = reflector.newEntity(typeName1);
                entity2.key = 'DEMO02';
                var entity1copy = reflector.newEntity(typeName1);
                entity1copy.key = 'DEMO01';
                var entityWithoutKey = reflector.newEntity(typeName1);
                
                assert.strictEqual(reflector.equalsEx([], null), false, "Array should not be equal to null.");
                assert.strictEqual(reflector.equalsEx(null, []), false, "Null should not be equal to array.");
                assert.strictEqual(reflector.equalsEx([], undefined), false, "Array should not be equal to null.");
                assert.strictEqual(reflector.equalsEx(undefined, []), false, "Null should not be equal to array.");
                var arr1 = [];
                var arr1copy = [];
                assert.strictEqual(reflector.equalsEx(arr1, arr1), true, "Array should be equal to itself.");
                assert.strictEqual(reflector.equalsEx(arr1, arr1copy), true, "Two empty arrays should be equal.");
                var arr2 = [entity1];
                assert.strictEqual(reflector.equalsEx(arr1, arr2), false, "Non-empty array should not be equal to empty.");
                assert.strictEqual(reflector.equalsEx(arr2, arr1), false, "Non-empty array should not be equal to empty.");
                var arr2copy = [entity1];
                assert.strictEqual(reflector.equalsEx(arr2, arr2copy), true, "Two arrays with the same item should be equal.");
                assert.strictEqual(reflector.equalsEx(arr2copy, arr2), true, "Two arrays with the same item should be equal.");
                var arr2copy2 = [entity1copy];
                assert.strictEqual(reflector.equalsEx(arr2, arr2copy2), true, "Two arrays with the equal item should be equal.");
                assert.strictEqual(reflector.equalsEx(arr2copy2, arr2), true, "Two arrays with the equal item should be equal.");
                var arr3 = [entity2];
                assert.strictEqual(reflector.equalsEx(arr1, arr3), false, "Two arrays with non-equal item should not be equal.");

                done();
            });
            
            test('isPersistent method works', function (done) {
                assert.strictEqual(reflector.getType('ua.com.fielden.platform.sample.domain.TgPersistentEntityWithProperties').isPersistent(), true);
                assert.strictEqual(reflector.getType('ua.com.fielden.platform.sample.domain.TgFunctionalEntityWithCentreContext').isPersistent(), false);
                done();
            });
            
            test('shouldDisplayDescription method works', function (done) {
                assert.strictEqual(reflector.getType('ua.com.fielden.platform.sample.domain.TgPersistentEntityWithProperties').shouldDisplayDescription(), true);
                assert.strictEqual(reflector.getType('ua.com.fielden.platform.sample.domain.TgPersistentCompositeEntity').shouldDisplayDescription(), false);
                done();
            });
            
            test('isContinuation method works', function (done) {
                assert.strictEqual(reflector.getType('ua.com.fielden.platform.entity.functional.master.AcknowledgeWarnings').isContinuation(), true);
                assert.strictEqual(reflector.getType('ua.com.fielden.platform.sample.domain.TgFunctionalEntityWithCentreContext').isContinuation(), false);
                done();
            });
            
            test('isUnionEntity method works', function (done) {
                assert.strictEqual(reflector.getType('ua.com.fielden.platform.sample.domain.TgUnion').isUnionEntity(), true);
                assert.strictEqual(reflector.getType('ua.com.fielden.platform.sample.domain.TgFunctionalEntityWithCentreContext').isUnionEntity(), false);
                done();
            });
            
            test('unionCommonProps method returns key and desc for types that define those properties and if the properties have the same types', function (done) {
                assert.deepEqual(reflector.getType('ua.com.fielden.platform.sample.domain.TgUnion').unionCommonProps(), [
                    'key', // key is always at the beginning of common props list, if present
                    'common', // common props from most specific types TgUnionType1 and TgUnionType2
                    'active', 'refCount', // common props from ActivatableAbstractEntity
                    'createdBy', 'createdDate', 'createdTransactionGuid', 'lastUpdatedBy', 'lastUpdatedDate', 'lastUpdatedTransactionGuid', // common props from AbstractPersistentEntity
                    'desc' // common props from AbstractEntity
                ]);
                done();
            });
            
            test('unionCommonProps method does not return key for types one of composite nature (DynamicEntityKey key) and other not (String key)', function (done) {
                assert.deepEqual(reflector.getType('ua.com.fielden.platform.sample.domain.TgBogieLocation').unionCommonProps(), [
                    'fuelType', // common props from most specific types TgWagonSlot and TgWorkshop
                    'desc' // common prop from AbstractEntity (in both union types @DescTitle is present)
                ]);
                done();
            });
            
            test('unionCommonProps method does not return desc for types where one of them has no @DescTitle annotation', function (done) {
                assert.deepEqual(reflector.getType('ua.com.fielden.platform.sample.domain.UnionEntityWithoutSecondDescTitle').unionCommonProps(), [
                    'stringProperty' // common props from most specific types EntityOne and EntityThree
                ]);
                done();
            });
            
            test('compoundOpenerType method works', function (done) {
                assert.strictEqual(reflector.getType('ua.com.fielden.platform.sample.domain.compound.ui_actions.OpenTgCompoundEntityMasterAction').compoundOpenerType(), 'ua.com.fielden.platform.sample.domain.compound.TgCompoundEntity');
                assert.strictEqual(reflector.getType('ua.com.fielden.platform.sample.domain.TgPersistentEntityWithProperties').compoundOpenerType(), null);
                done();
            });
            
            test('isCompoundMenuItem method works', function (done) {
                assert.strictEqual(reflector.getType('ua.com.fielden.platform.sample.domain.compound.master.menu.actions.TgCompoundEntityMaster_OpenMain_MenuItem').isCompoundMenuItem(), true);
                assert.strictEqual(reflector.getType('ua.com.fielden.platform.sample.domain.compound.ui_actions.OpenTgCompoundEntityMasterAction').isCompoundMenuItem(), false);
                done();
            });
            
            test('empty union entity gives empty values for id, key, desc and common properties', function (done) {
                const union = reflector.newEntity('ua.com.fielden.platform.sample.domain.UnionEntity');
                
                union.propertyOne = null;
                union.propertyTwo = null;
                
                assert.strictEqual(union.get('key'), null);
                assert.strictEqual(union.get('desc'), null);
                assert.strictEqual(union.get('stringProperty'), null);
                assert.strictEqual(union.get('id'), null);
                
                done();
            });
            
            test('non-empty union entity gives value for key from its active entity even if key is not common property; id is present too', function (done) {
                const union = reflector.newEntity('ua.com.fielden.platform.sample.domain.UnionEntity');
                
                const propertyOneVal = reflector.newEntity('ua.com.fielden.platform.sample.domain.EntityOne');
                propertyOneVal.key = 'EO1';
                propertyOneVal.desc = 'EO1 desc';
                propertyOneVal.id = 101;
                union.propertyOne = propertyOneVal;
                
                union.propertyTwo = null;
                
                assert.strictEqual(union.get('key'), 'EO1');
                assert.strictEqual(union.get('desc'), 'EO1 desc');
                assert.strictEqual(union.get('id'), 101);
                
                done();
            });
            
            test('non-empty union entity gives value for desc from its active entity even if desc is not common property; id is present too', function (done) {
                const union = reflector.newEntity('ua.com.fielden.platform.domain.metadata.DomainPropertyHolder');
                
                const domainTypeVal = reflector.newEntity('ua.com.fielden.platform.domain.metadata.DomainType');
                domainTypeVal.key = 'ua.com.fielden.platform.domain.metadata.DomainType';
                domainTypeVal.desc = 'DomainType description';
                domainTypeVal.id = 101;
                union.domainType = domainTypeVal;
                
                union.domainProperty = null;
                
                assert.strictEqual(union.get('key'), 'ua.com.fielden.platform.domain.metadata.DomainType');
                assert.strictEqual(union.get('desc'), 'DomainType description');
                assert.strictEqual(union.get('id'), 101);
                
                done();
            });
            
            test('non-empty union entity gives value for common property from its active entity', function (done) {
                const union = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgUnion');
                
                const union1Val = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgUnionType1');
                union1Val.key = 'U1';
                
                const union1CommonVal = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgUnionCommonType');
                union1Val.common = union1CommonVal;
                union1Val.active = false;
                union1Val.refCount = 7;
                union1Val.createdTransactionGuid = 'xxyyzz';
                union1Val.desc = 'U1 description';
                union1Val.id = 101;
                union.union1 = union1Val;
                
                union.union2 = null;
                
                assert.strictEqual(union.get('key'), 'U1');
                assert.strictEqual(union.get('common'), union1CommonVal);
                assert.strictEqual(union.get('active'), false);
                assert.strictEqual(union.get('refCount'), 7);
                assert.strictEqual(union.get('createdTransactionGuid'), 'xxyyzz');
                assert.strictEqual(union.get('desc'), 'U1 description');
                
                done();
            });
            
            test('non-empty union entity gives value for common key and common desc properties from its active entity', function (done) {
                const union = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgUnion');
                
                const union1Val = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgUnionType1');
                union1Val.key = 'U1';
                union1Val.desc = 'U1 description';
                union1Val.id = 101;
                union.union1 = union1Val;
                union.union2 = null;
                
                assert.strictEqual(union.get('key'), 'U1');
                assert.strictEqual(union.get('desc'), 'U1 description');
                
                done();
            });
            
            test('non-empty union entity gives value for common subproperty from its active entity', function (done) {
                const union = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgUnion');
                
                const union1Val = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgUnionType1');
                const union1CommonVal = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgUnionCommonType');
                union1CommonVal.desc = 'common sub-prop description';
                union1Val.common = union1CommonVal;
                union.union1 = union1Val;
                
                union.union2 = null;
                
                assert.strictEqual(union.get('common.desc'), 'common sub-prop description');
                
                done();
            });
            
            test('foramtting: formatting 123.3 decimal with scale and trailing zeros should return 123.3000', function (done) {
                assert.equal(reflector.tg_formatDecimal(123.3, 'en-AU', 4, true), "123.3000");
                done();
            });
            
            test('foramtting: formatting 123.3121 decimal with scale and trailing zeros should return 123.3121', function (done) {
                assert.equal(reflector.tg_formatDecimal(123.3121, 'en-AU', 4, true), "123.3121");
                done();
            });
            
            test('foramtting: formatting 123.3 decimal with scale and without trailing zeros should return 123.3', function (done) {
                assert.equal(reflector.tg_formatDecimal(123.3, 'en-AU', 4, false), "123.3");
                done();
            });
            
            test('foramtting: formatting 123.3121 decimal with scale and without trailing zeros should return 123.3121', function (done) {
                assert.equal(reflector.tg_formatDecimal(123.3121, 'en-AU', 4, false), "123.3121");
                done();
            });
            
            test('foramtting: formatting 123.3 money with scale and trailing zeros should return $123.3000', function (done) {
                assert.equal(reflector.tg_formatMoney({amount: 123.3}, 'en-AU', 4, true), "$" + CURRENCY_SYMBOL_SPACE + "123.3000");
                done();
            });

            test('foramtting: formatting -123.3 money with scale and trailing zeros should return -$123.3000', function (done) {
                assert.equal(reflector.tg_formatMoney({amount: -123.3}, 'en-AU', 4, true), "-$" + CURRENCY_SYMBOL_SPACE + "123.3000");
                done();
            });

            test('foramtting: formatting 123.3121 money with scale and trailing zeros should return $123.3121', function (done) {
                assert.equal(reflector.tg_formatMoney({amount: 123.3121}, 'en-AU', 4, true), "$" + CURRENCY_SYMBOL_SPACE + "123.3121");
                done();
            });
            
            test('foramtting: formatting 123.3 money with scale and without trailing zeros should return $123.3', function (done) {
                assert.equal(reflector.tg_formatMoney({amount: 123.3}, 'en-AU', 4, false), "$" + CURRENCY_SYMBOL_SPACE + "123.3");
                done();
            });
            
             test('foramtting: formatting 123.3121 decimal with scale and without trailing zeros should return $123.3121', function (done) {
                assert.equal(reflector.tg_formatMoney({amount: 123.3121}, 'en-AU', 4, false), "$" + CURRENCY_SYMBOL_SPACE + "123.3121");
                done();
            });
            
            test('foramtting: formatting 123.3 decimal with default scale and trailing zeros should return 123.30', function (done) {
                assert.equal(reflector.tg_formatDecimal(123.3, 'en-AU', undefined, true), "123.30");
                done();
            });
            
            test('foramtting: formatting 123.3121 decimal with default scale and trailing zeros should return 123.31', function (done) {
                assert.equal(reflector.tg_formatDecimal(123.3121, 'en-AU', undefined, true), "123.31");
                done();
            });
            
            test('foramtting: formatting 123.3 decimal with default scale and without trailing zeros should return 123.30', function (done) {
                assert.equal(reflector.tg_formatDecimal(123.3, 'en-AU'), "123.30");
                done();
            });
            
            test('foramtting: formatting 123.3121 decimal with default scale and without trailing zeros should return 123.31', function (done) {
                assert.equal(reflector.tg_formatDecimal(123.3121, 'en-AU'), "123.31");
                done();
            });
            
            test('foramtting: formatting 123.3 money with default scale and trailing zeros should return $123.30', function (done) {
                assert.equal(reflector.tg_formatMoney({amount: 123.3}, 'en-AU', undefined, true), "$" + CURRENCY_SYMBOL_SPACE + "123.30");
                done();
            });
            
            test('foramtting: formatting 123.3121 money with default scale and trailing zeros should return $123.31', function (done) {
                assert.equal(reflector.tg_formatMoney({amount: 123.3121}, 'en-AU', undefined, true), "$" + CURRENCY_SYMBOL_SPACE + "123.31");
                done();
            });
            
            test('foramtting: formatting 123.3 money with default scale and without trailing zeros should return $123.30', function (done) {
                assert.equal(reflector.tg_formatMoney({amount: 123.3}, 'en-AU'), "$" + CURRENCY_SYMBOL_SPACE + "123.30");
                done();
            });
            
            test('foramtting: formatting 123.3121 money with default scale and without trailing zeros should return $123.31', function (done) {
                assert.equal(reflector.tg_formatMoney({amount: 123.3121}, 'en-AU'), "$" + CURRENCY_SYMBOL_SPACE + "123.31");
                done();
            });
            
            test('prop retrieving: retrieveing of second level property should work fine', function (done) {
                const entity = reflector.newEntity(typeName1); 
                entity.key = 'DEMO01';
                const compositeEntity = reflector.newEntity(typeName2);
                compositeEntity.key1 = entity;
                compositeEntity.key2 = 7;
                const metaProp = reflector.getEntityTypeProp(compositeEntity, "key1.bigDecimalProp");
                assert.equal(metaProp.precision(), 18);
                assert.equal(metaProp.scale(), 5);
                assert.equal(metaProp.trailingZeros(), true);
                done();
            });
            
            test('prop retrieving: retrieveing of first level property should work fine', function (done) {
                const entity = reflector.newEntity(typeName1); 
                entity.key = 'DEMO01';
                const metaProp = reflector.getEntityTypeProp(entity, "bigDecimalProp");
                assert.equal(metaProp.precision(), 18);
                assert.equal(metaProp.scale(), 5);
                assert.equal(metaProp.trailingZeros(), true);
                done();
            });
            
            test('prop retrieving: retrieveing of empty property should return undefined', function (done) {
                const entity = reflector.newEntity(typeName1); 
                entity.key = 'DEMO01';
                const metaProp = reflector.getEntityTypeProp(entity, "");
                assert.equal(typeof metaProp, 'undefined');
                done();
            });
            
            test('prop retrieving: retrieveing of non exisiting property should return undefined', function (done) {
                const entity = reflector.newEntity(typeName1); 
                entity.key = 'DEMO01';
                const metaProp = reflector.getEntityTypeProp(entity, "nonExisting");
                assert.equal(typeof metaProp, 'undefined');
                done();
            });
        });
    </script>
</body>

</html>