<!doctype html>
<html>

<head>
    <meta charset="UTF-8">
    <title>entity-master basic tests</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">
    
    <script src="/resources/polymer/@webcomponents/webcomponentsjs/webcomponents-bundle.js"></script>
    <script src='/resources/polymer/web-animations-js/web-animations-next-lite.min.js'></script>
    <script src="/resources/filesaver/FileSaver.min.js"></script>
    <script src="/resources/polymer/wct-browser-legacy/browser.js"></script>
    <script type="module" src="/resources/test-config-loader.js"></script>
</head>

<body>
    <tg-reflector id="reflector"></tg-reflector>
    <test-fixture id="MasterFixture">
        <template>
               <tg-TgPersistentEntityWithProperties-master 
                id="master" 
                entity-type="ua.com.fielden.platform.sample.domain.TgPersistentEntityWithProperties" 
                entity-id="new" 
                current-state="EDIT">
            </tg-TgPersistentEntityWithProperties-master>
        </template>
    </test-fixture>

    <script type="module">

        import '/app/tg-reflector.js';
        import { _millis } from '/resources/reflection/tg-date-utils.js';
        import '/master_ui/ua.com.fielden.platform.sample.domain.TgPersistentEntityWithProperties';

        const _editProperties = function (master, datePropEditingValue, keyPropEditingValue) {
            master.$.editor_4_requiredValidatedProp._editingValue = '30';
            master.$.editor_4_requiredValidatedProp.commit();
            master.$.editor_4_key._editingValue = keyPropEditingValue ? keyPropEditingValue : 'key_to_pass_validation_before_save_' + (new Date()).getTime();
            master.$.editor_4_key.commit();
            master.$.editor_4_dateProp._editingValue = datePropEditingValue;
            master.$.editor_4_dateProp.commit();
        };
    
        suite('retrieval', function() {
            let master, reflector;
        
            setup(function() {
                master = fixture('MasterFixture');
                  reflector = document.querySelector('#reflector');
            });
        
            test('works for new entity', function(done) {
                master.postRetrieved = function(entity, bindingEntity, customObject) {
                    assert.strictEqual(entity.type().fullClassName(), 'ua.com.fielden.platform.sample.domain.TgPersistentEntityWithProperties', 'The type of entity response is not correct.');
                    assert.strictEqual(entity.get('id'), null, 'The id of entity is not correct.');
                    assert.strictEqual(entity.version, 0, 'The version of entity is not correct.');
                
                    // properties:
                    assert.strictEqual(typeof entity.get('integerProp'), 'object', 'The entity response property is not correct.');
                    assert.strictEqual(entity.get('integerProp'), null, 'The entity response property is not correct.');
                    
                    try {
                        entity.get('idOnlyProxyProp');
                        assert.fail('', '', 'The unfetched property for entity should throw an exception.');
                    } catch (ex) {
                        if (ex instanceof chai.AssertionError) {
                            throw ex;
                        }
                        assert.strictEqual(ex instanceof reflector.getStrictProxyExceptionPrototype(), true, 'The exception thrown should be of type StrictProxyException.');
                        assert.strictEqual(ex.message, 'Strict proxy exception: property [idOnlyProxyProp] is id-only proxy in the entity of type [TgPersistentEntityWithProperties]. Please, check the fetch strategy or construction strategy of the entity object.');
                    }
                
                    // instance meta-properties
                    assert.strictEqual(entity.prop('integerProp').isChangedFromOriginal(), false, 'The entity response instance prop should be not changedFromOriginal.');
                    assert.strictEqual(entity.prop('integerProp').validationResult(), null, 'The entity response instance prop should have empty validation result.');
                    assert.strictEqual(entity.prop('integerProp').isRequired(), false, 'The entity response instance prop should be not required.');
                    assert.strictEqual(entity.prop('integerProp').isEditable(), true, 'The entity response instance prop should be editable.');
                    assert.strictEqual(entity.prop('integerProp').isVisible(), true, 'The entity response instance prop should be visible.');
                
                    // binding value ok?
                    assert.strictEqual(typeof bindingEntity.get('integerProp'), 'object', 'Binding property should be initialised.');
                    assert.strictEqual(bindingEntity.get('integerProp'), null, 'Binding property should be string entity representation.');
                
                    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                    ///////////////////////////////// CHECK THE VALUES INITIALISED BY ENTITY PRODUCER: /////////////////////////////////
                    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                    // value ok?
                    assert.ok(entity.get('producerInitProp'), 'The property should be initialised.');
                    assert.instanceOf(entity.get('producerInitProp'), reflector.getEntityPrototype(), 'The property should be of entity type.');
                    assert.strictEqual(entity.get('producerInitProp').get('key'), 'DEFAULT_KEY', 'The entity response property should be entity instance with appropriate key.');
                
                    // value is changed?
                    assert.strictEqual(entity.prop('producerInitProp').isChangedFromOriginal(), false, 'Instance meta-prop should be not changedFromOriginal, because all properties get their state reset in default producer implementation (DefaultEntityProducerWithContext).');
                
                    // value validationresult?
                    assert.strictEqual(entity.prop('producerInitProp').validationResult(), null, 'Instance meta-prop should have empty (successful) validation result.');
                
                    // binding value ok?
                    assert.ok(bindingEntity.get('producerInitProp'), 'Binding property should be initialised.');
                    assert.strictEqual(bindingEntity.get('producerInitProp'), 'DEFAULT_KEY', 'Binding property should be string entity representation.');
                
                    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                    ///////////////////////////////// CHECK THE VALUES INITIALISED BY ENTITY CLASS DEFINITION: /////////////////////////
                    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                    // value ok?
                    assert.ok(entity.get('domainInitProp'), 'The property should be initialised.');
                    assert.strictEqual(entity.get('domainInitProp'), 'ok', 'The entity response property should be correct.');
                
                    // value is changed?
                    assert.strictEqual(entity.prop('domainInitProp').isChangedFromOriginal(), false, 'Instance meta-prop should be not changedFromOriginal, because all properties get their state reset in default producer implementation (DefaultEntityProducerWithContext).');
                
                    // value validationresult?
                    assert.strictEqual(entity.prop('domainInitProp').validationResult(), null, 'Instance meta-prop should have empty (successful) validation result.');
                
                    // binding value ok?
                    assert.ok(bindingEntity.get('domainInitProp'), 'Binding property should be initialised.');
                    assert.strictEqual(bindingEntity.get('domainInitProp'), 'ok', 'Binding property should be string entity representation.');
                
                    done();
                };
                
                master.retrieve();
            });
            
            test('works for new persisted entity', function(done) {
                master.entityId = '5';
                
                master.postRetrieved = function(entity, bindingEntity, customObject) {
                    assert.strictEqual(entity.type().fullClassName(), 'ua.com.fielden.platform.sample.domain.TgPersistentEntityWithProperties', 'The type of entity response is not correct.');
                    assert.strictEqual(entity.get('id'), 5, 'The id of entity response is not correct.');
                    assert.strictEqual(entity.version, 0, 'The version of entity response is not correct.');

                    // properties:
                    assert.strictEqual(entity.get('integerProp'), 43, 'The entity response property is not correct.');

                    try {
                        entity.get('proxyProp');
                        assert.fail('', '', 'The unfetched property for entity should throw an exception.');
                    } catch (ex) {
                        if (ex instanceof chai.AssertionError) {
                            throw ex;
                        }
                        assert.strictEqual(ex instanceof reflector.getStrictProxyExceptionPrototype(), true, 'The exception thrown should be of type StrictProxyException.');
                        assert.strictEqual(ex.message, 'Strict proxy exception: property [proxyProp] does not exist in the entity of type [TgPersistentEntityWithProperties]. Please, check the fetch strategy or construction strategy of the entity object.');
                    }

                    // instance meta-properties
                    assert.strictEqual(entity.prop('integerProp').isChangedFromOriginal(), false, 'The entity response instance prop should be not changedFromOriginal.');
                    assert.strictEqual(entity.prop('integerProp').validationResult(), null, 'The entity response instance prop should have empty validation result.');
                    assert.strictEqual(entity.prop('integerProp').isRequired(), false, 'The entity response instance prop should be not required.');
                    assert.strictEqual(entity.prop('integerProp').isEditable(), true, 'The entity response instance prop should be editable.');
                    assert.strictEqual(entity.prop('integerProp').isVisible(), true, 'The entity response instance prop should be visible.');

                    // binding value ok?
                    assert.ok(bindingEntity.get('integerProp'), 'Binding property should be initialised.');
                    assert.strictEqual(bindingEntity.get('integerProp'), 43, 'Binding property should be string entity representation.');

                    done();
                };

                master.retrieve();
            });
        });
        
        suite('validation', function() {
            let master, reflector;
        
            setup(function() {
                master = fixture('MasterFixture');
                reflector = document.querySelector('#reflector');
            });
        
            test('works for property', function(done) {
                master.entityId = '5';
                
                master.postValidated = function(validatedEntity, bindingEntity, customObject) {
                    // value ok?
                    assert.ok(validatedEntity.get('integerProp'), 'Property value should be initialised.');
                    assert.strictEqual(validatedEntity.get('integerProp'), 43, 'Property value remain the same (validation did not succeed).');

                    // value is changed?
                    assert.strictEqual(validatedEntity.prop('integerProp').isChangedFromOriginal(), false, 'Instance meta-prop should be NOT changedFromOriginal.');

                    // value validationresult?
                    assert.ok(validatedEntity.prop('integerProp').validationResult(), 'Instance meta-prop should have non-empty (unsuccessful) validation result.');
                    assert.strictEqual(validatedEntity.prop('integerProp').validationResult().message, 'Value should be less or equal to 9999.', 'Property has incorrect validation result message.');

                    // binding value ok?
                    assert.ok(bindingEntity.get('integerProp'), 'Binding property should be initialised.');
                    assert.strictEqual(bindingEntity.get('integerProp'), 10000, 'Binding property should be correct number.');

                    done();
                };

                master.postRetrieved = function(entity, bindingEntity, customObject) {
                    // value ok?
                    assert.ok(entity.get('integerProp'), 'Property value should be initialised.');
                    assert.strictEqual(entity.get('integerProp'), 43, 'Property value should be correct.');

                    // value is changed?
                    assert.strictEqual(entity.prop('integerProp').isChangedFromOriginal(), false, 'Instance meta-prop should be not changedFromOriginal.');

                    // value validationresult?
                    assert.strictEqual(entity.prop('integerProp').validationResult(), null, 'Instance meta-prop should have empty (successful) validation result.');

                    // binding value ok?
                    assert.ok(bindingEntity.get('integerProp'), 'Binding property should be initialised.');
                    assert.strictEqual(bindingEntity.get('integerProp'), 43, 'Binding property should be string entity representation.');

                    // ACTUAL PROPERTY CHANGE
                    bindingEntity.setAndRegisterPropertyTouch('integerProp', 10000);

                    master.validate();
                };

                master.retrieve();
            });
            
            test('works for integer property', function (done) {
                master.entityId = '5';
                
                master.postValidated = function(validatedEntity, bindingEntity, customObject) {
                    // value ok?
                    assert.ok(validatedEntity.get('integerProp'), 'Property value should be initialised.');
                    assert.strictEqual(validatedEntity.get('integerProp'), 98, 'Property value should be correct.');

                    // value is changed?
                    assert.strictEqual(validatedEntity.prop('integerProp').isChangedFromOriginal(), true, 'Instance meta-prop should be changedFromOriginal.');

                    // value validationresult?
                    assert.strictEqual(validatedEntity.prop('integerProp').validationResult(), null, 'Instance meta-prop should have empty (successful) validation result.');

                    // binding value ok?
                    assert.ok(bindingEntity.get('integerProp'), 'Binding property should be initialised.');
                    assert.strictEqual(bindingEntity.get('integerProp'), 98, 'Binding property should be correct number.');

                    done();
                };

                master.postRetrieved = function(entity, bindingEntity, customObject) {
                    // value ok?
                    assert.ok(entity.get('integerProp'), 'Property value should be initialised.');
                    assert.strictEqual(entity.get('integerProp'), 43, 'Property value should be correct.');

                    // value is changed?
                    assert.strictEqual(entity.prop('integerProp').isChangedFromOriginal(), false, 'Instance meta-prop should be not changedFromOriginal.');

                    // value validationresult?
                    assert.strictEqual(entity.prop('integerProp').validationResult(), null, 'Instance meta-prop should have empty (successful) validation result.');

                    // binding value ok?
                    assert.ok(bindingEntity.get('integerProp'), 'Binding property should be initialised.');
                    assert.strictEqual(bindingEntity.get('integerProp'), 43, 'Binding property should be string entity representation.');
                    
                    // ACTUAL PROPERTY CHANGE
                    bindingEntity.setAndRegisterPropertyTouch('integerProp', 98);

                    master.validate();
                };

                master.retrieve();
            });
            
            test('works for bigDecimal property', function (done) {
                master.entityId = '9';
                
                master.postValidated = function(validatedEntity, bindingEntity, customObject) {
                    // value ok?
                    assert.ok(validatedEntity.get('bigDecimalProp'), 'Property value should be initialised.');
                    assert.strictEqual(validatedEntity.get('bigDecimalProp'), 46.5, 'Property value should be correct.');

                    // value is changed?
                    assert.strictEqual(validatedEntity.prop('bigDecimalProp').isChangedFromOriginal(), true, 'Instance meta-prop should be changedFromOriginal.');

                    // value validationresult?
                    assert.strictEqual(validatedEntity.prop('bigDecimalProp').validationResult(), null, 'Instance meta-prop should have empty (successful) validation result.');

                    // binding value ok?
                    assert.ok(bindingEntity.get('bigDecimalProp'), 'Binding property should be initialised.');
                    assert.strictEqual(bindingEntity.get('bigDecimalProp'), 46.5, 'Property value should be correct.');

                    done();
                };

                master.postRetrieved = function(entity, bindingEntity, customObject) {
                    // value ok?
                    assert.ok(entity.get('bigDecimalProp'), 'Property value should be initialised.');
                    assert.strictEqual(entity.get('bigDecimalProp'), 23.0, 'Property value should be correct.');

                    // value is changed?
                    assert.strictEqual(entity.prop('bigDecimalProp').isChangedFromOriginal(), false, 'Instance meta-prop should be not changedFromOriginal.');

                    // value validationresult?
                    assert.strictEqual(entity.prop('bigDecimalProp').validationResult(), null, 'Instance meta-prop should have empty (successful) validation result.');

                    // binding value ok?
                    assert.ok(bindingEntity.get('bigDecimalProp'), 'Binding property should be initialised.');
                    assert.strictEqual(bindingEntity.get('bigDecimalProp'), 23.0, 'Property value should be correct.');
                    
                    // ACTUAL PROPERTY CHANGE
                    bindingEntity.setAndRegisterPropertyTouch('bigDecimalProp', 46.5);

                    master.validate();
                };

                master.retrieve();
            });
            
            test('works for boolean property', function (done) {
                master.entityId = '11';
                
                master.postValidated = function(validatedEntity, bindingEntity, customObject) {
                    // value ok?
                    assert.strictEqual(validatedEntity.get('booleanProp'), false, 'Property value should be correct.');

                    // value is changed?
                    assert.strictEqual(validatedEntity.prop('booleanProp').isChangedFromOriginal(), true, 'Instance meta-prop should be changedFromOriginal.');

                    // value validationresult?
                    assert.strictEqual(validatedEntity.prop('booleanProp').validationResult(), null, 'Instance meta-prop should have empty (successful) validation result.');

                    // binding value ok?
                    assert.strictEqual(bindingEntity.get('booleanProp'), false, 'Binding property should be correct number.');

                    done();
                };

                master.postRetrieved = function(entity, bindingEntity, customObject) {
                    // value ok?
                    assert.ok(entity.get('booleanProp'), 'Property value should be initialised.');
                    assert.strictEqual(entity.get('booleanProp'), true, 'Property value should be correct.');

                    // value is changed?
                    assert.strictEqual(entity.prop('booleanProp').isChangedFromOriginal(), false, 'Instance meta-prop should be not changedFromOriginal.');

                    // value validationresult?
                    assert.strictEqual(entity.prop('booleanProp').validationResult(), null, 'Instance meta-prop should have empty (successful) validation result.');

                    // binding value ok?
                    assert.ok(bindingEntity.get('booleanProp'), 'Binding property should be initialised.');
                    assert.strictEqual(bindingEntity.get('booleanProp'), true, 'Binding property should be string entity representation.');
                    
                    // ACTUAL PROPERTY CHANGE
                    bindingEntity.setAndRegisterPropertyTouch('booleanProp', false);

                    master.validate();
                };

                master.retrieve();
            });
            
            test('works for date property', function (done) {
                master.entityId = '12';
                
                master.postValidated = function(validatedEntity, bindingEntity, customObject) {
                    // value ok?
                    assert.ok(validatedEntity.get('dateProp'), 'Property value should be initialised.');
                    assert.strictEqual(validatedEntity.get('dateProp'), 10000, 'Property value should be correct.');

                    // value is changed?
                    assert.strictEqual(validatedEntity.prop('dateProp').isChangedFromOriginal(), true, 'Instance meta-prop should be changedFromOriginal.');

                    // value validationresult?
                    assert.strictEqual(validatedEntity.prop('dateProp').validationResult(), null, 'Instance meta-prop should have empty (successful) validation result.');

                    // binding value ok?
                    assert.ok(bindingEntity.get('dateProp'), 'Binding property should be initialised.');
                    assert.strictEqual(bindingEntity.get('dateProp'), 10000, 'Binding property should be correct number.');

                    done();
                };

                master.postRetrieved = function(entity, bindingEntity, customObject) {
                    // value ok?
                    assert.ok(entity.get('dateProp'), 'Property value should be initialised.');
                    assert.strictEqual(entity.get('dateProp'), 3609999, 'Property value should be correct.');

                    // value is changed?
                    assert.strictEqual(entity.prop('dateProp').isChangedFromOriginal(), false, 'Instance meta-prop should be not changedFromOriginal.');

                    // value validationresult?
                    assert.strictEqual(entity.prop('dateProp').validationResult(), null, 'Instance meta-prop should have empty (successful) validation result.');

                    // binding value ok?
                    assert.ok(bindingEntity.get('dateProp'), 'Binding property should be initialised.');
                    assert.strictEqual(bindingEntity.get('dateProp'), 3609999, 'Binding property should be string entity representation.');
                    
                    // ACTUAL PROPERTY CHANGE
                    bindingEntity.setAndRegisterPropertyTouch('dateProp', 10000);

                    master.validate();
                };

                master.retrieve();
            });
            
            test('works for entity property', function (done) {
                master.entityId = '6';
                
                master.postValidated = function(validatedEntity, bindingEntity, customObject) {
                    // value ok?
                    assert.ok(validatedEntity.get('entityProp'), 'The property should be initialised.');
                    assert.instanceOf(validatedEntity.get('entityProp'), reflector.getEntityPrototype(), 'The property should be of entity type.');
                    assert.strictEqual(validatedEntity.get('entityProp').get('key'), 'KEY1', 'The entity response property should be entity instance with appropriate key (validate).');

                    // value is changed?
                    assert.strictEqual(validatedEntity.prop('entityProp').isChangedFromOriginal(), true, 'Instance meta-prop should be changedFromOriginal.');

                    // value validationresult?
                    assert.ok(validatedEntity.prop('entityProp').validationResult(), 'Instance meta-prop should have non-empty (warning) validation result.');
                    assert.strictEqual(validatedEntity.prop('entityProp').validationResult()['@resultType'], 'ua.com.fielden.platform.error.Warning');
                    assert.strictEqual(validatedEntity.prop('entityProp').validationResult().message, "Validator: value with bool prop 'false'.");

                    // binding value ok?
                    assert.ok(bindingEntity.get('entityProp'), 'Binding property should be initialised.');
                    assert.strictEqual(bindingEntity.get('entityProp'), 'KEY1', 'Binding property should be string entity representation.');

                    done();
                };

                master.postRetrieved = function(entity, bindingEntity, customObject) {
                    // value ok?
                    assert.ok(entity.get('entityProp'), 'The property should be initialised.');
                    assert.instanceOf(entity.get('entityProp'), reflector.getEntityPrototype(), 'The property should be of entity type.');
                    assert.strictEqual(entity.get('entityProp').get('key'), 'KEY3', 'The entity response property should be entity instance with appropriate key (retrieve).');

                    // value is changed?
                    assert.strictEqual(entity.prop('entityProp').isChangedFromOriginal(), false, 'Instance meta-prop should be not changedFromOriginal.');

                    // value validationresult?
                    assert.ok(entity.prop('entityProp').validationResult(), 'Instance meta-prop should have non-empty (informative) validation result.');
                    assert.strictEqual(entity.prop('entityProp').validationResult()['@resultType'], 'ua.com.fielden.platform.error.Informative');
                    assert.strictEqual(entity.prop('entityProp').validationResult().message, "Definer: value with bool prop 'false'.");

                    // binding value ok?
                    assert.ok(bindingEntity.get('entityProp'), 'Binding property should be initialised.');
                    assert.strictEqual(bindingEntity.get('entityProp'), 'KEY3', 'Binding property should be string entity representation.');

                    
                    // ACTUAL PROPERTY CHANGE
                    bindingEntity.setAndRegisterPropertyTouch('entityProp', 'KEY1');

                    master.validate();
                };

                master.retrieve();
            });
            
            test('works for money property', function (done) {
                master.entityId = '8';
                // TODO at this stage whatever currency is used for setting into binding entity (to be saved), retrieval from database 
                //      will return money instances with the currency, that is currently used in your OS.
                // Please, adjust the currency to be the same as in your OS to make this test happy.
                // #486 TODO var expectedCurrency = 'USD'; // 'AUD'
                
                master.postValidated = function(validatedEntity, bindingEntity, customObject) {
                    // value ok?
                    assert.ok(validatedEntity.get('moneyProp'), 'Property value should be initialised.');
                    assert.strictEqual(validatedEntity.get('moneyProp').amount, 46.0, 'Property value amount should be correct.');
                    // #486 TODO assert.strictEqual(validatedEntity.get('moneyProp').currency, expectedCurrency, 'Property value currency should be correct.');
                    assert.strictEqual(validatedEntity.get('moneyProp').taxPercent, 20, 'Property value taxPercent should be correct.');

                    // value is changed?
                    assert.strictEqual(validatedEntity.prop('moneyProp').isChangedFromOriginal(), true, 'Instance meta-prop should be changedFromOriginal.');

                    // value validationresult?
                    assert.strictEqual(validatedEntity.prop('moneyProp').validationResult(), null, 'Instance meta-prop should have empty (successful) validation result.');

                    // binding value ok?
                    assert.ok(bindingEntity.get('moneyProp'), 'Binding property should be initialised.');
                    assert.strictEqual(bindingEntity.get('moneyProp').amount, 46.0, 'Property value amount should be correct.');
                    // #486 TODO assert.strictEqual(bindingEntity.get('moneyProp').currency, expectedCurrency, 'Property value currency should be correct.');
                    assert.strictEqual(bindingEntity.get('moneyProp').taxPercent, 20, 'Property value taxPercent should be correct.');

                    done();
                };

                master.postRetrieved = function(entity, bindingEntity, customObject) {
                    // value ok?
                    assert.ok(entity.get('moneyProp'), 'Property value should be initialised.');
                    assert.strictEqual(entity.get('moneyProp').amount, 23.0, 'Property value amount should be correct.');
                    // #486 TODO assert.strictEqual(entity.get('moneyProp').currency, expectedCurrency, 'Property value currency should be correct.');
                    assert.strictEqual(entity.get('moneyProp').taxPercent, null, 'Property value taxPercent should be correct.');

                    // value is changed?
                    assert.strictEqual(entity.prop('moneyProp').isChangedFromOriginal(), false, 'Instance meta-prop should be not changedFromOriginal.');

                    // value validationresult?
                    assert.strictEqual(entity.prop('moneyProp').validationResult(), null, 'Instance meta-prop should have empty (successful) validation result.');

                    // binding value ok?
                    assert.ok(bindingEntity.get('moneyProp'), 'Binding property should be initialised.');
                    assert.strictEqual(bindingEntity.get('moneyProp').amount, 23.0, 'Property value amount should be correct.');
                    // #486 TODO assert.strictEqual(bindingEntity.get('moneyProp').currency, expectedCurrency, 'Property value currency should be correct.');
                    assert.strictEqual(bindingEntity.get('moneyProp').taxPercent, null, 'Property value taxPercent should be correct.');
                    
                    // ACTUAL PROPERTY CHANGE
                    bindingEntity.setAndRegisterPropertyTouch('moneyProp', { 'amount' : 46.0, 'taxPercent' : 20 }); // #486 TODO 'currency' : expectedCurrency, 

                    master.validate();
                };

                master.retrieve();
            });
            
            test('works for string property', function (done) {
                master.entityId = '10';
                
                master.postValidated = function(validatedEntity, bindingEntity, customObject) {
                    // value ok?
                    assert.ok(validatedEntity.get('stringProp'), 'Property value should be initialised.');
                    assert.strictEqual(validatedEntity.get('stringProp'), 'okok', 'Property value should be correct.');

                    // value is changed?
                    assert.strictEqual(validatedEntity.prop('stringProp').isChangedFromOriginal(), true, 'Instance meta-prop should be changedFromOriginal.');

                    // value validationresult?
                    assert.strictEqual(validatedEntity.prop('stringProp').validationResult(), null, 'Instance meta-prop should have empty (successful) validation result.');

                    // binding value ok?
                    assert.ok(bindingEntity.get('stringProp'), 'Binding property should be initialised.');
                    assert.strictEqual(bindingEntity.get('stringProp'), 'okok', 'Binding property should be correct number.');

                    done();
                };

                master.postRetrieved = function(entity, bindingEntity, customObject) {
                    // value ok?
                    assert.ok(entity.get('stringProp'), 'Property value should be initialised.');
                    assert.strictEqual(entity.get('stringProp'), 'ok', 'Property value should be correct.');

                    // value is changed?
                    assert.strictEqual(entity.prop('stringProp').isChangedFromOriginal(), false, 'Instance meta-prop should be not changedFromOriginal.');

                    // value validationresult?
                    assert.strictEqual(entity.prop('stringProp').validationResult(), null, 'Instance meta-prop should have empty (successful) validation result.');

                    // binding value ok?
                    assert.ok(bindingEntity.get('stringProp'), 'Binding property should be initialised.');
                    assert.strictEqual(bindingEntity.get('stringProp'), 'ok', 'Binding property should be string entity representation.');
                    
                    // ACTUAL PROPERTY CHANGE
                    bindingEntity.setAndRegisterPropertyTouch('stringProp', 'okok');

                    master.validate();
                };

                master.retrieve();
            });
            
            test('works for uppercased property editor', function (done) {
                master.entityId = '10';
                const edProperty = master.$.editor_4_stringProp;
                
                master.postValidated = function(validatedEntity, bindingEntity, customObject) {
                    // value ok?
                    assert.ok(validatedEntity.get('stringProp'), 'Property value should be initialised.');
                    assert.strictEqual(validatedEntity.get('stringProp'), 'OKOK', 'Property value should be uppercased for @UpperCase property.');

                    // binding value ok?
                    assert.ok(bindingEntity.get('stringProp'), 'Binding property should be initialised.');
                    assert.strictEqual(bindingEntity.get('stringProp'), 'OKOK', 'Binding property value should be uppercased for @UpperCase property.');

                    done();
                };

                master.postRetrieved = function(entity, bindingEntity, customObject) {
                    // value ok?
                    assert.ok(entity.get('stringProp'), 'Property value should be initialised.');
                    assert.strictEqual(entity.get('stringProp'), 'ok', 'Property value should be correct.');

                    // binding value ok?
                    assert.ok(bindingEntity.get('stringProp'), 'Binding property should be initialised.');
                    assert.strictEqual(bindingEntity.get('stringProp'), 'ok', 'Binding property should be string entity representation.');
                    
                    // ACTUAL PROPERTY CHANGE
                    // intentionally set lowercased value to check whether the result will be uppercased
                    edProperty._editingValue = 'okOk';
                    edProperty.commit();
                };

                master.retrieve();
            });
            
            test('works for any property for new entity', function (done) {
                master.postValidated = function(validatedEntity, bindingEntity, customObject) {
                    assert.strictEqual(validatedEntity.get('id'), null, 'The id of entity is not correct.');
                    // value ok?
                    assert.ok(validatedEntity.get('stringProp'), 'Property value should be initialised.');
                    assert.strictEqual(validatedEntity.get('stringProp'), 'okok', 'Property value should be correct.');

                    // value is changed?
                    assert.strictEqual(validatedEntity.prop('stringProp').isChangedFromOriginal(), true, 'Instance meta-prop should be changedFromOriginal.');

                    // value validationresult?
                    assert.strictEqual(validatedEntity.prop('stringProp').validationResult(), null, 'Instance meta-prop should have empty (successful) validation result.');

                    // binding value ok?
                    assert.ok(bindingEntity.get('stringProp'), 'Binding property should be initialised.');
                    assert.strictEqual(bindingEntity.get('stringProp'), 'okok', 'Binding property should be correct number.');

                    done();
                };

                master.postRetrieved = function(entity, bindingEntity, customObject) {
                    assert.strictEqual(entity.get('id'), null, 'The id of entity is not correct.');

                    // value ok?
                    assert.strictEqual(entity.get('stringProp'), null, 'Property value should be correct.');

                    // value is changed?
                    assert.strictEqual(entity.prop('stringProp').isChangedFromOriginal(), false, 'Instance meta-prop should be not changedFromOriginal.');

                    // value validationresult?
                    assert.strictEqual(entity.prop('stringProp').validationResult(), null, 'Instance meta-prop should have empty (successful) validation result.');

                    // binding value ok?
                    assert.strictEqual(bindingEntity.get('stringProp'), null, 'Binding property should be string entity representation.');
                    
                    // ACTUAL PROPERTY CHANGE
                    bindingEntity.setAndRegisterPropertyTouch('stringProp', 'okok');

                    master.validate();
                };

                master.retrieve();
            });
            
            test('works for any property into missing value', function (done) {
                master.entityId = '12';
                
                master.postValidated = function(validatedEntity, bindingEntity, customObject) {
                    // value ok?
                    assert.strictEqual(validatedEntity.get('dateProp'), null, 'Property value should be correct.');

                    // value is changed?
                    assert.strictEqual(validatedEntity.prop('dateProp').isChangedFromOriginal(), true, 'Instance meta-prop should be changedFromOriginal.');

                    // value validationresult?
                    assert.strictEqual(validatedEntity.prop('dateProp').validationResult(), null, 'Instance meta-prop should have empty (successful) validation result.');

                    // binding value ok?
                    assert.strictEqual(bindingEntity.get('dateProp'), null, 'Binding property should be correct number.');

                    done();
                };

                master.postRetrieved = function(entity, bindingEntity, customObject) {
                    // value ok?
                    assert.ok(entity.get('dateProp'), 'Property value should be initialised.');
                    assert.strictEqual(entity.get('dateProp'), 3609999, 'Property value should be correct.');

                    // value is changed?
                    assert.strictEqual(entity.prop('dateProp').isChangedFromOriginal(), false, 'Instance meta-prop should be not changedFromOriginal.');

                    // value validationresult?
                    assert.strictEqual(entity.prop('dateProp').validationResult(), null, 'Instance meta-prop should have empty (successful) validation result.');

                    // binding value ok?
                    assert.ok(bindingEntity.get('dateProp'), 'Binding property should be initialised.');
                    assert.strictEqual(bindingEntity.get('dateProp'), 3609999, 'Binding property should be string entity representation.');
                    
                    // ACTUAL PROPERTY CHANGE
                    bindingEntity.setAndRegisterPropertyTouch('dateProp', null);

                    master.validate();
                };

                master.retrieve();
            });
            
            test('works for any property simultaneously', function (done) {
                master.entityId = '10';
                
                let postValidatedCount = 0;

                master.postValidated = function(validatedEntity, bindingEntity, customObject) {
                    postValidatedCount = postValidatedCount + 1;
                    if (postValidatedCount > 2) {
                        assert.fail('', '', 'The validation should occur only twice.')
                    }

                    if (postValidatedCount === 1) {
                        // value ok?
                        assert.ok(validatedEntity.get('stringProp'), 'Property value should be initialised.');
                        assert.strictEqual(validatedEntity.get('stringProp'), '6', 'Property value should be correct.');
    
                        // value is changed?
                        assert.strictEqual(validatedEntity.prop('stringProp').isChangedFromOriginal(), true, 'Instance meta-prop should be changedFromOriginal.');
    
                        // value validationresult?
                        assert.strictEqual(validatedEntity.prop('stringProp').validationResult(), null, 'Instance meta-prop should have empty (successful) validation result.');
    
                        // binding value ok?
                        assert.ok(bindingEntity.get('stringProp'), 'Binding property should be initialised.');
                        assert.strictEqual(bindingEntity.get('stringProp'), '6', 'Binding property should be correct number.');
                    } else if (postValidatedCount === 2) {
                        // value ok?
                        assert.ok(validatedEntity.get('stringProp'), 'Property value should be initialised.');
                        assert.strictEqual(validatedEntity.get('stringProp'), '5', 'Property value should be correct.');
    
                        // value is changed?
                        assert.strictEqual(validatedEntity.prop('stringProp').isChangedFromOriginal(), true, 'Instance meta-prop should be changedFromOriginal.');
    
                        // value validationresult?
                        assert.strictEqual(validatedEntity.prop('stringProp').validationResult(), null, 'Instance meta-prop should have empty (successful) validation result.');
    
                        // binding value ok?
                        assert.ok(bindingEntity.get('stringProp'), 'Binding property should be initialised.');
                        assert.strictEqual(bindingEntity.get('stringProp'), '5', 'Binding property should be correct number.');
    
                        done();
                    }
                };

                master.postRetrieved = function(entity, bindingEntity, customObject) {
                    // value ok?
                    assert.ok(entity.get('stringProp'), 'Property value should be initialised.');
                    assert.strictEqual(entity.get('stringProp'), 'ok', 'Property value should be correct.');

                    // value is changed?
                    assert.strictEqual(entity.prop('stringProp').isChangedFromOriginal(), false, 'Instance meta-prop should be not changedFromOriginal.');

                    // value validationresult?
                    assert.strictEqual(entity.prop('stringProp').validationResult(), null, 'Instance meta-prop should have empty (successful) validation result.');

                    // binding value ok?
                    assert.ok(bindingEntity.get('stringProp'), 'Binding property should be initialised.');
                    assert.strictEqual(bindingEntity.get('stringProp'), 'ok', 'Binding property should be string entity representation.');
                    
                    // ACTUAL PROPERTY CHANGE   
                    bindingEntity.setAndRegisterPropertyTouch('stringProp', '1');
                    master.validate();

                    // ACTUAL PROPERTY CHANGE
                    bindingEntity.setAndRegisterPropertyTouch('stringProp', '2');
                    master.validate();

                    // ACTUAL PROPERTY CHANGE
                    bindingEntity.setAndRegisterPropertyTouch('stringProp', '3');
                    master.validate();

                    // ACTUAL PROPERTY CHANGE
                    bindingEntity.setAndRegisterPropertyTouch('stringProp', '4');
                    master.validate();

                    // Please not the use of "master._currBindingEntity" instead of "bindingEntity". This is important as it is expected that "bindingEntity" will be different at the time setting value "5" due to a validation roundtrip.
                    // Success of this change depends on the timing and may very between executions.
                    // This has to do with the fact that the delay of 100 millis may pass faster than the roundtrip of setting property to value "6" below.
                    // Therefore, if this tests keeps on failing, simply increase the delay and try again.
                    master.async(() => {
                        // ACTUAL PROPERTY CHANGE
                        console.log('	change to 5');
                        master._currBindingEntity.setAndRegisterPropertyTouch('stringProp', '5');
                        master.validate();
                    }, 200);

                    // ACTUAL PROPERTY CHANGE
                    console.log('	change to 6');
                    bindingEntity.setAndRegisterPropertyTouch('stringProp', '6');
                    master.validate();
                };

                master.retrieve();
            });
        });
        
        suite('saving', function() {
            let master, reflector;
        
            setup(function() {
                master = fixture('MasterFixture');
                  reflector = document.querySelector('#reflector');
            });
            
            test('works for new entity', function (done) {
                master.postSaved = function(potentiallySavedOrNewEntity, bindingEntity) {
                    assert.isNotNull(potentiallySavedOrNewEntity.get('id'), 'Entity id should be not null.');
                    assert.strictEqual(potentiallySavedOrNewEntity.version, 0, 'Entity version should be the same.');
                 
                    // value ok?
                    assert.ok(potentiallySavedOrNewEntity.get('stringProp'), 'Property value should be initialised.');
                    assert.strictEqual(potentiallySavedOrNewEntity.get('stringProp'), 'okok', 'Property value should be correct.');

                    // value is changed?
                    assert.strictEqual(potentiallySavedOrNewEntity.prop('stringProp').isChangedFromOriginal(), false, 'Instance meta-prop should be changedFromOriginal.');

                    // value validationresult?
                    assert.strictEqual(potentiallySavedOrNewEntity.prop('stringProp').validationResult(), null, 'Instance meta-prop should have empty (successful) validation result.');

                    // binding value ok?
                    assert.ok(bindingEntity.get('stringProp'), 'Binding property should be initialised.');
                    assert.strictEqual(bindingEntity.get('stringProp'), 'okok', 'Binding property should be correct number.');

                    done();
                };

                master.postRetrieved = function(entity, bindingEntity, customObject) {
                    assert.strictEqual(entity.get('id'), null, 'Entity id should be null.');
                    assert.strictEqual(entity.version, 0, 'Entity version should be initial.');
                    // value ok?
                    assert.strictEqual(entity.get('stringProp'), null, 'Property value should be correct.');

                    // value is changed?
                    assert.strictEqual(entity.prop('stringProp').isChangedFromOriginal(), false, 'Instance meta-prop should be not changedFromOriginal.');

                    // value validationresult?
                    assert.strictEqual(entity.prop('stringProp').validationResult(), null, 'Instance meta-prop should have empty (successful) validation result.');

                    // binding value ok?
                    assert.strictEqual(bindingEntity.get('stringProp'), null, 'Binding property should be string entity representation.');
                    
                    // ACTUAL PROPERTY CHANGE            
                    bindingEntity.setAndRegisterPropertyTouch('requiredValidatedProp', 30);
                    bindingEntity.setAndRegisterPropertyTouch('key', 'KEY_TO_PASS_VALIDATION_BEFORE_SAVE_' + (new Date()).getTime());
                    bindingEntity.setAndRegisterPropertyTouch('stringProp', 'okok');

                    master.save();
                };

                master.retrieve();
            });
            
            test('works for new entity with validation result thrown in CommonEntityDao save method', function (done) {
                master.postValidated = function(validatedEntity, bindingEntity, customObject) {
                    // validation process is legal -- it is not discarded, but saving is chained on top of last validation promise
                    // see issue https://github.com/fieldenms/tg/issues/479
                    const saveButton = master.shadowRoot.querySelector('tg-action[role="save"]');
                    saveButton._asyncRun();
                };
                
                master.postSaved = function (potentiallySavedOrNewEntity, bindingEntity) {
                    assert.isNull(potentiallySavedOrNewEntity.get('id'), 'Entity id should be null.');
                    assert.strictEqual(potentiallySavedOrNewEntity.version, 0, 'Entity version should be the same.');
                    
                    assert.isNotNull(potentiallySavedOrNewEntity.exceptionOccurred(), 'Entity\'s exceptionOccurred should exist.');
                    assert.strictEqual(potentiallySavedOrNewEntity.exceptionOccurred().message, '[1/2/3 6:19] is not acceptable.', 'Entity\'s exceptionOccurred should exist.');
                    
                    const arrivedValue = null;
                    
                    // value ok?
                    assert.notOk(potentiallySavedOrNewEntity.get('dateProp'), 'Property value should be initialised.');
                    assert.strictEqual(potentiallySavedOrNewEntity.get('dateProp'), arrivedValue, 'Property value should be correct.');
                    
                    // value is changed?
                    assert.strictEqual(potentiallySavedOrNewEntity.prop('dateProp').isChangedFromOriginal(), false, 'Instance meta-prop should be not changedFromOriginal.');
                    
                    // value validationresult?
                    assert.isNotNull(potentiallySavedOrNewEntity.prop('dateProp').validationResult(), 'Instance meta-prop should have empty (successful) validation result.');
                    
                    assert.ok(potentiallySavedOrNewEntity.prop('dateProp').validationResult(), 'Instance meta-prop should have non-empty (unsuccessful) validation result.');
                    assert.strictEqual(potentiallySavedOrNewEntity.prop('dateProp').validationResult()['@resultType'], 'ua.com.fielden.platform.error.Result');
                    assert.strictEqual(potentiallySavedOrNewEntity.prop('dateProp').validationResult().message, '[1/2/3 6:19] is not acceptable.');
                    
                    // _editingValue ok?
                    assert.strictEqual(master.$.editor_4_dateProp._editingValue, '01/02/2003 06:19', 'Editing value should correspond to invalid value [01/02/2003 06:19].');
                    // binding value ok?
                    assert.ok(bindingEntity.get('dateProp'), 'Binding property should be initialised.');
                    const invalidDateValue = _millis('01/02/2003 06:19:00.000');
                    assert.strictEqual(bindingEntity.get('dateProp'), invalidDateValue, 'Binding property should contain the invalid value that represents [1/2/3 6:19] date.');
                    
                    done();
                };
                
                master.postRetrieved = function(entity, bindingEntity, customObject) {
                    _editProperties(master, '1/2/3 6:19');
                };
                
                master.retrieve();
            });
            
            test('works for new entity with duplicate exception thrown in CommonEntityDao save method', function (done) {
                master.postValidated = function(validatedEntity, bindingEntity, customObject) {
                    // validation process is legal -- it is not discarded, but saving is chained on top of last validation promise
                    // see issue https://github.com/fieldenms/tg/issues/479
                    const saveButton = master.shadowRoot.querySelector('tg-action[role="save"]');
                    saveButton._asyncRun();
                };
                
                master.postSaved = function (potentiallySavedOrNewEntity, bindingEntity) {
                    assert.isNull(potentiallySavedOrNewEntity.get('id'), 'Entity id should be null.');
                    assert.strictEqual(potentiallySavedOrNewEntity.version, 0, 'Entity version should be the same.');
                    
                    assert.isNotNull(potentiallySavedOrNewEntity.exceptionOccurred(), 'Entity\'s exceptionOccurred should exist.');
                    assert.strictEqual(potentiallySavedOrNewEntity.exceptionOccurred().message, 'Tg Persistent Entity With Properties [DEMO00] already exists.', 'Entity\'s exceptionOccurred should exist.');
                    
                    const arrivedValue = _millis('01/02/2003 06:21:00.000');
                    
                    // value ok?
                    assert.ok(potentiallySavedOrNewEntity.get('dateProp'), 'Property value should be initialised.');
                    assert.strictEqual(potentiallySavedOrNewEntity.get('dateProp'), arrivedValue, 'Property value should be correct.');
                    
                    // value is changed?
                    assert.strictEqual(potentiallySavedOrNewEntity.prop('dateProp').isChangedFromOriginal(), true, 'Instance meta-prop should be changedFromOriginal.');
                    
                    // value validationresult?
                    assert.isNotNull(potentiallySavedOrNewEntity.prop('dateProp').validationResult(), 'Instance meta-prop should have non-empty warning result.');
                    
                    assert.ok(potentiallySavedOrNewEntity.prop('dateProp').validationResult(), 'Instance meta-prop should have non-empty warning result.');
                    assert.strictEqual(potentiallySavedOrNewEntity.prop('dateProp').validationResult()['@resultType'], 'ua.com.fielden.platform.error.Warning');
                    assert.strictEqual(potentiallySavedOrNewEntity.prop('dateProp').validationResult().message, '[1/2/3 6:21] is acceptable, but with warning.');
                    
                    // _editingValue ok?
                    assert.strictEqual(master.$.editor_4_dateProp._editingValue, '01/02/2003 06:21', 'Editing value should correspond to value [01/02/2003 06:21].');
                    // binding value ok?
                    assert.ok(bindingEntity.get('dateProp'), 'Binding property should be initialised.');
                    assert.strictEqual(bindingEntity.get('dateProp'), arrivedValue, 'Binding property should contain the value that represents [1/2/3 6:21] date.');
                    
                    done();
                };
                
                master.postRetrieved = function(entity, bindingEntity, customObject) {
                    _editProperties(master, '1/2/3 6:21', 'DEMO00');
                };
                
                master.retrieve();
            });
            
            test('works for new entity with exception thrown in companion save method', function (done) {
                master.postValidated = function(validatedEntity, bindingEntity, customObject) {
                    // validation process is legal -- it is not discarded, but saving is chained on top of last validation promise
                    // see issue https://github.com/fieldenms/tg/issues/479
                    const saveButton = master.shadowRoot.querySelector('tg-action[role="save"]');
                    saveButton._asyncRun();
                };
                
                master.postSaved = function (potentiallySavedOrNewEntity, bindingEntity) {
                    assert.isNull(potentiallySavedOrNewEntity.get('id'), 'Entity id should be null.');
                    assert.strictEqual(potentiallySavedOrNewEntity.version, 0, 'Entity version should be the same.');
                    
                    assert.isNotNull(potentiallySavedOrNewEntity.exceptionOccurred(), 'Entity\'s exceptionOccurred should exist.');
                    assert.strictEqual(potentiallySavedOrNewEntity.exceptionOccurred().message, 'Creation failed: [1/2/3 6:20] date is not permitted.', 'Entity\'s exceptionOccurred should exist.');
                    
                    const arrivedValue = _millis('01/02/2003 06:20:00.000');
                    
                    // value ok?
                    assert.ok(potentiallySavedOrNewEntity.get('dateProp'), 'Property value should be initialised.');
                    assert.strictEqual(potentiallySavedOrNewEntity.get('dateProp'), arrivedValue, 'Property value should be correct.');
                    
                    // value is changed?
                    assert.strictEqual(potentiallySavedOrNewEntity.prop('dateProp').isChangedFromOriginal(), true, 'Instance meta-prop should be changedFromOriginal.');
                    
                    // value validationresult?
                    assert.isNull(potentiallySavedOrNewEntity.prop('dateProp').validationResult(), 'Instance meta-prop should have empty (successful) validation result.');
                    
                    // _editingValue ok?
                    assert.strictEqual(master.$.editor_4_dateProp._editingValue, '01/02/2003 06:20', 'Editing value should correspond to valid value [01/02/2003 06:20].');
                    // binding value ok?
                    assert.ok(bindingEntity.get('dateProp'), 'Binding property should be initialised.');
                    assert.strictEqual(bindingEntity.get('dateProp'), arrivedValue, 'Binding property should contain the valid value that represents [1/2/3 6:20] date.');
                    
                    done();
                };
                
                master.postRetrieved = function(entity, bindingEntity, customObject) {
                    _editProperties(master, '1/2/3 6:20');
                };
                
                master.retrieve();
            });
            
            test('works for new entity with exception thrown in companion save method after super.save was successful', function (done) {
                master.postValidated = function(validatedEntity, bindingEntity, customObject) {
                    master.save().then(function () {
                        assert.isNull(master._currEntity.get('id'), 'Entity id should be null.');
                        assert.strictEqual(master._currEntity.version, 0, 'Entity version should be the same.');
                        assert.isNull(master._currBindingEntity.get('id'), 'Binding entity id should be null.');
                        assert.strictEqual(master._currBindingEntity.version, 0, 'Binding entity version should be the same.');
                        
                        const arrivedValue = _millis('01/02/2003 06:22:00.000');
                        
                        // value ok?
                        assert.ok(master._currEntity.get('dateProp'), 'Property value should be initialised.');
                        assert.strictEqual(master._currEntity.get('dateProp'), arrivedValue, 'Property value should be correct.');
                        
                        // value is changed?
                        assert.strictEqual(master._currEntity.prop('dateProp').isChangedFromOriginal(), true, 'Instance meta-prop should be changedFromOriginal.');
                        
                        // value validationresult?
                        assert.isNull(master._currEntity.prop('dateProp').validationResult(), 'Instance meta-prop should have empty (successful) validation result.');
                        
                        // _editingValue ok?
                        assert.strictEqual(master.$.editor_4_dateProp._editingValue, '01/02/2003 06:22', 'Editing value should correspond to valid value [01/02/2003 06:22].');
                        // binding value ok?
                        assert.ok(master._currBindingEntity.get('dateProp'), 'Binding property should be initialised.');
                        assert.strictEqual(master._currBindingEntity.get('dateProp'), arrivedValue, 'Binding property should contain the valid value that represents [1/2/3 6:22] date.');
                        
                        done();
                    });
                };
                
                master.postSaved = function (potentiallySavedOrNewEntity, bindingEntity) {
                    assert.isNull(potentiallySavedOrNewEntity.get('id'), 'Entity id should be null for new entity with failed save attempt.');
                    assert.strictEqual(potentiallySavedOrNewEntity.version, 0, 'Entity version should be the same.');
                    
                    assert.isNotNull(potentiallySavedOrNewEntity.exceptionOccurred(), 'Entity\'s exceptionOccurred should exist.');
                    assert.strictEqual(potentiallySavedOrNewEntity.exceptionOccurred().message, 'Creation failed: [1/2/3 6:22] date is not permitted.', 'Entity\'s exceptionOccurred should exist.');
                };
                
                master.postRetrieved = function(entity, bindingEntity, customObject) {
                    _editProperties(master, '1/2/3 6:22');
                };
                
                master.retrieve();
            });
            
            test('works for existing entity', function (done) {

                master.postSaved = function(potentiallySavedOrNewEntity, bindingEntity) {
                    assert.isNotNull(potentiallySavedOrNewEntity.get('id'), 'Entity id should be not null.');
                    assert.strictEqual(potentiallySavedOrNewEntity.version, 0, 'Entity version should be 0.');
             
                    // value ok?
                    assert.ok(potentiallySavedOrNewEntity.get('stringProp'), 'Property value should be initialised.');
                    assert.strictEqual(potentiallySavedOrNewEntity.get('stringProp'), 'ok', 'Property value should be correct.');

                    // value is changed?
                    assert.strictEqual(potentiallySavedOrNewEntity.prop('stringProp').isChangedFromOriginal(), false, 'Instance meta-prop should be changedFromOriginal.');

                    // value validationresult?
                    assert.strictEqual(potentiallySavedOrNewEntity.prop('stringProp').validationResult(), null, 'Instance meta-prop should have empty (successful) validation result.');

                    // binding value ok?
                    assert.ok(bindingEntity.get('stringProp'), 'Binding property should be initialised.');
                    assert.strictEqual(bindingEntity.get('stringProp'), 'ok', 'Binding property should be correct number.');

                    // ACTUAL PROPERTY CHANGE
                    bindingEntity.setAndRegisterPropertyTouch('stringProp', 'okok');
                    
                    // kick in the second save and thus the second part of this test 
                    this.postSaved = this.postSavedForExisting;
                    this.save();
                }.bind(master);
                
                master.postSavedForExisting = function (potentiallySavedOrNewEntity, bindingEntity) {
                    assert.isNotNull(potentiallySavedOrNewEntity.get('id'), 'Entity id should remain not null.');
                    assert.strictEqual(potentiallySavedOrNewEntity.version, 1, 'Entity version should be increased.');
             
                    // value ok?
                    assert.ok(potentiallySavedOrNewEntity.get('stringProp'), 'Property value should be initialised.');
                    assert.strictEqual(potentiallySavedOrNewEntity.get('stringProp'), 'okok', 'Property value should be correct.');

                    // value is changed?
                    assert.strictEqual(potentiallySavedOrNewEntity.prop('stringProp').isChangedFromOriginal(), false, 'Instance meta-prop should be changedFromOriginal.');

                    // value validationresult?
                    assert.strictEqual(potentiallySavedOrNewEntity.prop('stringProp').validationResult(), null, 'Instance meta-prop should have empty (successful) validation result.');

                    // binding value ok?
                    assert.ok(bindingEntity.get('stringProp'), 'Binding property should be initialised.');
                    assert.strictEqual(bindingEntity.get('stringProp'), 'okok', 'Binding property should be correct number.');

                    done();  
                }.bind(master);

                master.postRetrieved = function(entity, bindingEntity, customObject) {
                    // ACTUAL PROPERTY CHANGE
                    bindingEntity.setAndRegisterPropertyTouch('stringProp', 'ok');
                    bindingEntity.setAndRegisterPropertyTouch('requiredValidatedProp', 30);
                    bindingEntity.setAndRegisterPropertyTouch('key', 'KEY_' + (new Date()).getTime());

                    master.save();
                };

                master.retrieve();
            });
            
            test('works for existing entity after validation', function (done) {
                let postSavedFirst = true;

                master._postSaverLoadingFinished = function() {
                    if (postSavedFirst === true) {
                        postSavedFirst = false;
                        master.validate();
                    }
                };

                master.postSaved = function(potentiallySavedOrNewEntity, bindingEntity) {
                    assert.isNotNull(potentiallySavedOrNewEntity.get('id'), 'Entity id should be not null.');
                    assert.strictEqual(potentiallySavedOrNewEntity.version, 0, 'Entity version should be 0.');
             
                    // value ok?
                    assert.ok(potentiallySavedOrNewEntity.get('stringProp'), 'Property value should be initialised.');
                    assert.strictEqual(potentiallySavedOrNewEntity.get('stringProp'), 'ok', 'Property value should be correct.');

                    // value is changed?
                    assert.strictEqual(potentiallySavedOrNewEntity.prop('stringProp').isChangedFromOriginal(), false, 'Instance meta-prop should be changedFromOriginal.');

                    // value validationresult?
                    assert.strictEqual(potentiallySavedOrNewEntity.prop('stringProp').validationResult(), null, 'Instance meta-prop should have empty (successful) validation result.');

                    // binding value ok?
                    assert.ok(bindingEntity.get('stringProp'), 'Binding property should be initialised.');
                    assert.strictEqual(bindingEntity.get('stringProp'), 'ok', 'Binding property should be correct number.');

                    // ACTUAL PROPERTY CHANGE
                    bindingEntity.setAndRegisterPropertyTouch('stringProp', 'okok');
                    
                     // kick in validation and thus the second part of this test
                    this.postSaved = this.postSavedForExisting;
                    this.validate();
                }.bind(master);
                
                master.postSavedForExisting = function(potentiallySavedOrNewEntity, bindingEntity) {
                    assert.isNotNull(potentiallySavedOrNewEntity.get('id'), 'Entity id should remain not null.');
                    assert.strictEqual(potentiallySavedOrNewEntity.version, 1, 'Entity version should be increased.');
             
                    // value ok?
                    assert.ok(potentiallySavedOrNewEntity.get('stringProp'), 'Property value should be initialised.');
                    assert.strictEqual(potentiallySavedOrNewEntity.get('stringProp'), 'okok', 'Property value should be correct.');

                    // value is changed?
                    assert.strictEqual(potentiallySavedOrNewEntity.prop('stringProp').isChangedFromOriginal(), false, 'Instance meta-prop should be changedFromOriginal.');

                    // value validationresult?
                    assert.strictEqual(potentiallySavedOrNewEntity.prop('stringProp').validationResult(), null, 'Instance meta-prop should have empty (successful) validation result.');

                    // binding value ok?
                    assert.ok(bindingEntity.get('stringProp'), 'Binding property should be initialised.');
                    assert.strictEqual(bindingEntity.get('stringProp'), 'okok', 'Binding property should be correct number.');

                    done();  
                }.bind(master);

                master.postValidated = function(validatedEntity, newBindingEntity, customObject) {
                    assert.isNotNull(validatedEntity.get('id'), 'Entity id should be not null.');
                    assert.strictEqual(validatedEntity.version, 0, 'Entity version should be 0.');
             
                    // value ok?
                    assert.ok(validatedEntity.get('stringProp'), 'Property value should be initialised.');
                    assert.strictEqual(validatedEntity.get('stringProp'), 'okok', 'Property value should be correct.');

                    // value is changed?
                    assert.strictEqual(validatedEntity.prop('stringProp').isChangedFromOriginal(), true, 'Instance meta-prop should be changedFromOriginal.');

                    // value validationresult?
                    assert.strictEqual(validatedEntity.prop('stringProp').validationResult(), null, 'Instance meta-prop should have empty (successful) validation result.');

                    // binding value ok?
                    assert.ok(newBindingEntity.get('stringProp'), 'Binding property should be initialised.');
                    assert.strictEqual(newBindingEntity.get('stringProp'), 'okok', 'Binding property should be correct.');
                    
                    master.save();
                };

                master.postRetrieved = function(entity, bindingEntity, customObject) {
                    // ACTUAL PROPERTY CHANGE
                    bindingEntity.setAndRegisterPropertyTouch('stringProp', 'ok');
                    bindingEntity.setAndRegisterPropertyTouch('requiredValidatedProp', 30);
                    bindingEntity.setAndRegisterPropertyTouch('key', 'KEY_' + (new Date()).getTime());

                    master.save();
                };

                master.retrieve();
            });
            
            test('works for existing entity with exception thrown in companion save method', function (done) {
                let firstValidation = true;
                master.postValidated = function (validatedEntity, bindingEntity, customObject) {
                    // validation process is legal -- it is not discarded, but saving is chained on top of last validation promise
                    // see issue https://github.com/fieldenms/tg/issues/479
                    const saveButton = master.shadowRoot.querySelector('tg-action[role="save"]');
                    if (firstValidation) {
                        saveButton._asyncRun();
                        firstValidation = false;
                    } else {
                        this.async(function () {
                            // need to place this on top of JS execution stack after save button enablement logic
                            saveButton._asyncRun();
                        }, 1);
                    }
                };
                
                master.postSaved = function (potentiallySavedOrNewEntity, bindingEntity) {
                    master.$.editor_4_dateProp._editingValue = '1/2/3 6:22';
                    master.$.editor_4_dateProp.commit();
                    
                    // kick in the second save and thus the second part of this test 
                    this.postSaved = this.postSavedForExisting;
                }.bind(master);
                
                master.postSavedForExisting = function (potentiallySavedOrNewEntity, bindingEntity) {
                    assert.isNotNull(potentiallySavedOrNewEntity.get('id'), 'Entity id should be not null.');
                    
                    assert.isNotNull(potentiallySavedOrNewEntity.exceptionOccurred(), 'Entity\'s exceptionOccurred should exist.');
                    assert.strictEqual(potentiallySavedOrNewEntity.exceptionOccurred().message, 'Modification failed: [1/2/3 6:22] is not acceptable for persisted entity.', 'Entity\'s exceptionOccurred should exist.');
                    
                    const arrivedValue = _millis('01/02/2003 00:00:00.000');
                    
                    // value ok?
                    assert.ok(potentiallySavedOrNewEntity.get('dateProp'), 'Property value should be initialised.');
                    assert.strictEqual(potentiallySavedOrNewEntity.get('dateProp'), arrivedValue, 'Property value should be correct.');
                    
                    // value is changed?
                    assert.strictEqual(potentiallySavedOrNewEntity.prop('dateProp').isChangedFromOriginal(), false, 'Instance meta-prop should be not changedFromOriginal.');
                    
                    // value validationresult?
                    assert.isNotNull(potentiallySavedOrNewEntity.prop('dateProp').validationResult(), 'Instance meta-prop should have empty (successful) validation result.');
                    
                    assert.ok(potentiallySavedOrNewEntity.prop('dateProp').validationResult(), 'Instance meta-prop should have non-empty (unsuccessful) validation result.');
                    assert.strictEqual(potentiallySavedOrNewEntity.prop('dateProp').validationResult()['@resultType'], 'ua.com.fielden.platform.error.Result');
                    assert.strictEqual(potentiallySavedOrNewEntity.prop('dateProp').validationResult().message, '[1/2/3 6:22] is not acceptable for persisted entity.');
                    
                    // _editingValue ok?
                    assert.strictEqual(master.$.editor_4_dateProp._editingValue, '01/02/2003 06:22', 'Editing value should correspond to invalid value [01/02/2003 06:22].');
                    // binding value ok?
                    assert.ok(bindingEntity.get('dateProp'), 'Binding property should be initialised.');
                    const invalidDateValue = _millis('01/02/2003 06:22:00.000');
                    assert.strictEqual(bindingEntity.get('dateProp'), invalidDateValue, 'Binding property should contain the invalid value that represents [1/2/3 6:22] date.');
                    
                    done();
                }.bind(master);
                
                master.postRetrieved = function (entity, bindingEntity, customObject) {
                    _editProperties(master, '1/2/3');
                };
                
                master.retrieve();
            });
            
            test('of an existing valid non-dirty entity simply returns the same entity back', function (done) {
                let firstValidation = true;
                let thirdValidation = false;
                master.postValidated = function (validatedEntity, bindingEntity, customObject) {
                    // validation process is legal -- it is not discarded, but saving is chained on top of last validation promise
                    // see issue https://github.com/fieldenms/tg/issues/479
                    const saveButton = master.$._saveAction;
                    if (firstValidation) {
                        saveButton._asyncRun();
                        firstValidation = false;
                    } else if (!firstValidation && !thirdValidation) {
                        master.$.editor_4_dateProp._editingValue = '01/02/2003 00:00';
                        master.$.editor_4_dateProp.commit();
                        saveButton._asyncRun();
                        thirdValidation = true;
                    } 
                };
                
                master.postSaved = function (potentiallySavedOrNewEntity, bindingEntity) {
                    master.$.editor_4_dateProp._editingValue = '01/02/2004 00:00';
                    master.$.editor_4_dateProp.commit();
                    
                    // kick in the second save and thus the second part of this test 
                    this.postSaved = this.postSavedForExisting;
                }.bind(master);
                
                master.postSavedForExisting = function (potentiallySavedOrNewEntity, bindingEntity) {
                    assert.isNotNull(potentiallySavedOrNewEntity.get('id'), 'Entity id should be not null.');

                    assert.isNull(potentiallySavedOrNewEntity.exceptionOccurred(), 'No exception was expected when attempting to save not changed entity.');

                    const arrivedValue = _millis('01/02/2003 00:00:00.000');

                    // value ok?
                    assert.ok(potentiallySavedOrNewEntity.get('dateProp'), 'Property value should be initialised.');
                    assert.strictEqual(potentiallySavedOrNewEntity.get('dateProp'), arrivedValue, 'Property value should be correct.');
                    
                    // value is changed?
                    assert.strictEqual(potentiallySavedOrNewEntity.prop('dateProp').isChangedFromOriginal(), false, 'Instance meta-prop should be not changedFromOriginal.');
                    
                    // value validationresult?
                    assert.isNull(potentiallySavedOrNewEntity.prop('dateProp').validationResult(), 'Instance meta-prop should have empty (successful) validation result.');
                    
                    // _editingValue ok?
                    assert.strictEqual(master.$.editor_4_dateProp._editingValue, '01/02/2003 00:00', 'Editing value should correspond to valid value [01/02/2003 00:00].');
                    // binding value ok?
                    assert.ok(bindingEntity.get('dateProp'), 'Binding property should be initialised.');
                    const validDateValue = _millis('01/02/2003 00:00:00.000');
                    assert.strictEqual(bindingEntity.get('dateProp'), validDateValue, 'Binding property should contain valid value that represents [1/2/3 00:00] date.');
                    
                    done();
                }.bind(master);
                
                master.postRetrieved = function (entity, bindingEntity, customObject) {
                    _editProperties(master, '1/2/3');
                };
                
                master.retrieve();
            });
            
            test('works for multiple concurrent saving initiations', function (done) {
                let savingCount = 0;
                
                master.postSaved = (function (potentiallySavedOrNewEntity, bindingEntity) {
                    assert.isNotNull(potentiallySavedOrNewEntity.get('id'), 'Entity id should be not null.');
                    savingCount += 1;
                    
                    if (savingCount > 1) {
                        throw 'More than one (' + savingCount + ') saving request has been fulfilled.';
                    }
                }).bind(master);
                
                master.postRetrieved = function(entity, bindingEntity, customObject) {
                    // ACTUAL PROPERTY CHANGE
                    bindingEntity.setAndRegisterPropertyTouch('stringProp', 'ok');
                    bindingEntity.setAndRegisterPropertyTouch('requiredValidatedProp', 30);
                    bindingEntity.setAndRegisterPropertyTouch('key', 'KEY_' + (new Date()).getTime());
                    
                    master.save();
                    master.save();
                    master.save();
                    master.save();
                    master.save().then(function () {
                        done();
                    });
                };
                
                master.retrieve();
            });
            
            test('through ctrls works for the case with uncommitted value in focused editor, which gets committed automatically', function (done) {
                master.postSaved = (function (potentiallySavedOrNewEntity, bindingEntity) {
                    assert.isNotNull(potentiallySavedOrNewEntity.get('id'), 'Entity id should be not null.');
                    done();
                }).bind(master);
                
                master.postRetrieved = function(entity, bindingEntity, customObject) {
                    bindingEntity.setAndRegisterPropertyTouch('stringProp', 'ok');
                    bindingEntity.setAndRegisterPropertyTouch('requiredValidatedProp', 30);
                };
                
                master.retrieve().then(function () {
                    master.$.editor_4_key.$.input.focus();
                    master.$.editor_4_key._editingValue = 'KEY_' + (new Date()).getTime();
                    
                    const event = {
                        detail: {
                            combo: 'ctrl+s'
                        }
                    };
                    master.processShortcut(event, ['tg-action']);
                });
            });
            
            test('setEditorValue4Property method works', function (done) {
                master.postValidated = function (validatedEntity, bindingEntity, customObject) {
                    done();
                };
                master.retrieve().then(function () {
                    const funcEntity = reflector.newEntity('ua.com.fielden.platform.sample.domain.TgPersistentEntityWithProperties');
                    funcEntity.stringProp = 'TEST';
                    master.setEditorValue4Property('key', funcEntity, 'stringProp');
                });
            });
            
            test('setEditorValue4PropertyFromConcreteValue method works', function (done) {
                master.postValidated = function (validatedEntity, bindingEntity, customObject) {
                    done();
                };
                master.retrieve().then(function () {
                    master.setEditorValue4PropertyFromConcreteValue('key', 'TEST');
                });
            });

            test('BindSavedPropertyPostActionSuccess binds parent master with saved instance and updates property action indices', function (done) {
                master.entityId = '10';
                let validateCount = 0, saveCount = 0;
                let smallValue;

                const checkIndices = expectedBigDecimalPropIndex => {
                    assert.deepEqual(master._propertyActionIndices, {
                        "booleanProp": 0,
                        "compositeProp": 0,
                        "dateProp": 0,
                        "entityProp.entityProp": 0,
                        "bigDecimalProp": expectedBigDecimalPropIndex,
                        "requiredValidatedProp": 0,
                        "key": 0,
                        "status": 0,
                        "stringProp": 0,
                        "entityProp": 0
                    });
                };
                master.postSaved = function (potentiallySavedOrNewEntity, newBindingEntity) {
                    saveCount++;
                    if (saveCount === 1) {
                        checkIndices(smallValue ? 2 : 0); // III -- indices remained "as is" after Complete action binds entity in its BindSavedPropertyPostActionSuccess
                    } else if (saveCount === 2) {
                        checkIndices(smallValue ? 2 : 0); // V -- indices become 0 or 2 again after making entity not 'completed'
                        done();
                    }
                };
                master.postValidated = function (validatedEntity, bindingEntity, customObject) {
                    validateCount++;
                    if (validateCount === 1) {
                        checkIndices(smallValue ? 2 : 0); // II -- changed indices after first validation
                        const completeButton = master.shadowRoot.querySelector('tg-ui-action[short-desc="Complete"]'); // trigger Complete action
                        completeButton._run();
                    } else if (validateCount === 2) {
                        checkIndices(1); // IV -- indices get updated in parent master update from Complete action (see tg-ui-action._onExecuted.postSaved postal publish); 'completed' entity has index 1 (see BigDecimalPropActionSelector)
                        master.$.editor_4_completed._editingValue = 'false'; // change 'completed' back to 'false' ...
                        master.$.editor_4_completed.commit();
                        master.save(); // ... and save
                    }
                };
                master.retrieve().then(function () {
                    // at start, the entity is not 'completed' and bigDecimalProp will have value '12' (zero action index) or '25' (action index equal to 2)
                    smallValue = master.$.editor_4_bigDecimalProp._editingValue === '12';
                    checkIndices(smallValue ? 0 : 2);

                    master.$.editor_4_requiredValidatedProp._editingValue = '30';
                    master.$.editor_4_requiredValidatedProp.commit();
                    master.$.editor_4_bigDecimalProp._editingValue = smallValue ? '25' : '12'; // I -- change value to "opposite"
                    master.$.editor_4_bigDecimalProp.commit();
                });
            });

        });
    </script>
</body>

</html>