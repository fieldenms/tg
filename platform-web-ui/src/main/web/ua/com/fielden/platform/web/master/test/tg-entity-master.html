<!doctype html>
<html>

<head>
	<meta charset="UTF-8">
	<title>entity-master basic tests</title>
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">
	
	<script src="/resources/polymer/webcomponentsjs/webcomponents-lite.js"></script>
	<script src="/resources/polymer/web-component-tester/browser.js"></script>
	<script src="/resources/polymer/test-fixture/test-fixture-mocha.js"></script>
	<script src="/resources/polymer/iron-test-helpers/mock-interactions.js"></script>
	
	<link rel="import" href="/resources/polymer/test-fixture/test-fixture.html">
  
    <link rel="import" href="/app/tg-reflector.html">
    <link rel="import" href="/master_ui/ua.com.fielden.platform.sample.domain.TgPersistentEntityWithProperties"> <!-- Test_TgPersistentEntityWithProperties -->
</head>

<body>
	<tg-reflector id="reflector"></tg-reflector>
	<test-fixture id="MasterFixture">
    	<template>
   		    <tg-TgPersistentEntityWithProperties-master 
		    	id="master" 
		    	entity-type="ua.com.fielden.platform.sample.domain.TgPersistentEntityWithProperties" 
		    	entity-id="new" 
		    	current-state="EDIT">
    		</tg-TgPersistentEntityWithProperties-master>
    	</template>
	</test-fixture>

	<script>
        var _editProperties = function (master, datePropEditingValue, keyPropEditingValue) {
            master.$.editor_4_requiredValidatedProp._editingValue = '30';
            master.$.editor_4_requiredValidatedProp.commit();
            master.$.editor_4_key._editingValue = keyPropEditingValue ? keyPropEditingValue : 'key_to_pass_validation_before_save_' + (new Date()).getTime();
            master.$.editor_4_key.commit();
            master.$.editor_4_dateProp._editingValue = datePropEditingValue;
            master.$.editor_4_dateProp.commit();
        };
	
		suite('retrieval', function() {
		    var master, reflector;
		
		    setup(function() {
				master = fixture('MasterFixture');
		      	reflector = document.querySelector('#reflector');
		    });
		
		    test('works for new entity', function(done) {
				master.postRetrieved = function(entity, bindingEntity, customObject) {
				    assert.strictEqual(entity.type().fullClassName(), "ua.com.fielden.platform.sample.domain.TgPersistentEntityWithProperties", "The type of entity response is not correct.");
				    assert.strictEqual(entity.id, null, "The id of entity is not correct.");
				    assert.strictEqual(entity.version, 0, "The version of entity is not correct.");
				
				    // properties:
				    assert.strictEqual(typeof entity.get("integerProp"), "object", "The entity response property is not correct.");
				    assert.strictEqual(entity.get("integerProp"), null, "The entity response property is not correct.");
				
				    // IMPORTANT NOTE: regular properties are not proxied at this stage! So they are serialised...
				    // IMPORTANT NOTE: regular properties are not proxied at this stage! So they are serialised...
				    // IMPORTANT NOTE: regular properties are not proxied at this stage! So they are serialised...
				    // IMPORTANT NOTE: regular properties are not proxied at this stage! So they are serialised...
				    // IMPORTANT NOTE: regular properties are not proxied at this stage! So they are serialised...
				    // IMPORTANT NOTE: regular properties are not proxied at this stage! So they are serialised...
				    // IMPORTANT NOTE: regular properties are not proxied at this stage! So they are serialised...
				    // try {
				    //     entity.get("desc");
				    //     assert.fail("", "", "The unfetched property for entity should throw an exception.");
				    // } catch (ex) {
				    //     if (ex instanceof chai.AssertionError) {
				    //         throw ex;
				    //     }
				    //     assert.strictEqual(ex instanceof reflector.getStrictProxyExceptionPrototype(), true, "The exception thrown should be of type StrictProxyException.");
				    // }
				
				    // try {
				    //     entity.get("key");
				    //     assert.fail("", "", "The unfetched property for entity should throw an exception.");
				    // } catch (ex) {
				    //     if (ex instanceof chai.AssertionError) {
				    //         throw ex;
				    //     }
				    //     assert.strictEqual(ex instanceof reflector.getStrictProxyExceptionPrototype(), true, "The exception thrown should be of type StrictProxyException.");
				    // }
				
				    // instance meta-properties
				    assert.strictEqual(entity.prop("integerProp").isChangedFromOriginal(), false, "The entity response instance prop should be not changedFromOriginal.");
				    assert.strictEqual(entity.prop("integerProp").validationResult(), null, "The entity response instance prop should have empty validation result.");
				    assert.strictEqual(entity.prop("integerProp").isRequired(), false, "The entity response instance prop should be not required.");
				    assert.strictEqual(entity.prop("integerProp").isEditable(), true, "The entity response instance prop should be editable.");
				    assert.strictEqual(entity.prop("integerProp").isVisible(), true, "The entity response instance prop should be visible.");
				
				    // binding value ok?
				    assert.strictEqual(typeof bindingEntity.get("integerProp"), "object", "Binding property should be initialised.");
				    assert.strictEqual(bindingEntity.get("integerProp"), null, "Binding property should be string entity representation.");
				
				    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
				    ///////////////////////////////// CHECK THE VALUES INITIALISED BY ENTITY PRODUCER: /////////////////////////////////
				    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
				    // value ok?
				    assert.ok(entity.get("producerInitProp"), "The property should be initialised.");
				    assert.instanceOf(entity.get("producerInitProp"), reflector.getEntityPrototype(), "The property should be of entity type.");
				    assert.strictEqual(entity.get("producerInitProp").get("key"), "DEFAULT_KEY", "The entity response property should be entity instance with appropriate key.");
				
				    // value is changed?
				    assert.strictEqual(entity.prop("producerInitProp").isChangedFromOriginal(), true, "Instance meta-prop should be not changedFromOriginal.");
				
				    // value validationresult?
				    assert.strictEqual(entity.prop("producerInitProp").validationResult(), null, "Instance meta-prop should have empty (successful) validation result.");
				
				    // binding value ok?
				    assert.ok(bindingEntity.get("producerInitProp"), "Binding property should be initialised.");
				    assert.strictEqual(bindingEntity.get("producerInitProp"), "DEFAULT_KEY", "Binding property should be string entity representation.");
				
				    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
				    ///////////////////////////////// CHECK THE VALUES INITIALISED BY ENTITY CLASS DEFINITION: /////////////////////////
				    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
				    // value ok?
				    assert.ok(entity.get("domainInitProp"), "The property should be initialised.");
				    assert.strictEqual(entity.get("domainInitProp"), "ok", "The entity response property should be correct.");
				
				    // value is changed?
				    assert.strictEqual(entity.prop("domainInitProp").isChangedFromOriginal(), true, "Instance meta-prop should be not changedFromOriginal.");
				
				    // value validationresult?
				    assert.strictEqual(entity.prop("domainInitProp").validationResult(), null, "Instance meta-prop should have empty (successful) validation result.");
				
				    // binding value ok?
				    assert.ok(bindingEntity.get("domainInitProp"), "Binding property should be initialised.");
				    assert.strictEqual(bindingEntity.get("domainInitProp"), "ok", "Binding property should be string entity representation.");
				
				    done();
				};
				
				master.retrieve();
		    });
		    
		    test('works for new persisted entity', function(done) {
		    	master.entityId = '7';
		    	
	            master.postRetrieved = function(entity, bindingEntity, customObject) {
	                assert.strictEqual(entity.type().fullClassName(), "ua.com.fielden.platform.sample.domain.TgPersistentEntityWithProperties", "The type of entity response is not correct.");
	                assert.strictEqual(entity.id, 7, "The id of entity response is not correct.");
	                assert.strictEqual(entity.version, 0, "The version of entity response is not correct.");

	                // properties:
	                assert.strictEqual(entity.get("integerProp"), 43, "The entity response property is not correct.");

	                // IMPORTANT NOTE: regular properties are not proxied at this stage! So they are serialised...
	                // IMPORTANT NOTE: regular properties are not proxied at this stage! So they are serialised...
	                // IMPORTANT NOTE: regular properties are not proxied at this stage! So they are serialised...
	                // IMPORTANT NOTE: regular properties are not proxied at this stage! So they are serialised...
	                // IMPORTANT NOTE: regular properties are not proxied at this stage! So they are serialised...
	                // IMPORTANT NOTE: regular properties are not proxied at this stage! So they are serialised...
	                // IMPORTANT NOTE: regular properties are not proxied at this stage! So they are serialised...
	                // try {
	                //     entity.get("desc");
	                //     assert.fail("", "", "The unfetched property for entity should throw an exception.");
	                // } catch (ex) {
	                //     if (ex instanceof chai.AssertionError) {
	                //         throw ex;
	                //     }
	                //     assert.strictEqual(ex instanceof reflector.getStrictProxyExceptionPrototype(), true, "The exception thrown should be of type StrictProxyException.");
	                // }

	                // try {
	                //     entity.get("key");
	                //     assert.fail("", "", "The unfetched property for entity should throw an exception.");
	                // } catch (ex) {
	                //     if (ex instanceof chai.AssertionError) {
	                //         throw ex;
	                //     }
	                //     assert.strictEqual(ex instanceof reflector.getStrictProxyExceptionPrototype(), true, "The exception thrown should be of type StrictProxyException.");
	                // }

	                // instance meta-properties
	                assert.strictEqual(entity.prop("integerProp").isChangedFromOriginal(), false, "The entity response instance prop should be not changedFromOriginal.");
	                assert.strictEqual(entity.prop("integerProp").validationResult(), null, "The entity response instance prop should have empty validation result.");
	                assert.strictEqual(entity.prop("integerProp").isRequired(), false, "The entity response instance prop should be not required.");
	                assert.strictEqual(entity.prop("integerProp").isEditable(), true, "The entity response instance prop should be editable.");
	                assert.strictEqual(entity.prop("integerProp").isVisible(), true, "The entity response instance prop should be visible.");

	                // binding value ok?
	                assert.ok(bindingEntity.get("integerProp"), "Binding property should be initialised.");
	                assert.strictEqual(bindingEntity.get("integerProp"), 43, "Binding property should be string entity representation.");

	                done();
	            };

	            master.retrieve();
		    });
		});
		
		suite('validation', function() {
		    var master, reflector;
		
		    setup(function() {
				master = fixture('MasterFixture');
		      	reflector = document.querySelector('#reflector');
		    });
		
		    test('works for property', function(done) {
		    	master.entityId = '7';
		    	
	            master.postValidated = function(validatedEntity, bindingEntity, customObject) {
	                // value ok?
	                assert.ok(validatedEntity.get("integerProp"), "Property value should be initialised.");
	                assert.strictEqual(validatedEntity.get("integerProp"), 43, "Property value remain the same (validation did not succeed).");

	                // value is changed?
	                assert.strictEqual(validatedEntity.prop("integerProp").isChangedFromOriginal(), false, "Instance meta-prop should be NOT changedFromOriginal.");

	                // value validationresult?
	                assert.ok(validatedEntity.prop("integerProp").validationResult(), "Instance meta-prop should have non-empty (unsuccessful) validation result.");
	                assert.strictEqual(validatedEntity.prop("integerProp").validationResult().message, "Value '10000' is greater than the maximum limit of 9999.", "Property has incorrect validation result message.");

	                // binding value ok?
	                assert.ok(bindingEntity.get("integerProp"), "Binding property should be initialised.");
	                assert.strictEqual(bindingEntity.get("integerProp"), 10000, "Binding property should be correct number.");

	                done();
	            };

	            master.postRetrieved = function(entity, bindingEntity, customObject) {
	                // value ok?
	                assert.ok(entity.get("integerProp"), "Property value should be initialised.");
	                assert.strictEqual(entity.get("integerProp"), 43, "Property value should be correct.");

	                // value is changed?
	                assert.strictEqual(entity.prop("integerProp").isChangedFromOriginal(), false, "Instance meta-prop should be not changedFromOriginal.");

	                // value validationresult?
	                assert.strictEqual(entity.prop("integerProp").validationResult(), null, "Instance meta-prop should have empty (successful) validation result.");

	                // binding value ok?
	                assert.ok(bindingEntity.get("integerProp"), "Binding property should be initialised.");
	                assert.strictEqual(bindingEntity.get("integerProp"), 43, "Binding property should be string entity representation.");

	                // ACTUAL PROPERTY CHANGE
	                bindingEntity.set("integerProp", 10000);

	                master.validate();
	            };

	            master.retrieve();
		    });
		    
		    test('works for integer property', function (done) {
		    	master.entityId = '7';
		    	
	            master.postValidated = function(validatedEntity, bindingEntity, customObject) {
	                // value ok?
	                assert.ok(validatedEntity.get("integerProp"), "Property value should be initialised.");
	                assert.strictEqual(validatedEntity.get("integerProp"), 98, "Property value should be correct.");

	                // value is changed?
	                assert.strictEqual(validatedEntity.prop("integerProp").isChangedFromOriginal(), true, "Instance meta-prop should be changedFromOriginal.");

	                // value validationresult?
	                assert.strictEqual(validatedEntity.prop("integerProp").validationResult(), null, "Instance meta-prop should have empty (successful) validation result.");

	                // binding value ok?
	                assert.ok(bindingEntity.get("integerProp"), "Binding property should be initialised.");
	                assert.strictEqual(bindingEntity.get("integerProp"), 98, "Binding property should be correct number.");

	                done();
	            };

	            master.postRetrieved = function(entity, bindingEntity, customObject) {
	                // value ok?
	                assert.ok(entity.get("integerProp"), "Property value should be initialised.");
	                assert.strictEqual(entity.get("integerProp"), 43, "Property value should be correct.");

	                // value is changed?
	                assert.strictEqual(entity.prop("integerProp").isChangedFromOriginal(), false, "Instance meta-prop should be not changedFromOriginal.");

	                // value validationresult?
	                assert.strictEqual(entity.prop("integerProp").validationResult(), null, "Instance meta-prop should have empty (successful) validation result.");

	                // binding value ok?
	                assert.ok(bindingEntity.get("integerProp"), "Binding property should be initialised.");
	                assert.strictEqual(bindingEntity.get("integerProp"), 43, "Binding property should be string entity representation.");
	                
	                // ACTUAL PROPERTY CHANGE
	                bindingEntity.set("integerProp", 98);

	                master.validate();
	            };

	            master.retrieve();
		    });
		    
		    test('works for bigDecimal property', function (done) {
		    	master.entityId = '11';
		    	
	            master.postValidated = function(validatedEntity, bindingEntity, customObject) {
	                // value ok?
	                assert.ok(validatedEntity.get("bigDecimalProp"), "Property value should be initialised.");
	                assert.strictEqual(validatedEntity.get("bigDecimalProp"), 46.5, "Property value should be correct.");

	                // value is changed?
	                assert.strictEqual(validatedEntity.prop("bigDecimalProp").isChangedFromOriginal(), true, "Instance meta-prop should be changedFromOriginal.");

	                // value validationresult?
	                assert.strictEqual(validatedEntity.prop("bigDecimalProp").validationResult(), null, "Instance meta-prop should have empty (successful) validation result.");

	                // binding value ok?
	                assert.ok(bindingEntity.get("bigDecimalProp"), "Binding property should be initialised.");
	                assert.strictEqual(bindingEntity.get("bigDecimalProp"), 46.5, "Property value should be correct.");

	                done();
	            };

	            master.postRetrieved = function(entity, bindingEntity, customObject) {
	                // value ok?
	                assert.ok(entity.get("bigDecimalProp"), "Property value should be initialised.");
	                assert.strictEqual(entity.get("bigDecimalProp"), 23.0, "Property value should be correct.");

	                // value is changed?
	                assert.strictEqual(entity.prop("bigDecimalProp").isChangedFromOriginal(), false, "Instance meta-prop should be not changedFromOriginal.");

	                // value validationresult?
	                assert.strictEqual(entity.prop("bigDecimalProp").validationResult(), null, "Instance meta-prop should have empty (successful) validation result.");

	                // binding value ok?
	                assert.ok(bindingEntity.get("bigDecimalProp"), "Binding property should be initialised.");
	                assert.strictEqual(bindingEntity.get("bigDecimalProp"), 23.0, "Property value should be correct.");
	                
	                // ACTUAL PROPERTY CHANGE
	                bindingEntity.set("bigDecimalProp", 46.5);

	                master.validate();
	            };

	            master.retrieve();
		    });
		    
		    test('works for boolean property', function (done) {
		    	master.entityId = '13';
		    	
	            master.postValidated = function(validatedEntity, bindingEntity, customObject) {
	                // value ok?
	                assert.strictEqual(validatedEntity.get("booleanProp"), false, "Property value should be correct.");

	                // value is changed?
	                assert.strictEqual(validatedEntity.prop("booleanProp").isChangedFromOriginal(), true, "Instance meta-prop should be changedFromOriginal.");

	                // value validationresult?
	                assert.strictEqual(validatedEntity.prop("booleanProp").validationResult(), null, "Instance meta-prop should have empty (successful) validation result.");

	                // binding value ok?
	                assert.strictEqual(bindingEntity.get("booleanProp"), false, "Binding property should be correct number.");

	                done();
	            };

	            master.postRetrieved = function(entity, bindingEntity, customObject) {
	                // value ok?
	                assert.ok(entity.get("booleanProp"), "Property value should be initialised.");
	                assert.strictEqual(entity.get("booleanProp"), true, "Property value should be correct.");

	                // value is changed?
	                assert.strictEqual(entity.prop("booleanProp").isChangedFromOriginal(), false, "Instance meta-prop should be not changedFromOriginal.");

	                // value validationresult?
	                assert.strictEqual(entity.prop("booleanProp").validationResult(), null, "Instance meta-prop should have empty (successful) validation result.");

	                // binding value ok?
	                assert.ok(bindingEntity.get("booleanProp"), "Binding property should be initialised.");
	                assert.strictEqual(bindingEntity.get("booleanProp"), true, "Binding property should be string entity representation.");
	                
	                // ACTUAL PROPERTY CHANGE
	                bindingEntity.set("booleanProp", false);

	                master.validate();
	            };

	            master.retrieve();
		    });
		    
		    test('works for date property', function (done) {
		    	master.entityId = '14';
		    	
	            master.postValidated = function(validatedEntity, bindingEntity, customObject) {
	                // value ok?
	                assert.ok(validatedEntity.get("dateProp"), "Property value should be initialised.");
	                assert.strictEqual(validatedEntity.get("dateProp"), 10000, "Property value should be correct.");

	                // value is changed?
	                assert.strictEqual(validatedEntity.prop("dateProp").isChangedFromOriginal(), true, "Instance meta-prop should be changedFromOriginal.");

	                // value validationresult?
	                assert.strictEqual(validatedEntity.prop("dateProp").validationResult(), null, "Instance meta-prop should have empty (successful) validation result.");

	                // binding value ok?
	                assert.ok(bindingEntity.get("dateProp"), "Binding property should be initialised.");
	                assert.strictEqual(bindingEntity.get("dateProp"), 10000, "Binding property should be correct number.");

	                done();
	            };

	            master.postRetrieved = function(entity, bindingEntity, customObject) {
	                // value ok?
	                assert.ok(entity.get("dateProp"), "Property value should be initialised.");
	                assert.strictEqual(entity.get("dateProp"), 9999, "Property value should be correct.");

	                // value is changed?
	                assert.strictEqual(entity.prop("dateProp").isChangedFromOriginal(), false, "Instance meta-prop should be not changedFromOriginal.");

	                // value validationresult?
	                assert.strictEqual(entity.prop("dateProp").validationResult(), null, "Instance meta-prop should have empty (successful) validation result.");

	                // binding value ok?
	                assert.ok(bindingEntity.get("dateProp"), "Binding property should be initialised.");
	                assert.strictEqual(bindingEntity.get("dateProp"), 9999, "Binding property should be string entity representation.");
	                
	                // ACTUAL PROPERTY CHANGE
	                bindingEntity.set("dateProp", 10000);

	                master.validate();
	            };

	            master.retrieve();
		    });
		    
		    test('works for entity property', function (done) {
		    	master.entityId = '8';
		    	
	            master.postValidated = function(validatedEntity, bindingEntity, customObject) {
	                // value ok?
	                assert.ok(validatedEntity.get("entityProp"), "The property should be initialised.");
	                assert.instanceOf(validatedEntity.get("entityProp"), reflector.getEntityPrototype(), "The property should be of entity type.");
	                assert.strictEqual(validatedEntity.get("entityProp").get("key"), "KEY1", "The entity response property should be entity instance with appropriate key.");

	                // value is changed?
	                assert.strictEqual(validatedEntity.prop("entityProp").isChangedFromOriginal(), true, "Instance meta-prop should be changedFromOriginal.");

	                // value validationresult?
	                assert.strictEqual(validatedEntity.prop("entityProp").validationResult(), null, "Instance meta-prop should have empty (successful) validation result.");

	                // binding value ok?
	                assert.ok(bindingEntity.get("entityProp"), "Binding property should be initialised.");
	                assert.strictEqual(bindingEntity.get("entityProp"), "KEY1", "Binding property should be string entity representation.");

	                done();
	            };

	            master.postRetrieved = function(entity, bindingEntity, customObject) {
	                // value ok?
	                assert.ok(entity.get("entityProp"), "The property should be initialised.");
	                assert.instanceOf(entity.get("entityProp"), reflector.getEntityPrototype(), "The property should be of entity type.");
	                assert.strictEqual(entity.get("entityProp").get("key"), "KEY3", "The entity response property should be entity instance with appropriate key.");

	                // value is changed?
	                assert.strictEqual(entity.prop("entityProp").isChangedFromOriginal(), false, "Instance meta-prop should be not changedFromOriginal.");

	                // value validationresult?
	                assert.strictEqual(entity.prop("entityProp").validationResult(), null, "Instance meta-prop should have empty (successful) validation result.");

	                // binding value ok?
	                assert.ok(bindingEntity.get("entityProp"), "Binding property should be initialised.");
	                assert.strictEqual(bindingEntity.get("entityProp"), "KEY3", "Binding property should be string entity representation.");

	                
	                // ACTUAL PROPERTY CHANGE
	                bindingEntity.set("entityProp", "KEY1");

	                master.validate();
	            };

	            master.retrieve();
		    });
		    
		    test('works for money property', function (done) {
		    	master.entityId = '10';
		    	// TODO at this stage whatever currency is used for setting into binding entity (to be saved), retrieval from database 
		    	//      will return money instances with the currency, that is currently used in your OS.
		    	// Please, adjust the currency to be the same as in your OS to make this test happy.
		    	// #486 TODO var expectedCurrency = 'USD'; // 'AUD'
		    	
	            master.postValidated = function(validatedEntity, bindingEntity, customObject) {
	                // value ok?
	                assert.ok(validatedEntity.get("moneyProp"), "Property value should be initialised.");
	                assert.strictEqual(validatedEntity.get("moneyProp").amount, 46.0, "Property value amount should be correct.");
	                // #486 TODO assert.strictEqual(validatedEntity.get("moneyProp").currency, expectedCurrency, "Property value currency should be correct.");
	                assert.strictEqual(validatedEntity.get("moneyProp").taxPercent, 20, "Property value taxPercent should be correct.");

	                // value is changed?
	                assert.strictEqual(validatedEntity.prop("moneyProp").isChangedFromOriginal(), true, "Instance meta-prop should be changedFromOriginal.");

	                // value validationresult?
	                assert.strictEqual(validatedEntity.prop("moneyProp").validationResult(), null, "Instance meta-prop should have empty (successful) validation result.");

	                // binding value ok?
	                assert.ok(bindingEntity.get("moneyProp"), "Binding property should be initialised.");
	                assert.strictEqual(bindingEntity.get("moneyProp").amount, 46.0, "Property value amount should be correct.");
	                // #486 TODO assert.strictEqual(bindingEntity.get("moneyProp").currency, expectedCurrency, "Property value currency should be correct.");
	                assert.strictEqual(bindingEntity.get("moneyProp").taxPercent, 20, "Property value taxPercent should be correct.");

	                done();
	            };

	            master.postRetrieved = function(entity, bindingEntity, customObject) {
	                // value ok?
	                assert.ok(entity.get("moneyProp"), "Property value should be initialised.");
	                assert.strictEqual(entity.get("moneyProp").amount, 23.0, "Property value amount should be correct.");
	                // #486 TODO assert.strictEqual(entity.get("moneyProp").currency, expectedCurrency, "Property value currency should be correct.");
	                assert.strictEqual(entity.get("moneyProp").taxPercent, null, "Property value taxPercent should be correct.");

	                // value is changed?
	                assert.strictEqual(entity.prop("moneyProp").isChangedFromOriginal(), false, "Instance meta-prop should be not changedFromOriginal.");

	                // value validationresult?
	                assert.strictEqual(entity.prop("moneyProp").validationResult(), null, "Instance meta-prop should have empty (successful) validation result.");

	                // binding value ok?
	                assert.ok(bindingEntity.get("moneyProp"), "Binding property should be initialised.");
	                assert.strictEqual(bindingEntity.get("moneyProp").amount, 23.0, "Property value amount should be correct.");
	                // #486 TODO assert.strictEqual(bindingEntity.get("moneyProp").currency, expectedCurrency, "Property value currency should be correct.");
	                assert.strictEqual(bindingEntity.get("moneyProp").taxPercent, null, "Property value taxPercent should be correct.");
	                
	                // ACTUAL PROPERTY CHANGE
	                bindingEntity.set("moneyProp", { "amount" : 46.0, "taxPercent" : 20 }); // #486 TODO "currency" : expectedCurrency, 

	                master.validate();
	            };

	            master.retrieve();
		    });
		    
		    test('works for string property', function (done) {
		    	master.entityId = '12';
		    	
	            master.postValidated = function(validatedEntity, bindingEntity, customObject) {
	                // value ok?
	                assert.ok(validatedEntity.get("stringProp"), "Property value should be initialised.");
	                assert.strictEqual(validatedEntity.get("stringProp"), "okok", "Property value should be correct.");

	                // value is changed?
	                assert.strictEqual(validatedEntity.prop("stringProp").isChangedFromOriginal(), true, "Instance meta-prop should be changedFromOriginal.");

	                // value validationresult?
	                assert.strictEqual(validatedEntity.prop("stringProp").validationResult(), null, "Instance meta-prop should have empty (successful) validation result.");

	                // binding value ok?
	                assert.ok(bindingEntity.get("stringProp"), "Binding property should be initialised.");
	                assert.strictEqual(bindingEntity.get("stringProp"), "okok", "Binding property should be correct number.");

	                done();
	            };

	            master.postRetrieved = function(entity, bindingEntity, customObject) {
	                // value ok?
	                assert.ok(entity.get("stringProp"), "Property value should be initialised.");
	                assert.strictEqual(entity.get("stringProp"), "ok", "Property value should be correct.");

	                // value is changed?
	                assert.strictEqual(entity.prop("stringProp").isChangedFromOriginal(), false, "Instance meta-prop should be not changedFromOriginal.");

	                // value validationresult?
	                assert.strictEqual(entity.prop("stringProp").validationResult(), null, "Instance meta-prop should have empty (successful) validation result.");

	                // binding value ok?
	                assert.ok(bindingEntity.get("stringProp"), "Binding property should be initialised.");
	                assert.strictEqual(bindingEntity.get("stringProp"), "ok", "Binding property should be string entity representation.");
	                
	                // ACTUAL PROPERTY CHANGE
	                bindingEntity.set("stringProp", "okok");

	                master.validate();
	            };

	            master.retrieve();
		    });
		    
		    test('works for uppercased property editor', function (done) {
		    	master.entityId = '12';
		        var edProperty = master.$.editor_4_stringProp;
		    	
	            master.postValidated = function(validatedEntity, bindingEntity, customObject) {
	                // value ok?
	                assert.ok(validatedEntity.get("stringProp"), "Property value should be initialised.");
	                assert.strictEqual(validatedEntity.get("stringProp"), "OKOK", "Property value should be uppercased for @UpperCase property.");

	                // binding value ok?
	                assert.ok(bindingEntity.get("stringProp"), "Binding property should be initialised.");
	                assert.strictEqual(bindingEntity.get("stringProp"), "OKOK", "Binding property value should be uppercased for @UpperCase property.");

	                done();
	            };

	            master.postRetrieved = function(entity, bindingEntity, customObject) {
	                // value ok?
	                assert.ok(entity.get("stringProp"), "Property value should be initialised.");
	                assert.strictEqual(entity.get("stringProp"), "ok", "Property value should be correct.");

	                // binding value ok?
	                assert.ok(bindingEntity.get("stringProp"), "Binding property should be initialised.");
	                assert.strictEqual(bindingEntity.get("stringProp"), "ok", "Binding property should be string entity representation.");
	                
	                // ACTUAL PROPERTY CHANGE
	                // intentionally set lowercased value to check whether the result will be uppercased
	                edProperty._editingValue = 'okOk';
	                edProperty.commit();
	            };

	            master.retrieve();
		    });
		    
		    test('works for any property for new entity', function (done) {
	            master.postValidated = function(validatedEntity, bindingEntity, customObject) {
	                assert.strictEqual(validatedEntity.id, null, "The id of entity is not correct.");
	                // value ok?
	                assert.ok(validatedEntity.get("stringProp"), "Property value should be initialised.");
	                assert.strictEqual(validatedEntity.get("stringProp"), "okok", "Property value should be correct.");

	                // value is changed?
	                assert.strictEqual(validatedEntity.prop("stringProp").isChangedFromOriginal(), true, "Instance meta-prop should be changedFromOriginal.");

	                // value validationresult?
	                assert.strictEqual(validatedEntity.prop("stringProp").validationResult(), null, "Instance meta-prop should have empty (successful) validation result.");

	                // binding value ok?
	                assert.ok(bindingEntity.get("stringProp"), "Binding property should be initialised.");
	                assert.strictEqual(bindingEntity.get("stringProp"), "okok", "Binding property should be correct number.");

	                done();
	            };

	            master.postRetrieved = function(entity, bindingEntity, customObject) {
	                assert.strictEqual(entity.id, null, "The id of entity is not correct.");

	                // value ok?
	                assert.strictEqual(entity.get("stringProp"), null, "Property value should be correct.");

	                // value is changed?
	                assert.strictEqual(entity.prop("stringProp").isChangedFromOriginal(), false, "Instance meta-prop should be not changedFromOriginal.");

	                // value validationresult?
	                assert.strictEqual(entity.prop("stringProp").validationResult(), null, "Instance meta-prop should have empty (successful) validation result.");

	                // binding value ok?
	                assert.strictEqual(bindingEntity.get("stringProp"), null, "Binding property should be string entity representation.");
	                
	                // ACTUAL PROPERTY CHANGE
	                bindingEntity.set("stringProp", "okok");

	                master.validate();
	            };

	            master.retrieve();
		    });
		    
		    test('works for any property into missing value', function (done) {
		    	master.entityId = '14';
		    	
	            master.postValidated = function(validatedEntity, bindingEntity, customObject) {
	                // value ok?
	                assert.strictEqual(validatedEntity.get("dateProp"), null, "Property value should be correct.");

	                // value is changed?
	                assert.strictEqual(validatedEntity.prop("dateProp").isChangedFromOriginal(), true, "Instance meta-prop should be changedFromOriginal.");

	                // value validationresult?
	                assert.strictEqual(validatedEntity.prop("dateProp").validationResult(), null, "Instance meta-prop should have empty (successful) validation result.");

	                // binding value ok?
	                assert.strictEqual(bindingEntity.get("dateProp"), null, "Binding property should be correct number.");

	                done();
	            };

	            master.postRetrieved = function(entity, bindingEntity, customObject) {
	                // value ok?
	                assert.ok(entity.get("dateProp"), "Property value should be initialised.");
	                assert.strictEqual(entity.get("dateProp"), 9999, "Property value should be correct.");

	                // value is changed?
	                assert.strictEqual(entity.prop("dateProp").isChangedFromOriginal(), false, "Instance meta-prop should be not changedFromOriginal.");

	                // value validationresult?
	                assert.strictEqual(entity.prop("dateProp").validationResult(), null, "Instance meta-prop should have empty (successful) validation result.");

	                // binding value ok?
	                assert.ok(bindingEntity.get("dateProp"), "Binding property should be initialised.");
	                assert.strictEqual(bindingEntity.get("dateProp"), 9999, "Binding property should be string entity representation.");
	                
	                // ACTUAL PROPERTY CHANGE
	                bindingEntity.set("dateProp", null);

	                master.validate();
	            };

	            master.retrieve();
		    });
		    
		    test('works for any property simultaneously', function (done) {
		    	master.entityId = '12';
		    	
	            var postValidatedCount = 0;

	            master.postValidated = function(validatedEntity, bindingEntity, customObject) {
	                postValidatedCount = postValidatedCount + 1;
	                if (postValidatedCount > 2) {
	                    assert.fail("", "", "The validation should occur only twice.")
	                }

	                if (postValidatedCount === 1) {
		                // value ok?
		                assert.ok(validatedEntity.get("stringProp"), "Property value should be initialised.");
		                assert.strictEqual(validatedEntity.get("stringProp"), "6", "Property value should be correct.");
	
		                // value is changed?
		                assert.strictEqual(validatedEntity.prop("stringProp").isChangedFromOriginal(), true, "Instance meta-prop should be changedFromOriginal.");
	
		                // value validationresult?
		                assert.strictEqual(validatedEntity.prop("stringProp").validationResult(), null, "Instance meta-prop should have empty (successful) validation result.");
	
		                // binding value ok?
		                assert.ok(bindingEntity.get("stringProp"), "Binding property should be initialised.");
		                assert.strictEqual(bindingEntity.get("stringProp"), "6", "Binding property should be correct number.");
	                } else if (postValidatedCount === 2) {
		                // value ok?
		                assert.ok(validatedEntity.get("stringProp"), "Property value should be initialised.");
		                assert.strictEqual(validatedEntity.get("stringProp"), "5", "Property value should be correct.");
	
		                // value is changed?
		                assert.strictEqual(validatedEntity.prop("stringProp").isChangedFromOriginal(), true, "Instance meta-prop should be changedFromOriginal.");
	
		                // value validationresult?
		                assert.strictEqual(validatedEntity.prop("stringProp").validationResult(), null, "Instance meta-prop should have empty (successful) validation result.");
	
		                // binding value ok?
		                assert.ok(bindingEntity.get("stringProp"), "Binding property should be initialised.");
		                assert.strictEqual(bindingEntity.get("stringProp"), "5", "Binding property should be correct number.");
	
		                done();
	                }
	            };

	            master.postRetrieved = function(entity, bindingEntity, customObject) {
	                // value ok?
	                assert.ok(entity.get("stringProp"), "Property value should be initialised.");
	                assert.strictEqual(entity.get("stringProp"), "ok", "Property value should be correct.");

	                // value is changed?
	                assert.strictEqual(entity.prop("stringProp").isChangedFromOriginal(), false, "Instance meta-prop should be not changedFromOriginal.");

	                // value validationresult?
	                assert.strictEqual(entity.prop("stringProp").validationResult(), null, "Instance meta-prop should have empty (successful) validation result.");

	                // binding value ok?
	                assert.ok(bindingEntity.get("stringProp"), "Binding property should be initialised.");
	                assert.strictEqual(bindingEntity.get("stringProp"), "ok", "Binding property should be string entity representation.");
	                
	                // ACTUAL PROPERTY CHANGE
	                bindingEntity.set("stringProp", "1");
	                master.validate();

	                // ACTUAL PROPERTY CHANGE
	                bindingEntity.set("stringProp", "2");
	                master.validate();

	                // ACTUAL PROPERTY CHANGE
	                bindingEntity.set("stringProp", "3");
	                master.validate();

	                // ACTUAL PROPERTY CHANGE
	                bindingEntity.set("stringProp", "4");
	                master.validate();

	                master.async(function () {
		                // ACTUAL PROPERTY CHANGE
	                	console.log('	change to 5');
		                master._currBindingEntity.set("stringProp", "5");
		                master.validate();
	                }, 55);

	                //master.async(function () {
		            // ACTUAL PROPERTY CHANGE
		            console.log('	change to 6');
		            bindingEntity.set("stringProp", "6");
		            master.validate();
	                //}, 25);
	            };

	            master.retrieve();
		    });
		});
		
		suite('saving', function() {
		    var master, reflector;
		
		    setup(function() {
				master = fixture('MasterFixture');
		      	reflector = document.querySelector('#reflector');
		    });
		    
		    test('works for new entity', function (done) {
	            master.postSaved = function(potentiallySavedOrNewEntity, bindingEntity) {
	                assert.isNotNull(potentiallySavedOrNewEntity.id, "Entity id should be not null.");
	                assert.strictEqual(potentiallySavedOrNewEntity.version, 0, "Entity version should be the same.");
	             
	                // value ok?
	                assert.ok(potentiallySavedOrNewEntity.get("stringProp"), "Property value should be initialised.");
	                assert.strictEqual(potentiallySavedOrNewEntity.get("stringProp"), "okok", "Property value should be correct.");

	                // value is changed?
	                assert.strictEqual(potentiallySavedOrNewEntity.prop("stringProp").isChangedFromOriginal(), false, "Instance meta-prop should be changedFromOriginal.");

	                // value validationresult?
	                assert.strictEqual(potentiallySavedOrNewEntity.prop("stringProp").validationResult(), null, "Instance meta-prop should have empty (successful) validation result.");

	                // binding value ok?
	                assert.ok(bindingEntity.get("stringProp"), "Binding property should be initialised.");
	                assert.strictEqual(bindingEntity.get("stringProp"), "okok", "Binding property should be correct number.");

	                done();
	            };

	            master.postRetrieved = function(entity, bindingEntity, customObject) {
	                assert.strictEqual(entity.id, null, "Entity id should be null.");
	                assert.strictEqual(entity.version, 0, "Entity version should be initial.");
	                // value ok?
	                assert.strictEqual(entity.get("stringProp"), null, "Property value should be correct.");

	                // value is changed?
	                assert.strictEqual(entity.prop("stringProp").isChangedFromOriginal(), false, "Instance meta-prop should be not changedFromOriginal.");

	                // value validationresult?
	                assert.strictEqual(entity.prop("stringProp").validationResult(), null, "Instance meta-prop should have empty (successful) validation result.");

	                // binding value ok?
	                assert.strictEqual(bindingEntity.get("stringProp"), null, "Binding property should be string entity representation.");
	                
	                // ACTUAL PROPERTY CHANGE            
	                bindingEntity.set("requiredValidatedProp", 30);
	                bindingEntity.set("key", "KEY_TO_PASS_VALIDATION_BEFORE_SAVE_" + (new Date()).getTime());
	                bindingEntity.set("stringProp", "okok");

	                master.save();
	            };

	            master.retrieve();
		    });
            
            test('works for new entity with validation result thrown in CommonEntityDao save method', function (done) {
                master.postValidated = function(validatedEntity, bindingEntity, customObject) {
                    // validation process is legal -- it is not discarded, but saving is chained on top of last validation promise
                    // see issue https://github.com/fieldenms/tg/issues/479
                };
                
                master.postSaved = function (potentiallySavedOrNewEntity, bindingEntity) {
                    assert.isNull(potentiallySavedOrNewEntity.id, "Entity id should be null.");
                    assert.strictEqual(potentiallySavedOrNewEntity.version, 0, "Entity version should be the same.");
                    
                    assert.isNotNull(potentiallySavedOrNewEntity.exceptionOccured(), "Entity's exceptionOccured should exist.");
                    assert.strictEqual(potentiallySavedOrNewEntity.exceptionOccured().message, '[1/2/3 6:19] is not acceptable.', "Entity's exceptionOccured should exist.");
                    
                    var arrivedValue = null;
                    
                    // value ok?
                    assert.notOk(potentiallySavedOrNewEntity.get("dateProp"), "Property value should be initialised.");
                    assert.strictEqual(potentiallySavedOrNewEntity.get("dateProp"), arrivedValue, "Property value should be correct.");
                    
                    // value is changed?
                    assert.strictEqual(potentiallySavedOrNewEntity.prop("dateProp").isChangedFromOriginal(), false, "Instance meta-prop should be not changedFromOriginal.");
                    
                    // value validationresult?
                    assert.isNotNull(potentiallySavedOrNewEntity.prop("dateProp").validationResult(), "Instance meta-prop should have empty (successful) validation result.");
                    
                    assert.ok(potentiallySavedOrNewEntity.prop("dateProp").validationResult(), "Instance meta-prop should have non-empty (unsuccessful) validation result.");
                    assert.strictEqual(potentiallySavedOrNewEntity.prop("dateProp").validationResult()["@resultType"], "ua.com.fielden.platform.error.Result");
                    assert.strictEqual(potentiallySavedOrNewEntity.prop("dateProp").validationResult().message, "[1/2/3 6:19] is not acceptable.");
                    
                    // _editingValue ok?
                    assert.strictEqual(master.$.editor_4_dateProp._editingValue, '01/02/2003 06:19', 'Editing value should correspond to invalid value [01/02/2003 06:19].');
                    // binding value ok?
                    assert.ok(bindingEntity.get("dateProp"), "Binding property should be initialised.");
                    var invalidDateValue = reflector._millis('01/02/2003 06:19:00.000');
                    assert.strictEqual(bindingEntity.get("dateProp"), invalidDateValue, "Binding property should contain the invalid value that represents [1/2/3 6:19] date.");
                    
                    done();
                };
                
                master.postRetrieved = function(entity, bindingEntity, customObject) {
                    _editProperties(master, '1/2/3 6:19');
                    var saveButton = master.$$('tg-action[role="save"]').$.actionButton;
                    MockInteractions.tap(saveButton);
                };
                
                master.retrieve();
            });
            
            test('works for new entity with duplicate exception thrown in CommonEntityDao save method', function (done) {
                master.postValidated = function(validatedEntity, bindingEntity, customObject) {
                    // validation process is legal -- it is not discarded, but saving is chained on top of last validation promise
                    // see issue https://github.com/fieldenms/tg/issues/479
                };
                
                master.postSaved = function (potentiallySavedOrNewEntity, bindingEntity) {
                    assert.isNull(potentiallySavedOrNewEntity.id, "Entity id should be null.");
                    assert.strictEqual(potentiallySavedOrNewEntity.version, 0, "Entity version should be the same.");
                    
                    assert.isNotNull(potentiallySavedOrNewEntity.exceptionOccured(), "Entity's exceptionOccured should exist.");
                    assert.strictEqual(potentiallySavedOrNewEntity.exceptionOccured().message, 'Entity "DEMO00" of type Tg Persistent Entity With Properties already exists.', "Entity's exceptionOccured should exist.");
                    
                    var arrivedValue = reflector._millis('01/02/2003 06:21:00.000');
                    
                    // value ok?
                    assert.ok(potentiallySavedOrNewEntity.get("dateProp"), "Property value should be initialised.");
                    assert.strictEqual(potentiallySavedOrNewEntity.get("dateProp"), arrivedValue, "Property value should be correct.");
                    
                    // value is changed?
                    assert.strictEqual(potentiallySavedOrNewEntity.prop("dateProp").isChangedFromOriginal(), true, "Instance meta-prop should be changedFromOriginal.");
                    
                    // value validationresult?
                    assert.isNotNull(potentiallySavedOrNewEntity.prop("dateProp").validationResult(), "Instance meta-prop should have non-empty warning result.");
                    
                    assert.ok(potentiallySavedOrNewEntity.prop("dateProp").validationResult(), "Instance meta-prop should have non-empty warning result.");
                    assert.strictEqual(potentiallySavedOrNewEntity.prop("dateProp").validationResult()["@resultType"], "ua.com.fielden.platform.error.Warning");
                    assert.strictEqual(potentiallySavedOrNewEntity.prop("dateProp").validationResult().message, "[1/2/3 6:21] is acceptable, but with warning.");
                    
                    // _editingValue ok?
                    assert.strictEqual(master.$.editor_4_dateProp._editingValue, '01/02/2003 06:21', 'Editing value should correspond to value [01/02/2003 06:21].');
                    // binding value ok?
                    assert.ok(bindingEntity.get("dateProp"), "Binding property should be initialised.");
                    assert.strictEqual(bindingEntity.get("dateProp"), arrivedValue, "Binding property should contain the value that represents [1/2/3 6:21] date.");
                    
                    done();
                };
                
                master.postRetrieved = function(entity, bindingEntity, customObject) {
                    _editProperties(master, '1/2/3 6:21', 'DEMO00');
                    var saveButton = master.$$('tg-action[role="save"]').$.actionButton;
                    MockInteractions.tap(saveButton);
                };
                
                master.retrieve();
            });
            
            test('works for new entity with exception thrown in companion save method', function (done) {
                master.postValidated = function(validatedEntity, bindingEntity, customObject) {
                    // validation process is legal -- it is not discarded, but saving is chained on top of last validation promise
                    // see issue https://github.com/fieldenms/tg/issues/479
                };
                
                master.postSaved = function (potentiallySavedOrNewEntity, bindingEntity) {
                    assert.isNull(potentiallySavedOrNewEntity.id, "Entity id should be null.");
                    assert.strictEqual(potentiallySavedOrNewEntity.version, 0, "Entity version should be the same.");
                    
                    assert.isNotNull(potentiallySavedOrNewEntity.exceptionOccured(), "Entity's exceptionOccured should exist.");
                    assert.strictEqual(potentiallySavedOrNewEntity.exceptionOccured().message, 'Creation failed: [1/2/3 6:20] date is not permitted.', "Entity's exceptionOccured should exist.");
                    
                    var arrivedValue = reflector._millis('01/02/2003 06:20:00.000');
                    
                    // value ok?
                    assert.ok(potentiallySavedOrNewEntity.get("dateProp"), "Property value should be initialised.");
                    assert.strictEqual(potentiallySavedOrNewEntity.get("dateProp"), arrivedValue, "Property value should be correct.");
                    
                    // value is changed?
                    assert.strictEqual(potentiallySavedOrNewEntity.prop("dateProp").isChangedFromOriginal(), true, "Instance meta-prop should be changedFromOriginal.");
                    
                    // value validationresult?
                    assert.isNull(potentiallySavedOrNewEntity.prop("dateProp").validationResult(), "Instance meta-prop should have empty (successful) validation result.");
                    
                    // _editingValue ok?
                    assert.strictEqual(master.$.editor_4_dateProp._editingValue, '01/02/2003 06:20', 'Editing value should correspond to valid value [01/02/2003 06:20].');
                    // binding value ok?
                    assert.ok(bindingEntity.get("dateProp"), "Binding property should be initialised.");
                    assert.strictEqual(bindingEntity.get("dateProp"), arrivedValue, "Binding property should contain the valid value that represents [1/2/3 6:20] date.");
                    
                    done();
                };
                
                master.postRetrieved = function(entity, bindingEntity, customObject) {
                    _editProperties(master, '1/2/3 6:20');
                    var saveButton = master.$$('tg-action[role="save"]').$.actionButton;
                    MockInteractions.tap(saveButton);
                };
                
                master.retrieve();
            });
            
		    test('works for existing entity', function (done) {

	            master.postSaved = function(potentiallySavedOrNewEntity, bindingEntity) {
                    assert.isNotNull(potentiallySavedOrNewEntity.id, "Entity id should be not null.");
                    assert.strictEqual(potentiallySavedOrNewEntity.version, 0, "Entity version should be 0.");
             
                    // value ok?
                    assert.ok(potentiallySavedOrNewEntity.get("stringProp"), "Property value should be initialised.");
                    assert.strictEqual(potentiallySavedOrNewEntity.get("stringProp"), "ok", "Property value should be correct.");

                    // value is changed?
                    assert.strictEqual(potentiallySavedOrNewEntity.prop("stringProp").isChangedFromOriginal(), false, "Instance meta-prop should be changedFromOriginal.");

                    // value validationresult?
                    assert.strictEqual(potentiallySavedOrNewEntity.prop("stringProp").validationResult(), null, "Instance meta-prop should have empty (successful) validation result.");

                    // binding value ok?
                    assert.ok(bindingEntity.get("stringProp"), "Binding property should be initialised.");
                    assert.strictEqual(bindingEntity.get("stringProp"), "ok", "Binding property should be correct number.");

                    // ACTUAL PROPERTY CHANGE
                    bindingEntity.set("stringProp", "okok");
                    
                    // kick in the second save and thus the second part of this test 
                    this.postSaved = this.postSavedForExisting;
                    this.save();
	            }.bind(master);
	            
	            master.postSavedForExisting = function (potentiallySavedOrNewEntity, bindingEntity) {
                    assert.isNotNull(potentiallySavedOrNewEntity.id, "Entity id should remain not null.");
                    assert.strictEqual(potentiallySavedOrNewEntity.version, 1, "Entity version should be increased.");
             
                    // value ok?
                    assert.ok(potentiallySavedOrNewEntity.get("stringProp"), "Property value should be initialised.");
                    assert.strictEqual(potentiallySavedOrNewEntity.get("stringProp"), "okok", "Property value should be correct.");

                    // value is changed?
                    assert.strictEqual(potentiallySavedOrNewEntity.prop("stringProp").isChangedFromOriginal(), false, "Instance meta-prop should be changedFromOriginal.");

                    // value validationresult?
                    assert.strictEqual(potentiallySavedOrNewEntity.prop("stringProp").validationResult(), null, "Instance meta-prop should have empty (successful) validation result.");

                    // binding value ok?
                    assert.ok(bindingEntity.get("stringProp"), "Binding property should be initialised.");
                    assert.strictEqual(bindingEntity.get("stringProp"), "okok", "Binding property should be correct number.");

                    done();  
	            }.bind(master);

	            master.postRetrieved = function(entity, bindingEntity, customObject) {
	                // ACTUAL PROPERTY CHANGE
	                bindingEntity.set("stringProp", "ok");
	                bindingEntity.set("requiredValidatedProp", 30);
	                bindingEntity.set("key", "KEY_" + (new Date()).getTime());

	                master.save();
	            };

	            master.retrieve();
		    });
		    
		    test('works for existing entity after validation', function (done) {
	            var postSavedFirst = true;

	            master._postSaverLoadingFinished = function() {
	                if (postSavedFirst === true) {
	                    postSavedFirst = false;
	                    master.validate();
	                }
	            };

	            master.postSaved = function(potentiallySavedOrNewEntity, bindingEntity) {
                    assert.isNotNull(potentiallySavedOrNewEntity.id, "Entity id should be not null.");
                    assert.strictEqual(potentiallySavedOrNewEntity.version, 0, "Entity version should be 0.");
             
                    // value ok?
                    assert.ok(potentiallySavedOrNewEntity.get("stringProp"), "Property value should be initialised.");
                    assert.strictEqual(potentiallySavedOrNewEntity.get("stringProp"), "ok", "Property value should be correct.");

                    // value is changed?
                    assert.strictEqual(potentiallySavedOrNewEntity.prop("stringProp").isChangedFromOriginal(), false, "Instance meta-prop should be changedFromOriginal.");

                    // value validationresult?
                    assert.strictEqual(potentiallySavedOrNewEntity.prop("stringProp").validationResult(), null, "Instance meta-prop should have empty (successful) validation result.");

                    // binding value ok?
                    assert.ok(bindingEntity.get("stringProp"), "Binding property should be initialised.");
                    assert.strictEqual(bindingEntity.get("stringProp"), "ok", "Binding property should be correct number.");

                    // ACTUAL PROPERTY CHANGE
                    bindingEntity.set("stringProp", "okok");
                    
                 	// kick in validation and thus the second part of this test
                    this.postSaved = this.postSavedForExisting;
                    this.validate();
	            }.bind(master);
	            
	            master.postSavedForExisting = function(potentiallySavedOrNewEntity, bindingEntity) {
                    assert.isNotNull(potentiallySavedOrNewEntity.id, "Entity id should remain not null.");
                    assert.strictEqual(potentiallySavedOrNewEntity.version, 1, "Entity version should be increased.");
             
                    // value ok?
                    assert.ok(potentiallySavedOrNewEntity.get("stringProp"), "Property value should be initialised.");
                    assert.strictEqual(potentiallySavedOrNewEntity.get("stringProp"), "okok", "Property value should be correct.");

                    // value is changed?
                    assert.strictEqual(potentiallySavedOrNewEntity.prop("stringProp").isChangedFromOriginal(), false, "Instance meta-prop should be changedFromOriginal.");

                    // value validationresult?
                    assert.strictEqual(potentiallySavedOrNewEntity.prop("stringProp").validationResult(), null, "Instance meta-prop should have empty (successful) validation result.");

                    // binding value ok?
                    assert.ok(bindingEntity.get("stringProp"), "Binding property should be initialised.");
                    assert.strictEqual(bindingEntity.get("stringProp"), "okok", "Binding property should be correct number.");

                    done();  
	            }.bind(master);

	            master.postValidated = function(validatedEntity, newBindingEntity, customObject) {
                    assert.isNotNull(validatedEntity.id, "Entity id should be not null.");
                    assert.strictEqual(validatedEntity.version, 0, "Entity version should be 0.");
             
                    // value ok?
                    assert.ok(validatedEntity.get("stringProp"), "Property value should be initialised.");
                    assert.strictEqual(validatedEntity.get("stringProp"), "okok", "Property value should be correct.");

                    // value is changed?
                    assert.strictEqual(validatedEntity.prop("stringProp").isChangedFromOriginal(), true, "Instance meta-prop should be changedFromOriginal.");

                    // value validationresult?
                    assert.strictEqual(validatedEntity.prop("stringProp").validationResult(), null, "Instance meta-prop should have empty (successful) validation result.");

                    // binding value ok?
                    assert.ok(newBindingEntity.get("stringProp"), "Binding property should be initialised.");
                    assert.strictEqual(newBindingEntity.get("stringProp"), "okok", "Binding property should be correct.");
	            	
	                master.save();
	            };

	            master.postRetrieved = function(entity, bindingEntity, customObject) {
	                // ACTUAL PROPERTY CHANGE
	                bindingEntity.set("stringProp", "ok");
	                bindingEntity.set("requiredValidatedProp", 30);
	                bindingEntity.set("key", "KEY_" + (new Date()).getTime());

	                master.save();
	            };

	            master.retrieve();
		    });
		    
            test('works for existing entity with exception thrown in companion save method', function (done) {
                master.postValidated = function (validatedEntity, bindingEntity, customObject) {
                    // validation process is legal -- it is not discarded, but saving is chained on top of last validation promise
                    // see issue https://github.com/fieldenms/tg/issues/479
                };
                
                master.postSaved = function (potentiallySavedOrNewEntity, bindingEntity) {
                    master.$.editor_4_dateProp._editingValue = '1/2/3 6:22';
                    master.$.editor_4_dateProp.commit();
                    
                    // kick in the second save and thus the second part of this test 
                    this.postSaved = this.postSavedForExisting;
                    
                    var saveButton = master.$$('tg-action[role="save"]').$.actionButton;
                    this.async(function () {
                        // need to do this on async because at this stage saveButton is disabled but will be enabled very soon
                        MockInteractions.tap(saveButton);
                    }, 100);
                }.bind(master);
                
                master.postSavedForExisting = function (potentiallySavedOrNewEntity, bindingEntity) {
                    assert.isNotNull(potentiallySavedOrNewEntity.id, "Entity id should be not null.");
                    
                    assert.isNotNull(potentiallySavedOrNewEntity.exceptionOccured(), "Entity's exceptionOccured should exist.");
                    assert.strictEqual(potentiallySavedOrNewEntity.exceptionOccured().message, 'Modification failed: [1/2/3 6:22] is not acceptable for persisted entity.', "Entity's exceptionOccured should exist.");
                    
                    var arrivedValue = reflector._millis('01/02/2003 00:00:00.000');
                    
                    // value ok?
                    assert.ok(potentiallySavedOrNewEntity.get("dateProp"), "Property value should be initialised.");
                    assert.strictEqual(potentiallySavedOrNewEntity.get("dateProp"), arrivedValue, "Property value should be correct.");
                    
                    // value is changed?
                    assert.strictEqual(potentiallySavedOrNewEntity.prop("dateProp").isChangedFromOriginal(), false, "Instance meta-prop should be not changedFromOriginal.");
                    
                    // value validationresult?
                    assert.isNotNull(potentiallySavedOrNewEntity.prop("dateProp").validationResult(), "Instance meta-prop should have empty (successful) validation result.");
                    
                    assert.ok(potentiallySavedOrNewEntity.prop("dateProp").validationResult(), "Instance meta-prop should have non-empty (unsuccessful) validation result.");
                    assert.strictEqual(potentiallySavedOrNewEntity.prop("dateProp").validationResult()["@resultType"], "ua.com.fielden.platform.error.Result");
                    assert.strictEqual(potentiallySavedOrNewEntity.prop("dateProp").validationResult().message, "[1/2/3 6:22] is not acceptable for persisted entity.");
                    
                    // _editingValue ok?
                    assert.strictEqual(master.$.editor_4_dateProp._editingValue, '01/02/2003 06:22', 'Editing value should correspond to invalid value [01/02/2003 06:22].');
                    // binding value ok?
                    assert.ok(bindingEntity.get("dateProp"), "Binding property should be initialised.");
                    var invalidDateValue = reflector._millis('01/02/2003 06:22:00.000');
                    assert.strictEqual(bindingEntity.get("dateProp"), invalidDateValue, "Binding property should contain the invalid value that represents [1/2/3 6:22] date.");
                    
                    done();
                }.bind(master);
                
                master.postRetrieved = function (entity, bindingEntity, customObject) {
                    _editProperties(master, '1/2/3');
                    
                    var saveButton = master.$$('tg-action[role="save"]').$.actionButton;
                    MockInteractions.tap(saveButton);
                };
                
                master.retrieve();
            });
		});
		
		suite('merging', function() {
		    var master, reflector;
		
		    setup(function() {
				master = fixture('MasterFixture');
		      	reflector = document.querySelector('#reflector');
		    });
		    
		    test('works for stale entity', function (done) {
		    	master.entityId = '16';
		    	
	            master.postValidated = function(validatedEntity, bindingEntity, customObject) {
	                assert.strictEqual(validatedEntity.version, 1, "Entity version should be increased.");

	                ////////////////////////////////////////// CHECK NON-CONFLICTING PROP //////////////////////////////////////////
	                // value ok?
	                assert.ok(validatedEntity.get("nonConflictingProp"), "Property value should be initialised.");
	                assert.strictEqual(validatedEntity.get("nonConflictingProp"), "modified", "Property value should be correct.");

	                // value is changed?
	                assert.strictEqual(validatedEntity.prop("nonConflictingProp").isChangedFromOriginal(), true, "Instance meta-prop should be changedFromOriginal.");

	                // value validationresult?
	                assert.strictEqual(validatedEntity.prop("nonConflictingProp").validationResult(), null, "Instance meta-prop should have empty (successful) validation result.");

	                // binding value ok?
	                assert.ok(bindingEntity.get("nonConflictingProp"), "Binding property should be initialised.");
	                assert.strictEqual(bindingEntity.get("nonConflictingProp"), "modified", "Binding property should be correct number.");

	                ////////////////////////////////////////// CHECK CONFLICTING PROP //////////////////////////////////////////
	                // value ok?
	                assert.ok(validatedEntity.get("conflictingProp"), "Property value should be initialised.");
	                assert.strictEqual(validatedEntity.get("conflictingProp"), "persistently modified", "Property value should be correct.");

	                // value is changed?
	                assert.strictEqual(validatedEntity.prop("conflictingProp").isChangedFromOriginal(), false, "Instance meta-prop should be changedFromOriginal.");

	                // value validationresult?
	                assert.ok(validatedEntity.prop("conflictingProp").validationResult(), "Instance meta-prop should have non-empty warning result.");
	                assert.strictEqual(validatedEntity.prop("conflictingProp").validationResult()["@resultType"], "ua.com.fielden.platform.error.Warning");
	                assert.strictEqual(validatedEntity.prop("conflictingProp").validationResult().message, "The property has been recently changed by other user.");

	                // binding value ok?
	                assert.ok(bindingEntity.get("conflictingProp"), "Binding property should be initialised.");
	                assert.strictEqual(bindingEntity.get("conflictingProp"), "persistently modified", "Binding property should be correct number.");

	                done();
	            };

	            master.preRetrieved = function(entity) {
	                entity.version = 0;
	                entity.set("conflictingProp", "initial");
	                return entity;
	            };

	            master.postRetrieved = function(entity, bindingEntity, customObject) {
	                assert.strictEqual(entity.version, 0, "Entity version should be original.");

	                ////////////////////////////////////////// CHECK NON-CONFLICTING PROP //////////////////////////////////////////
	                // value ok?
	                assert.ok(entity.get("nonConflictingProp"), "Property value should be initialised.");
	                assert.strictEqual(entity.get("nonConflictingProp"), "initial", "Property value should be correct.");

	                // value is changed?
	                assert.strictEqual(entity.prop("nonConflictingProp").isChangedFromOriginal(), false, "Instance meta-prop should be not changedFromOriginal.");

	                // value validationresult?
	                assert.strictEqual(entity.prop("nonConflictingProp").validationResult(), null, "Instance meta-prop should have empty (successful) validation result.");

	                // binding value ok?
	                assert.ok(bindingEntity.get("nonConflictingProp"), "Binding property should be initialised.");
	                assert.strictEqual(bindingEntity.get("nonConflictingProp"), "initial", "Binding property should be string entity representation.");

	                ////////////////////////////////////////// CHECK CONFLICTING PROP //////////////////////////////////////////
	                // value ok?
	                assert.ok(entity.get("conflictingProp"), "Property value should be initialised.");
	                assert.strictEqual(entity.get("conflictingProp"), "initial", "Property value should be correct.");

	                // value is changed?
	                assert.strictEqual(entity.prop("conflictingProp").isChangedFromOriginal(), false, "Instance meta-prop should be not changedFromOriginal.");

	                // value validationresult?
	                assert.strictEqual(entity.prop("conflictingProp").validationResult(), null, "Instance meta-prop should have empty (successful) validation result.");

	                // binding value ok?
	                assert.ok(bindingEntity.get("conflictingProp"), "Binding property should be initialised.");
	                assert.strictEqual(bindingEntity.get("conflictingProp"), "initial", "Binding property should be string entity representation.");
	                
	                // ACTUAL PROPERTY CHANGE
	                bindingEntity.set("nonConflictingProp", "modified");

	                master.validate();
	            };

	            master.retrieve();
		    });
		    
		    test('works for stale entity with conflict', function (done) {
		    	master.entityId = '16';
		    	
	            master.postValidated = function(validatedEntity, bindingEntity, customObject) {
	                assert.strictEqual(validatedEntity.version, 1, "Entity version should be increased.");

	                ////////////////////////////////////////// CHECK CONFLICTING PROP //////////////////////////////////////////
	                // value ok?
	                assert.ok(validatedEntity.get("conflictingProp"), "Property value should be initialised.");
	                assert.strictEqual(validatedEntity.get("conflictingProp"), "persistently modified", "Property value should be correct.");

	                // value is changed?
	                assert.strictEqual(validatedEntity.prop("conflictingProp").isChangedFromOriginal(), false, "Instance meta-prop should be changedFromOriginal.");

	                // value validationresult?
	                assert.ok(validatedEntity.prop("conflictingProp").validationResult(), "Instance meta-prop should have non-empty (unsuccessful) validation result.");
	                assert.strictEqual(validatedEntity.prop("conflictingProp").validationResult()["@resultType"], "ua.com.fielden.platform.error.Result");
	                assert.strictEqual(validatedEntity.prop("conflictingProp").validationResult().message, "The property has been recently changed by other user. Please revert property value to resolve conflict.");

	                // binding value ok?
	                assert.ok(bindingEntity.get("conflictingProp"), "Binding property should be initialised.");
	                assert.strictEqual(bindingEntity.get("conflictingProp"), "modified", "Binding property should be correct number.");

	                done();
	            };

	            master.preRetrieved = function(entity) {
	                entity.version = 0;
	                entity.set("conflictingProp", "initial");
	                return entity;
	            };

	            master.postRetrieved = function(entity, bindingEntity, customObject) {
	                assert.strictEqual(entity.version, 0, "Entity version should be original.");

	                ////////////////////////////////////////// CHECK CONFLICTING PROP //////////////////////////////////////////
	                // value ok?
	                assert.ok(entity.get("conflictingProp"), "Property value should be initialised.");
	                assert.strictEqual(entity.get("conflictingProp"), "initial", "Property value should be correct.");

	                // value is changed?
	                assert.strictEqual(entity.prop("conflictingProp").isChangedFromOriginal(), false, "Instance meta-prop should be not changedFromOriginal.");

	                // value validationresult?
	                assert.strictEqual(entity.prop("conflictingProp").validationResult(), null, "Instance meta-prop should have empty (successful) validation result.");

	                // binding value ok?
	                assert.ok(bindingEntity.get("conflictingProp"), "Binding property should be initialised.");
	                assert.strictEqual(bindingEntity.get("conflictingProp"), "initial", "Binding property should be string entity representation.");
	                
	                // ACTUAL PROPERTY CHANGE
	                bindingEntity.set("conflictingProp", "modified");

	                master.validate();
	            };

	            master.retrieve();
		    });
		});
	</script>
</body>

</html>