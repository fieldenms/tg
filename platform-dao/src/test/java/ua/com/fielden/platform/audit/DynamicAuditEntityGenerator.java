package ua.com.fielden.platform.audit;

import jakarta.inject.Inject;
import jakarta.inject.Singleton;
import ua.com.fielden.platform.entity.AbstractEntity;
import ua.com.fielden.platform.reflection.exceptions.ReflectionException;
import ua.com.fielden.platform.test_utils.compile.Compilation;
import ua.com.fielden.platform.test_utils.compile.InMemoryJavaFileObjects;
import ua.com.fielden.platform.utils.CollectionUtil;

import java.lang.invoke.MethodHandle;
import java.lang.invoke.MethodHandles;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

import static com.google.common.collect.ImmutableSet.toImmutableSet;
import static java.lang.invoke.MethodType.methodType;

/**
 * Generates audit-entity types at runtime by dynamically compiling source code generated by {@link AuditEntityGenerator} and loading the classes.
 */
@Singleton
public final class DynamicAuditEntityGenerator {

    private final AuditEntityGenerator generator;

    @Inject
    DynamicAuditEntityGenerator(final AuditEntityGenerator generator) {
        this.generator = generator;
    }

    /**
     * Generates audit-entity and audit-prop entity types for the specified audited entity type.
     * The source code is first generated, then compiled, and, finally, loaded using the class loader of the specified entity type,
     * enabling global discovery of the generated types.
     */
    public Set<Class<?>> generateAuditTypes(final Class<? extends AbstractEntity<?>> entityType) {
        final var sourceInfos = generator.generateSources(List.of(entityType));
        final var jfos = sourceInfos.stream()
                .map(sourceInfo -> InMemoryJavaFileObjects.createJavaSource(sourceInfo.className(), sourceInfo.source()))
                .toList();
        final var compilation = Compilation.newInMemory(jfos);
        final var compilationResult = compilation.compile();

        compilationResult.throwIfFailed(compilerMsg -> """
            Failed to compile dynamically generated audit types [%s].
            Their source code is reported below, followed by the compilation errors.
            %s
            
            %s
            """.formatted(CollectionUtil.toString(sourceInfos, AuditEntityGenerator.SourceInfo::className, ", "),
                          sourceInfos.stream()
                                  .map(si -> """
                                             >>>>> BEGIN %1$s
                                             %2$s
                                             <<<<< END %1$s
                                             """.formatted(si.className(), si.source()))
                                  .collect(Collectors.joining("\n")),
                          compilerMsg));

        return compilationResult.outputClasses().stream()
                .map(classFile -> defineClass(entityType.getClassLoader(), classFile.name(), classFile.getBytes()))
                .collect(toImmutableSet());
    }

    /**
     * Invokes {@link ClassLoader#defineClass(String, byte[], int, int)} on the specified class loader with the specified arguments.
     * The invoked method is inaccessible to this class, so this method uses method handles to bypass standard accesibility checks.
     * <p>
     * The purpose of this method is to enable loading of classes into the specified class loader directly.
     * In particular, the achieved effect is that dynamically generated audit-entity types are loaded by the same class
     * loader as the audited entity types, enabling their discovery globally.
     */
    private static Class<?> defineClass(final ClassLoader classLoader, final String name, final byte[] bytes) {
        class $ {
            static final MethodHandle mh_defineClass;

            static {
                try {
                    final var lookup = MethodHandles.privateLookupIn(ClassLoader.class, MethodHandles.lookup());
                    mh_defineClass = lookup.findVirtual(ClassLoader.class, "defineClass", methodType(Class.class, String.class, byte[].class, int.class, int.class));
                } catch (final Exception e) {
                    throw new RuntimeException(e);
                }
            }
        }

        try {
            return (Class<?>) $.mh_defineClass.invoke(classLoader, name, bytes, 0, bytes.length);
        } catch (final Throwable ex) {
            throw new ReflectionException("Failed to define class [%s] with class loader [%s]".formatted(name, classLoader), ex);
        }
    }

}
