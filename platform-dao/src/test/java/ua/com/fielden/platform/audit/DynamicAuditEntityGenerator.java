package ua.com.fielden.platform.audit;

import jakarta.inject.Inject;
import jakarta.inject.Named;
import jakarta.inject.Singleton;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import ua.com.fielden.platform.entity.AbstractEntity;
import ua.com.fielden.platform.entity.exceptions.InvalidArgumentException;
import ua.com.fielden.platform.reflection.exceptions.ReflectionException;
import ua.com.fielden.platform.test_utils.compile.Compilation;
import ua.com.fielden.platform.test_utils.compile.InMemoryJavaFileObjects;
import ua.com.fielden.platform.types.tuples.T2;
import ua.com.fielden.platform.utils.CollectionUtil;

import java.io.IOException;
import java.lang.invoke.MethodHandle;
import java.lang.invoke.MethodHandles;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.List;
import java.util.Optional;
import java.util.Set;
import java.util.stream.Collectors;

import static com.google.common.collect.ImmutableSet.toImmutableSet;
import static java.lang.invoke.MethodType.methodType;
import static ua.com.fielden.platform.test.ioc.AuditingTestIocModule.GENERATED_AUDIT_SOURCES_PATH;

/**
 * Generates audit-entity types at runtime by dynamically compiling source code generated by {@link AuditEntityGenerator} and loading the classes.
 */
@Singleton
public final class DynamicAuditEntityGenerator {

    private static final Logger LOGGER = LogManager.getLogger();

    private final AuditEntityGenerator generator;
    private final Optional<String> maybeGeneratedAuditSourcesPath;

    @Inject
    DynamicAuditEntityGenerator(final AuditEntityGenerator generator, final @Named(GENERATED_AUDIT_SOURCES_PATH) String generatedAuditSourcesPath) {
        this.generator = generator;
        this.maybeGeneratedAuditSourcesPath = generatedAuditSourcesPath.isEmpty() ? Optional.empty() : Optional.of(generatedAuditSourcesPath);
    }

    /**
     * Generates audit-entity and audit-prop entity types for the specified audited entity type.
     * The source code is first generated, then compiled, and, finally, loaded using the class loader of the specified entity type,
     * enabling global discovery of the generated types.
     */
    public Set<Class<?>> generateAuditTypes(final Class<? extends AbstractEntity<?>> entityType) {
        final var sourceInfos = generator.generateSources(List.of(entityType));
        final var jfos = sourceInfos.stream()
                .map(sourceInfo -> InMemoryJavaFileObjects.createJavaSource(sourceInfo.className(), sourceInfo.source()))
                .toList();
        final var compilation = Compilation.newInMemory(jfos);
        final var compilationResult = compilation.compile();

        compilationResult.throwIfFailed(compilerMsg -> """
            Failed to compile dynamically generated audit types [%s].
            Their source code is reported below, followed by the compilation errors.
            %s
            
            %s
            """.formatted(CollectionUtil.toString(sourceInfos, AuditEntityGenerator.SourceInfo::className, ", "),
                          sourceInfos.stream()
                                  .map(si -> """
                                             >>>>> BEGIN %1$s
                                             %2$s
                                             <<<<< END %1$s
                                             """.formatted(si.className(), si.source()))
                                  .collect(Collectors.joining("\n")),
                          compilerMsg));

        // Write sources to disk if this option is enabled.
        // It is envisioned that these sources will be put under version control, enabling traceability of audit structure's evolution.
        maybeGeneratedAuditSourcesPath.ifPresentOrElse(basePath -> {
            for (final var sourceInfo : sourceInfos) {
                final var pkgName_simpleName = splitClassName(sourceInfo.className());
                final var absDirPath = Path.of(basePath, pkgName_simpleName._1.replace('.', '/')).toAbsolutePath().normalize();
                final var absFilePath = absDirPath.resolve(pkgName_simpleName._2 + ".java");
                try {
                    Files.createDirectories(absDirPath);
                    Files.writeString(absFilePath, sourceInfo.source(), StandardCharsets.UTF_8);
                } catch (final IOException ex) {
                    throw new RuntimeException(
                            "Failed to write the source of generated audit type [%s] to [%s]".formatted(sourceInfo.className(), absFilePath), ex);
                }
            }
            LOGGER.info("Sources for generated audit types were written to [%s]".formatted(Path.of(basePath).toAbsolutePath().normalize()));
        }, () -> LOGGER.info("Skipping writing of sources for generated audit types, it was not requested."));

        return compilationResult.outputClasses().stream()
                .map(classFile -> defineClass(entityType.getClassLoader(), classFile.name(), classFile.getBytes()))
                .collect(toImmutableSet());
    }

    /**
     * Splits a fully-qualified class name into its package and simple names.
     * <p>
     * If the specified name does not contain a package name, the resulting package name is empty.
     * <p>
     * It is an error if the specified class name begins or ends with a dot.
     * No further validation is performed.
     */
    private static T2<String, String> splitClassName(final String className) {
        final int lastDotIdx = className.lastIndexOf('.');

        if (lastDotIdx == 0 || lastDotIdx == className.length() - 1) {
            throw new InvalidArgumentException("Invalid class name: %s".formatted(className));
        }

        return lastDotIdx == -1
                ? T2.t2("", className)
                : T2.t2(className.substring(0, lastDotIdx), className.substring(lastDotIdx + 1));
    }

    /**
     * Invokes {@link ClassLoader#defineClass(String, byte[], int, int)} on the specified class loader with the specified arguments.
     * The invoked method is inaccessible to this class, so this method uses method handles to bypass standard accesibility checks.
     * <p>
     * The purpose of this method is to enable loading of classes into the specified class loader directly.
     * In particular, the achieved effect is that dynamically generated audit-entity types are loaded by the same class
     * loader as the audited entity types, enabling their discovery globally.
     */
    private static Class<?> defineClass(final ClassLoader classLoader, final String name, final byte[] bytes) {
        class $ {
            static final MethodHandle mh_defineClass;

            static {
                try {
                    final var lookup = MethodHandles.privateLookupIn(ClassLoader.class, MethodHandles.lookup());
                    mh_defineClass = lookup.findVirtual(ClassLoader.class, "defineClass", methodType(Class.class, String.class, byte[].class, int.class, int.class));
                } catch (final Exception e) {
                    throw new RuntimeException(e);
                }
            }
        }

        try {
            return (Class<?>) $.mh_defineClass.invoke(classLoader, name, bytes, 0, bytes.length);
        } catch (final Throwable ex) {
            throw new ReflectionException("Failed to define class [%s] with class loader [%s]".formatted(name, classLoader), ex);
        }
    }

}
