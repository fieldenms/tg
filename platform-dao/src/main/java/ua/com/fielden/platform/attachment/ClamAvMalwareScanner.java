package ua.com.fielden.platform.attachment;

import jakarta.inject.Named;
import jakarta.inject.Singleton;
import org.apache.logging.log4j.Logger;
import ua.com.fielden.platform.attachment.IMalwareScanner.ScanResult.Found;
import ua.com.fielden.platform.attachment.IMalwareScanner.ScanResult.Ok;
import ua.com.fielden.platform.attachment.IMalwareScanner.ScanResult.ScannerError;
import ua.com.fielden.platform.attachment.IMalwareScanner.ScanResult.ScannerNotAvailable;
import ua.com.fielden.platform.error.Result;

import java.io.*;
import java.net.Socket;
import java.nio.file.Files;
import java.nio.file.Path;
import java.time.Duration;
import java.util.Arrays;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

import static org.apache.logging.log4j.LogManager.getLogger;
import static ua.com.fielden.platform.error.Result.successful;

/**
 * Implementation of {@link IMalwareScanner} that uses ClamAV for malware scanning.
 * <p>
 * An instance of this class gets instantiated as a singleton and uses {@link ExecutorService} to handle concurrent requests for malware scanning.
 */
@Singleton
public class ClamAvMalwareScanner implements IMalwareScanner {

    private static final Logger LOGGER = getLogger(ClamAvMalwareScanner.class);
    public static final String ERR_MALWARE_SCANNER_NOT_AVAILABLE = "Malware scanner is not available. Try again later.";

    private final ExecutorService executorService;

    private static final Result SUCCESS = successful();


    private final String hostName;
    private final int port;
    private final Duration timeout;

    // The chunk size should not exceed `StreamMaxLength` as defined in `clamd.conf`.
    // Otherwise, `clamd` will reply with an error about size limit exceeded, closing the connection.
    // The default size in the standard ClamAV docker image is 100M.
    private static final int CHUNK_SIZE = 2048;
    private static final int DEFAULT_TIMEOUT = 500;

    public ClamAvMalwareScanner() {
        this("localhost", 3310, Duration.ofMillis(DEFAULT_TIMEOUT));
    }

    public ClamAvMalwareScanner(
            final @Named("clamav.host") String hostName,
            final @Named("clamav.port") int port,
            final @Named("clamav.timeout") Duration timeout)
    {
        this.hostName = hostName;
        this.port = port;
        this.timeout = timeout;

        executorService = Executors.newVirtualThreadPerTaskExecutor();
        Runtime.getRuntime().addShutdownHook(new Thread(() -> {
            try {
                LOGGER.info("Shutting down executor service for ClamAV malware scanner...");
                executorService.shutdown();
            } catch (final Exception ex) {
                LOGGER.error("Shutting down executor service for ClamAV malware scanner encountered an error during shutdown.", ex);
            }
        }));

    }

    @Override
    public ScanResult scan(final Path pathToFile) {
        // Ping ClamAV to check if it is available.
        if (!ping()) {
            return new ScannerNotAvailable(ERR_MALWARE_SCANNER_NOT_AVAILABLE);
        }
        try (final InputStream is = Files.newInputStream(pathToFile)) {
            final var response = new String(executorService.submit(() -> scan_(is)).get(timeout.toMillis(), TimeUnit.MILLISECONDS));
            // If no infection found, then it is either OK or an error.
            if (!response.contains("FOUND")) {
                // File passed the check.
                if (response.contains("OK")) {
                    return new Ok("OK");
                }
                // Otherwise, there was likely some error during scanning.
                else {
                    return new ScannerError(response);
                }
            }
            // Otherwise, return `Found` with `response`, which likely include the malware information.
            return new Found(response);
        } catch (final Exception ex) {
            return new ScannerError(ex.getMessage());
        }
    }

    private byte[] scan_(InputStream input) throws IOException {
        try (final var socket = new Socket(hostName, port);
             final var out = new BufferedOutputStream(socket.getOutputStream());
             final var in = new BufferedInputStream(socket.getInputStream());
             final var dataOut = new DataOutputStream(out))
        {
            socket.setSoTimeout((int) timeout.toMillis());

            // Send handshake
            dataOut.write("zINSTREAM\0".getBytes());
            dataOut.flush();

            // Stream file data
            final var buffer = new byte[CHUNK_SIZE];
            int bytesRead;
            while ((bytesRead = input.read(buffer)) != -1) {
                dataOut.writeInt(bytesRead);
                dataOut.write(buffer, 0, bytesRead);
                dataOut.flush();
            }

            // Send termination chunk
            dataOut.writeInt(0);
            dataOut.flush();

            // Read ClamAV response
            return in.readAllBytes();
        }
    }

    /**
     * Pings ClamAV to see if it is available.
     *
     * @return  `true` if ClamAV could be contacted withing the `timeout` period.
     */
    public boolean ping() {
        try {
            return executorService.submit(this::ping_).get(timeout.toMillis(), TimeUnit.MILLISECONDS);
        } catch (final Exception ex) {
            LOGGER.error("Could not ping ClamAV.", ex);
            return false;
        }
    }

    private boolean ping_() throws IOException {
        try (final var socket = new Socket(hostName, port);
             final var out = socket.getOutputStream();
             final var in = socket.getInputStream())
        {
            socket.setSoTimeout((int) timeout.toMillis());

            out.write("zPING\0".getBytes());
            out.flush();

            final byte[] response = in.readAllBytes();
            return Arrays.equals(response, "PONG\0".getBytes());
        }
    }

}
