package ua.com.fielden.platform.processors.verify;

import static ua.com.fielden.platform.processors.test_utils.Compilation.OPTION_PROC_ONLY;

import java.util.Arrays;
import java.util.Collection;
import java.util.List;
import java.util.function.Function;

import javax.annotation.processing.ProcessingEnvironment;
import javax.tools.JavaCompiler;
import javax.tools.JavaFileObject;
import javax.tools.ToolProvider;

import com.squareup.javapoet.JavaFile;
import com.squareup.javapoet.TypeSpec;

import ua.com.fielden.platform.processors.test_utils.Compilation;
import ua.com.fielden.platform.processors.test_utils.InMemoryJavaFileManager;
import ua.com.fielden.platform.processors.verify.verifiers.Verifier;

/**
 * Base class for unit tests targeted at {@link Verifier} implementations.
 * 
 * @author TG Team
 */
public abstract class VerifierAbstractTest {
    
    /**
     * Returns a provider of a {@link Verifier} implementation that will be initialized by the {@link VerifyingProcessor} during tests.
     * @return
     */
    abstract protected Function<ProcessingEnvironment, Verifier> verifierProvider();

    /**
     * Returns a new instance of the verifying processor that will initialize and use the sole verifier provided by {@link #verifierProvider()}.
     * @return
     */
    protected final VerifyingProcessor createProcessor() {
        return new VerifyingProcessor(List.of(verifierProvider()));
    }

    /**
     * Returns a ready-to-go compilation configuration with the java source prototypes {@code typeSpecs} as its inputs.
     * Only annotation processing will be performed, without subsequent compilation of inputs.
     * Any files generated by the annotation processor will be stored in memory.
     * <p>
     * <i>Note</i>: {@code typeSpecs} will be mapped to java sources belonging to a <i>default package</i> (empty package name).
     * @see {@link TypeSpec}
     * 
     * @param typeSpecs
     * @return
     */
    protected Compilation buildCompilation(final Collection<TypeSpec> typeSpecs) {
        final JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
        final InMemoryJavaFileManager fileManager = new InMemoryJavaFileManager(compiler.getStandardFileManager(null, null, null));
        final List<JavaFileObject> compilationTargets = typeSpecs.stream()
                .map(ts -> JavaFile.builder(/*packageName*/ "", ts).build().toJavaFileObject())
                .toList();

        return new Compilation(compilationTargets)
                .setProcessor(createProcessor())
                .setCompiler(compiler)
                .setFileManager(fileManager)
                .setOptions(OPTION_PROC_ONLY);
    }
    
    /** Refer to {@link #buildCompilation(Collection)}. */
    protected Compilation buildCompilation(final TypeSpec... typeSpecs) {
        return buildCompilation(Arrays.asList(typeSpecs));
    }
}
