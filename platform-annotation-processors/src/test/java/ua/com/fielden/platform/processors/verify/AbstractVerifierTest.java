package ua.com.fielden.platform.processors.verify;

import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;
import static ua.com.fielden.platform.processors.test_utils.Compilation.OPTION_PROC_ONLY;

import java.util.Arrays;
import java.util.Collection;
import java.util.List;
import java.util.Locale;
import java.util.Set;
import java.util.stream.Collectors;

import javax.annotation.processing.ProcessingEnvironment;
import javax.tools.JavaCompiler;
import javax.tools.JavaFileObject;
import javax.tools.ToolProvider;

import com.squareup.javapoet.JavaFile;
import com.squareup.javapoet.TypeSpec;

import ua.com.fielden.platform.processors.test_utils.Compilation;
import ua.com.fielden.platform.processors.test_utils.InMemoryJavaFileManager;
import ua.com.fielden.platform.processors.verify.verifiers.Verifier;

/**
 * Base class for unit tests targeted at {@link Verifier} implementations.
 *
 * @author TG Team
 */
public abstract class AbstractVerifierTest {

    /**
     * Returns a verifier instance that will be used by the {@link VerifyingProcessor} during tests.
     * <p>
     * In case of a test class that targets a composable verifier and contains nested test classes for its respective components
     * this method might be irrelevant.
     * @return
     */
    abstract protected Verifier createVerifier(final ProcessingEnvironment procEnv);

    /**
     * Returns a new instance of the verifying processor that will initialize and use the sole verifier provided by
     * {@link #createVerifier(ProcessingEnvironment)}.
     * @return
     */
    private final VerifyingProcessor createProcessor() {
        return new VerifyingProcessor(List.of(this::createVerifier));
    }

    /**
     * Returns a ready-to-go compilation configuration with the java source prototypes {@code typeSpecs} as its inputs.
     * Only annotation processing will be performed, without subsequent compilation of inputs.
     * Any files generated by the annotation processor will be stored in memory.
     * <p>
     * <i>Note</i>: {@code typeSpecs} will be mapped to java sources belonging to a <i>default package</i> (empty package name).
     * @see {@link TypeSpec}
     *
     * @param typeSpecs
     * @return
     */
    protected final Compilation buildCompilation(final Collection<TypeSpec> typeSpecs) {
        final JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
        final InMemoryJavaFileManager fileManager = new InMemoryJavaFileManager(compiler.getStandardFileManager(null, null, null));
        final List<JavaFileObject> compilationTargets = typeSpecs.stream()
                .map(ts -> JavaFile.builder(/*packageName*/ "", ts).build().toJavaFileObject())
                .toList();

        return new Compilation(compilationTargets)
                .setProcessor(createProcessor())
                .setCompiler(compiler)
                .setFileManager(fileManager)
                .setOptions(OPTION_PROC_ONLY);
    }

    /** Refer to {@link #buildCompilation(Collection)}. */
    protected final Compilation buildCompilation(final TypeSpec... typeSpecs) {
        return buildCompilation(Arrays.asList(typeSpecs));
    }

    /**
     * A convenient method to compile {@code typeSpecs} and asssert that certain error messages were reported.
     * @return the resulting compilation instance
     */
    protected final Compilation compileAndAssertErrors(final Collection<TypeSpec> typeSpecs, final String... expectedErrorMessages) {
        return compileAndAssertErrors(typeSpecs, List.of(expectedErrorMessages));
    }

    /**
     * A convenient method to compile {@code typeSpecs} and asssert that certain error messages were reported.
     * <p>
     * If some errors were reported that were not expected (i.e. not specified by {@code expectedErrorMessages}) then a runtime exception is thrown
     * and all diagnostic messages are printed to standard output.
     *
     * @return the resulting compilation instance
     */
    protected final Compilation compileAndAssertErrors(final Collection<TypeSpec> typeSpecs, final Collection<String> expectedErrorMessages) {
        final Compilation compilation = buildCompilation(typeSpecs);
        final boolean success = compilation.compile();

        if (success) {
            compilation.printDiagnostics();
            fail("Compilaton should have failed.");
        }

        // first assert that all expected errors were reported
        final Set<String> uniqueErrorMessages = compilation.getErrors().stream()
                .map(err -> err.getMessage(Locale.getDefault())).collect(Collectors.toSet());
        expectedErrorMessages.forEach(
                msg -> assertTrue("No error was reported with message [%s].".formatted(msg), uniqueErrorMessages.contains(msg)));

        // now test for unexpected errors
        final List<String> errorMessages = compilation.getErrors().stream().map(diag -> diag.getMessage(Locale.getDefault())).toList();
        if (errorMessages.size() != expectedErrorMessages.size()) {
            compilation.printDiagnostics();
            fail("Unexpected errors were reported.");
        }

        return compilation;
    }

    /**
     * A convenient method to compile {@code typeSpecs} and asssert compilation successs.
     * In the case of an unsuccessful compilation, all diagnostic messages are printed to standard output.
     *
     * @return the resulting compilation instance
     */
    protected final Compilation compileAndAssertSuccess(final Collection<TypeSpec> typeSpecs) {
        final Compilation compilation = buildCompilation(typeSpecs);
        final boolean success = compilation.compile();

        if (!success) {
            compilation.printDiagnostics();
            fail("Compilation should have succeeded.");
        }

        return compilation;
    }

}
