package ua.com.fielden.platform.processors.verify;

import static org.junit.Assert.fail;
import static ua.com.fielden.platform.processors.test_utils.Compilation.OPTION_PROC_ONLY;

import java.util.Arrays;
import java.util.Collection;
import java.util.List;
import java.util.Locale;
import java.util.Set;
import java.util.stream.Collectors;

import javax.annotation.processing.ProcessingEnvironment;
import javax.tools.Diagnostic.Kind;
import javax.tools.JavaFileObject;

import com.squareup.javapoet.JavaFile;
import com.squareup.javapoet.TypeSpec;

import ua.com.fielden.platform.processors.test_utils.Compilation;
import ua.com.fielden.platform.processors.test_utils.CompilationResult;
import ua.com.fielden.platform.processors.verify.verifiers.IVerifier;

/**
 * Base class for unit tests targeted at {@link IVerifier} implementations.
 *
 * @author TG Team
 */
public abstract class AbstractVerifierTest {

    /**
     * Returns a verifier instance that will be used by the {@link VerifyingProcessor} during tests.
     * <p>
     * In case of a test class that targets a composable verifier and contains nested test classes for its respective components
     * this method might be irrelevant.
     * @return
     */
    abstract protected IVerifier createVerifier(final ProcessingEnvironment procEnv);

    /**
     * Returns a new instance of the verifying processor that will initialize and use the sole verifier provided by
     * {@link #createVerifier(ProcessingEnvironment)}.
     * @return
     */
    private final VerifyingProcessor createProcessor() {
        return new VerifyingProcessor(List.of(this::createVerifier));
    }

    /**
     * Returns a ready-to-go compilation configuration with the java source prototypes {@code typeSpecs} as its inputs.
     * Only annotation processing will be performed, without subsequent compilation of inputs.
     * Any files generated by the annotation processor will be stored in memory.
     * <p>
     * <i>Note</i>: {@code typeSpecs} will be mapped to java sources belonging to a <i>default package</i> (empty package name).
     * @see {@link TypeSpec}
     *
     * @param typeSpecs
     * @return
     */
    protected final Compilation buildCompilation(final Collection<TypeSpec> typeSpecs) {
        final List<JavaFileObject> compilationTargets = typeSpecs.stream()
                .map(ts -> JavaFile.builder(/*packageName*/ "", ts).build().toJavaFileObject())
                .toList();

        return Compilation.newInMemory(compilationTargets)
                .setProcessor(createProcessor())
                .setOptions(OPTION_PROC_ONLY);
    }

    /** Refer to {@link #buildCompilation(Collection)}. */
    protected final Compilation buildCompilation(final TypeSpec... typeSpecs) {
        return buildCompilation(Arrays.asList(typeSpecs));
    }

    /**
     * Another signature for {@link #compileAndAssertErrors(Collection, Collection)}.
     */
    protected final CompilationResult compileAndAssertErrors(final Collection<TypeSpec> typeSpecs, final String... expectedErrorMessages) {
        return compileAndAssertErrors(typeSpecs, List.of(expectedErrorMessages));
    }

    /**
     * A convenient method to compile {@code typeSpecs} and asssert that certain error messages were reported.
     * <p>
     * If some errors were reported that were not expected (i.e. not specified by {@code expectedErrorMessages}) then the assertion fails
     * and all diagnostic messages are printed to standard output.
     *
     * @return results of the compilation
     */
    protected final CompilationResult compileAndAssertErrors(final Collection<TypeSpec> typeSpecs, final Collection<String> expectedErrorMessages) {
        final Compilation compilation = buildCompilation(typeSpecs);
        final CompilationResult result = compilation.compile();
        assertTrueOrFailWith("Compilaton should have failed.", result.failure(), () -> result.printDiagnostics());

        // first assert that all expected errors were reported
        final Set<String> uniqueErrorMessages = result.errors().stream()
                .map(err -> err.getMessage(Locale.getDefault())).collect(Collectors.toSet());
        expectedErrorMessages.forEach(
                msg -> assertTrueOrFailWith("No error was reported with message [%s].".formatted(msg),
                        uniqueErrorMessages.contains(msg), () -> result.printDiagnostics()));

        // now test for unexpected errors
        final int diff = result.errors().size() - expectedErrorMessages.size();
        assertTrueOrFailWith("%s unexpected error(s) were reported.".formatted(diff), diff == 0, () -> result.printDiagnostics());

        return result;
    }

    /**
     * A convenient method to compile {@code typeSpecs} and asssert compilation successs.
     * <p>
     * In the case of an unsuccessful compilation, the assertion fails and all diagnostic messages are printed to standard output.
     *
     * @return results of the compilation
     */
    protected final CompilationResult compileAndAssertSuccess(final Collection<TypeSpec> typeSpecs) {
        final Compilation compilation = buildCompilation(typeSpecs);
        final CompilationResult result = compilation.compile();
        assertTrueOrFailWith("Compilation should have succeeded.", result.success(), () -> result.printDiagnostics());

        return result;
    }

    /**
     * Asserts that diagnostic messages of a given kind were reported as a result of a compilation.
     *
     * @param result    represents compilation results
     * @param kind      the message kind
     * @param messages  the messages, existence of which is to be asserted
     */
    protected final void assertMessages(final CompilationResult result, final Kind kind, final String... messages) {
        Arrays.stream(messages).forEach(msg -> assertMessage(result, kind, msg));
    }

    private final void assertMessage(final CompilationResult result, final Kind kind, final String message) {
        assertTrueOrFailWith("No %s was reported with message \"%s\"".formatted(kind, message),
                result.diagnosticsByKind(kind).stream().anyMatch(diag -> diag.getMessage(Locale.getDefault()).equals(message)),
                () -> result.printDiagnostics());
    }

    private void assertTrueOrFailWith(final String message, boolean condition, final Runnable failAction) {
        if (!condition) {
            failAction.run();
            fail(message);
        }
    }

}
